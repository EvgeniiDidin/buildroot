From 2b95fa4e6ed7fc8ae25797effb74372fc43a3728 Mon Sep 17 00:00:00 2001
From: Evgeniy Didin <didin@synopsys.com>
Date: Fri, 22 Jun 2018 17:49:52 +0300
Subject: [PATCH] switch log_debug to log_info for debug purposes

Signed-off-by: Evgeniy Didin <didin@synopsys.com>
---
 src/analyze/analyze-verify.c                  |   6 +-
 src/analyze/analyze.c                         |   2 +-
 src/backlight/backlight.c                     |   4 +-
 src/basic/audit-util.c                        |   2 +-
 src/basic/blockdev-util.c                     |   4 +-
 src/basic/capability-util.c                   |   2 +-
 src/basic/cgroup-util.c                       |  24 +--
 src/basic/conf-files.c                        |  14 +-
 src/basic/crypt-util.c                        |   2 +-
 src/basic/exec-util.c                         |   2 +-
 src/basic/fileio.c                            |   6 +-
 src/basic/journal-importer.c                  |  10 +-
 src/basic/locale-util.c                       |   4 +-
 src/basic/log.h                               |   6 +-
 src/basic/mount-util.c                        |  22 +--
 src/basic/path-util.c                         |   6 +-
 src/basic/process-util.c                      |  20 +--
 src/basic/selinux-util.c                      |   2 +-
 src/basic/smack-util.c                        |   2 +-
 src/basic/socket-util.c                       |   2 +-
 src/basic/terminal-util.c                     |   4 +-
 src/basic/time-util.c                         |   4 +-
 src/basic/user-util.c                         |   2 +-
 src/basic/util.c                              |   2 +-
 src/basic/verbs.c                             |   4 +-
 src/basic/virt.c                              |  66 ++++----
 src/binfmt/binfmt.c                           |   2 +-
 src/boot/bootctl.c                            |   2 +-
 src/cgroups-agent/cgroups-agent.c             |   6 +-
 src/cgtop/cgtop.c                             |   2 +-
 src/core/automount.c                          |   4 +-
 src/core/bpf-firewall.c                       |  20 +--
 src/core/cgroup.c                             |  18 +-
 src/core/dbus-job.c                           |   4 +-
 src/core/dbus-manager.c                       |   8 +-
 src/core/dbus.c                               |  14 +-
 src/core/dynamic-user.c                       |  10 +-
 src/core/execute.c                            |   4 +-
 src/core/ima-setup.c                          |   4 +-
 src/core/job.c                                |  22 +--
 src/core/kmod-setup.c                         |   4 +-
 src/core/load-fragment.c                      |   2 +-
 src/core/loopback-setup.c                     |   4 +-
 src/core/machine-id-setup.c                   |   2 +-
 src/core/main.c                               |  12 +-
 src/core/manager.c                            |  28 +--
 src/core/mount-setup.c                        |   2 +-
 src/core/mount.c                              |   2 +-
 src/core/namespace.c                          |  42 ++---
 src/core/path.c                               |   2 +-
 src/core/scope.c                              |   2 +-
 src/core/selinux-access.c                     |   2 +-
 src/core/selinux-setup.c                      |   2 +-
 src/core/shutdown.c                           |   2 +-
 src/core/slice.c                              |   6 +-
 src/core/smack-setup.c                        |  16 +-
 src/core/swap.c                               |   2 +-
 src/core/target.c                             |   6 +-
 src/core/transaction.c                        |  10 +-
 src/coredump/coredump.c                       |  12 +-
 src/coredump/coredumpctl.c                    |  12 +-
 src/cryptsetup/cryptsetup.c                   |   2 +-
 src/delta/delta.c                             |  16 +-
 src/fsck/fsck.c                               |   2 +-
 src/fstab-generator/fstab-generator.c         |  18 +-
 src/getty-generator/getty-generator.c         |   6 +-
 src/gpt-auto-generator/gpt-auto-generator.c   |  46 ++---
 src/hwdb/hwdb.c                               |  32 ++--
 src/import/curl-util.c                        |   4 +-
 src/import/export-tar.c                       |   2 +-
 src/import/importd.c                          |   4 +-
 src/import/pull-job.c                         |   4 +-
 src/import/pull-raw.c                         |   4 +-
 src/import/pull-tar.c                         |   4 +-
 src/initctl/initctl.c                         |   6 +-
 src/journal-remote/journal-remote-parse.c     |   4 +-
 src/journal-remote/journal-remote-write.c     |   8 +-
 src/journal-remote/journal-remote.c           |  38 ++---
 src/journal-remote/journal-upload-journal.c   |  14 +-
 src/journal-remote/journal-upload.c           |  18 +-
 src/journal-remote/microhttpd-util.c          |  10 +-
 src/journal/catalog.c                         |  10 +-
 src/journal/compress.c                        |  26 +--
 src/journal/journal-authenticate.c            |   8 +-
 src/journal/journal-file.c                    |  96 +++++------
 src/journal/journal-vacuum.c                  |   6 +-
 src/journal/journal-verify.c                  |   2 +-
 src/journal/journalctl.c                      |   8 +-
 src/journal/journald-audit.c                  |  10 +-
 src/journal/journald-console.c                |   4 +-
 src/journal/journald-kmsg.c                   |   4 +-
 src/journal/journald-native.c                 |  10 +-
 src/journal/journald-server.c                 |  26 +--
 src/journal/journald-stream.c                 |   4 +-
 src/journal/journald-syslog.c                 |   2 +-
 src/journal/journald-wall.c                   |   2 +-
 src/journal/journald.c                        |   4 +-
 src/journal/sd-journal.c                      |  46 ++---
 src/journal/test-compress-benchmark.c         |   2 +-
 src/journal/test-compress.c                   |  10 +-
 src/libsystemd-network/dhcp-packet.c          |  18 +-
 src/libsystemd-network/sd-dhcp-lease.c        |  76 ++++-----
 src/libsystemd/sd-bus/bus-control.c           |  22 +--
 src/libsystemd/sd-bus/bus-internal.c          |   2 +-
 src/libsystemd/sd-bus/bus-socket.c            |  16 +-
 src/libsystemd/sd-bus/bus-track.c             |   2 +-
 src/libsystemd/sd-bus/sd-bus.c                |  26 +--
 src/libsystemd/sd-bus/test-bus-watch-bind.c   |  16 +-
 src/libsystemd/sd-device/device-enumerator.c  |  20 +--
 src/libsystemd/sd-device/device-private.c     |  46 ++---
 src/libsystemd/sd-device/sd-device.c          |  34 ++--
 src/libsystemd/sd-event/sd-event.c            |  12 +-
 src/libsystemd/sd-hwdb/sd-hwdb.c              |  22 +--
 src/libsystemd/sd-netlink/netlink-message.c   |   2 +-
 src/libsystemd/sd-netlink/netlink-socket.c    |  12 +-
 src/libsystemd/sd-netlink/sd-netlink.c        |  12 +-
 src/libudev/libudev-monitor.c                 |  38 ++---
 src/libudev/libudev-util.c                    |   4 +-
 src/locale/keymap-util.c                      |   8 +-
 src/locale/localed.c                          |   4 +-
 src/login/logind-acl.c                        |   8 +-
 src/login/logind-action.c                     |  10 +-
 src/login/logind-button.c                     |   2 +-
 src/login/logind-core.c                       |   4 +-
 src/login/logind-dbus.c                       |   2 +-
 src/login/logind-inhibit.c                    |   4 +-
 src/login/logind-seat.c                       |   4 +-
 src/login/logind-session-dbus.c               |   2 +-
 src/login/logind-session.c                    |   2 +-
 src/login/logind-user.c                       |  12 +-
 src/login/logind.c                            |  10 +-
 src/machine/machinectl.c                      |   2 +-
 src/machine/machined-dbus.c                   |   2 +-
 src/machine/machined.c                        |   4 +-
 src/machine/operation.c                       |   4 +-
 src/modules-load/modules-load.c               |   6 +-
 src/mount/mount-tool.c                        |  28 +--
 src/network/netdev/netdev.c                   |   2 +-
 src/network/networkctl.c                      |   4 +-
 src/network/networkd-address-pool.c           |   2 +-
 src/network/networkd-dhcp4.c                  |   2 +-
 src/network/networkd-link.c                   |   6 +-
 src/network/networkd-manager.c                |  18 +-
 src/network/networkd-network.c                |   6 +-
 src/network/wait-online/manager.c             |  10 +-
 src/nspawn/nspawn-expose-ports.c              |   4 +-
 src/nspawn/nspawn-mount.c                     |   2 +-
 src/nspawn/nspawn-patch-uid.c                 |   2 +-
 src/nspawn/nspawn-register.c                  |   6 +-
 src/nspawn/nspawn-seccomp.c                   |  16 +-
 src/nspawn/nspawn.c                           |  22 +--
 src/partition/growfs.c                        |  10 +-
 src/random-seed/random-seed.c                 |   2 +-
 src/rc-local-generator/rc-local-generator.c   |   4 +-
 src/remount-fs/remount-fs.c                   |   2 +-
 src/resolve/resolve-tool.c                    |  30 ++--
 src/resolve/resolved-bus.c                    |   6 +-
 src/resolve/resolved-conf.c                   |   2 +-
 src/resolve/resolved-dns-cache.c              |  22 +--
 src/resolve/resolved-dns-dnssec.c             |   8 +-
 src/resolve/resolved-dns-packet.c             |  12 +-
 src/resolve/resolved-dns-query.c              |  10 +-
 src/resolve/resolved-dns-scope.c              |  44 ++---
 src/resolve/resolved-dns-server.c             |  16 +-
 src/resolve/resolved-dns-stream.c             |   4 +-
 src/resolve/resolved-dns-stub.c               |  42 ++---
 src/resolve/resolved-dns-transaction.c        |  90 +++++-----
 src/resolve/resolved-dns-zone.c               |  10 +-
 src/resolve/resolved-dnssd.c                  |   4 +-
 src/resolve/resolved-link.c                   |   8 +-
 src/resolve/resolved-llmnr.c                  |  14 +-
 src/resolve/resolved-manager.c                |  14 +-
 src/resolve/resolved-mdns.c                   |  26 +--
 src/resolve/resolved-resolv-conf.c            |   2 +-
 src/resolve/test-resolved-packet.c            |   2 +-
 src/rfkill/rfkill.c                           |  26 +--
 src/shared/ask-password-api.c                 |  16 +-
 src/shared/bootspec.c                         |  10 +-
 src/shared/bus-unit-util.c                    |   4 +-
 src/shared/clean-ipc.c                        |  12 +-
 src/shared/condition.c                        |   6 +-
 src/shared/dev-setup.c                        |   4 +-
 src/shared/dissect-image.c                    |  36 ++--
 src/shared/dns-domain.c                       |   8 +-
 src/shared/fdset.c                            |   2 +-
 src/shared/generator.c                        |  10 +-
 src/shared/import-util.c                      |   4 +-
 src/shared/install.c                          |  30 ++--
 src/shared/logs-show.c                        |  16 +-
 src/shared/loop-util.c                        |   6 +-
 src/shared/machine-image.c                    |  36 ++--
 src/shared/machine-pool.c                     |   4 +-
 src/shared/path-lookup.c                      |   6 +-
 src/shared/ptyfwd.c                           |   4 +-
 src/shared/seccomp-util.c                     |  78 ++++-----
 src/shared/sleep-config.c                     |   4 +-
 src/shared/sysctl-util.c                      |   2 +-
 src/shared/udev-util.c                        |   2 +-
 src/sleep/sleep.c                             |   4 +-
 src/socket-proxy/socket-proxyd.c              |   4 +-
 src/sysctl/sysctl.c                           |   4 +-
 src/systemctl/systemctl.c                     |  36 ++--
 src/sysusers/sysusers.c                       |  24 +--
 src/sysv-generator/sysv-generator.c           |  10 +-
 src/test/test-conf-files.c                    |   6 +-
 src/test/test-dns-domain.c                    |   2 +-
 src/test/test-escape.c                        |   2 +-
 src/test/test-mount-util.c                    |   6 +-
 src/test/test-nss.c                           |   8 +-
 src/test/test-socket-util.c                   |   2 +-
 src/test/test-tmpfiles.c                      |   4 +-
 src/test/test-udev.c                          |   4 +-
 src/timedate/timedated.c                      |   2 +-
 src/timesync/timesyncd-manager.c              |  50 +++---
 src/timesync/timesyncd-server.c               |   4 +-
 src/timesync/timesyncd.c                      |   2 +-
 src/tmpfiles/tmpfiles.c                       | 130 +++++++-------
 .../tty-ask-password-agent.c                  |  12 +-
 src/udev/ata_id/ata_id.c                      |   2 +-
 src/udev/cdrom_id/cdrom_id.c                  | 160 +++++++++---------
 src/udev/net/link-config.c                    |   6 +-
 src/udev/scsi_id/scsi_serial.c                |  60 +++----
 src/udev/udev-builtin-blkid.c                 |   4 +-
 src/udev/udev-builtin-input_id.c              |  16 +-
 src/udev/udev-builtin-keyboard.c              |   6 +-
 src/udev/udev-builtin-kmod.c                  |  16 +-
 src/udev/udev-builtin-net_setup_link.c        |   8 +-
 src/udev/udev-builtin-usb_id.c                |  24 +--
 src/udev/udev-event.c                         |  16 +-
 src/udev/udev-node.c                          |  30 ++--
 src/udev/udev-rules.c                         |  96 +++++------
 src/udev/udev-watch.c                         |   6 +-
 src/udev/udevadm-hwdb.c                       |  32 ++--
 src/udev/udevadm-settle.c                     |   4 +-
 src/udev/udevadm-test.c                       |   2 +-
 src/udev/udevadm-trigger.c                    |   2 +-
 src/udev/udevadm.c                            |   2 +-
 src/udev/udevd.c                              |  48 +++---
 src/update-done/update-done.c                 |   2 +-
 src/update-utmp/update-utmp.c                 |   4 +-
 src/vconsole/vconsole-setup.c                 |  10 +-
 src/veritysetup/veritysetup-generator.c       |   4 +-
 242 files changed, 1612 insertions(+), 1612 deletions(-)

diff --git a/src/analyze/analyze-verify.c b/src/analyze/analyze-verify.c
index f475b6598..d2256d379 100644
--- a/src/analyze/analyze-verify.c
+++ b/src/analyze/analyze-verify.c
@@ -271,7 +271,7 @@ int verify_units(char **filenames, UnitFileScope scope, bool check_man, bool run
         if (r < 0)
                 return log_error_errno(r, "Failed to initialize manager: %m");
 
-        log_debug("Starting manager...");
+        log_info("Starting manager...");
 
         r = manager_startup(m, serial, fdset);
         if (r < 0) {
@@ -281,12 +281,12 @@ int verify_units(char **filenames, UnitFileScope scope, bool check_man, bool run
 
         manager_clear_jobs(m);
 
-        log_debug("Loading remaining units from the command line...");
+        log_info("Loading remaining units from the command line...");
 
         STRV_FOREACH(filename, filenames) {
                 _cleanup_free_ char *prepared = NULL;
 
-                log_debug("Handling %s...", *filename);
+                log_info("Handling %s...", *filename);
 
                 k = prepare_filename(*filename, &prepared);
                 if (k < 0) {
diff --git a/src/analyze/analyze.c b/src/analyze/analyze.c
index 834620a4c..c54d7931b 100644
--- a/src/analyze/analyze.c
+++ b/src/analyze/analyze.c
@@ -475,7 +475,7 @@ static int acquire_host_info(sd_bus *bus, struct host_info **hi) {
                                    &error,
                                    host);
         if (r < 0)
-                log_debug_errno(r, "Failed to get host information from systemd-hostnamed: %s", bus_error_message(&error, r));
+                log_info_errno(r, "Failed to get host information from systemd-hostnamed: %s", bus_error_message(&error, r));
 
         r = bus_map_all_properties(bus,
                                    "org.freedesktop.systemd1",
diff --git a/src/backlight/backlight.c b/src/backlight/backlight.c
index 8fedf8ebb..d7cc909c3 100644
--- a/src/backlight/backlight.c
+++ b/src/backlight/backlight.c
@@ -182,7 +182,7 @@ static bool validate_device(struct udev *udev, struct udev_device *device) {
                 if (same_device(parent, other_parent)) {
                         /* Both have the same PCI parent, that means
                          * we are out. */
-                        log_debug("Skipping backlight device %s, since device %s is on same PCI device and takes precedence.",
+                        log_info("Skipping backlight device %s, since device %s is on same PCI device and takes precedence.",
                                   udev_device_get_sysname(device),
                                   udev_device_get_sysname(other));
                         return false;
@@ -193,7 +193,7 @@ static bool validate_device(struct udev *udev, struct udev_device *device) {
                         /* The other is connected to the platform bus
                          * and we are a PCI device, that also means we
                          * are out. */
-                        log_debug("Skipping backlight device %s, since device %s is a platform device and takes precedence.",
+                        log_info("Skipping backlight device %s, since device %s is a platform device and takes precedence.",
                                   udev_device_get_sysname(device),
                                   udev_device_get_sysname(other));
                         return false;
diff --git a/src/basic/audit-util.c b/src/basic/audit-util.c
index 6a93c9109..80a1fa88c 100644
--- a/src/basic/audit-util.c
+++ b/src/basic/audit-util.c
@@ -96,7 +96,7 @@ bool use_audit(void) {
                 if (fd < 0) {
                         cached_use = !IN_SET(errno, EAFNOSUPPORT, EPROTONOSUPPORT, EPERM);
                         if (errno == EPERM)
-                                log_debug_errno(errno, "Audit access prohibited, won't talk to audit");
+                                log_info_errno(errno, "Audit access prohibited, won't talk to audit");
                 }
                 else {
                         cached_use = true;
diff --git a/src/basic/blockdev-util.c b/src/basic/blockdev-util.c
index 3a8f8d1c2..7e9122226 100644
--- a/src/basic/blockdev-util.c
+++ b/src/basic/blockdev-util.c
@@ -154,13 +154,13 @@ int get_block_device_harder(const char *path, dev_t *dev) {
 
                         r = read_one_line_file(u, &a);
                         if (r < 0) {
-                                log_debug_errno(r, "Failed to read %s: %m", u);
+                                log_info_errno(r, "Failed to read %s: %m", u);
                                 goto fallback;
                         }
 
                         r = read_one_line_file(v, &b);
                         if (r < 0) {
-                                log_debug_errno(r, "Failed to read %s: %m", v);
+                                log_info_errno(r, "Failed to read %s: %m", v);
                                 goto fallback;
                         }
 
diff --git a/src/basic/capability-util.c b/src/basic/capability-util.c
index 97778c55a..eaa852fe1 100644
--- a/src/basic/capability-util.c
+++ b/src/basic/capability-util.c
@@ -181,7 +181,7 @@ int capability_bounding_set_drop(uint64_t keep, bool right_now) {
                         return -errno;
 
                 if (cap_set_proc(temp_cap) < 0)
-                        log_debug_errno(errno, "Can't acquire effective CAP_SETPCAP bit, ignoring: %m");
+                        log_info_errno(errno, "Can't acquire effective CAP_SETPCAP bit, ignoring: %m");
 
                 /* If we didn't manage to acquire the CAP_SETPCAP bit, we continue anyway, after all this just means
                  * we'll fail later, when we actually intend to drop some capabilities. */
diff --git a/src/basic/cgroup-util.c b/src/basic/cgroup-util.c
index 7c0ba9211..504e2174d 100644
--- a/src/basic/cgroup-util.c
+++ b/src/basic/cgroup-util.c
@@ -942,7 +942,7 @@ int cg_set_access(
                         if (i->fatal)
                                 return r;
 
-                        log_debug_errno(r, "Failed to set access on cgroup %s, ignoring: %m", fs);
+                        log_info_errno(r, "Failed to set access on cgroup %s, ignoring: %m", fs);
                 }
         }
 
@@ -954,7 +954,7 @@ int cg_set_access(
                         /* Always propagate access mode from unified to legacy controller */
                         r = cg_set_access(SYSTEMD_CGROUP_CONTROLLER_LEGACY, path, uid, gid);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to set access on compatibility systemd cgroup %s, ignoring: %m", path);
+                                log_info_errno(r, "Failed to set access on compatibility systemd cgroup %s, ignoring: %m", path);
                 }
         }
 
@@ -2440,36 +2440,36 @@ static int cg_unified_update(void) {
                 return 0;
 
         if (statfs("/sys/fs/cgroup/", &fs) < 0)
-                return log_debug_errno(errno, "statfs(\"/sys/fs/cgroup/\" failed: %m");
+                return log_info_errno(errno, "statfs(\"/sys/fs/cgroup/\" failed: %m");
 
         if (F_TYPE_EQUAL(fs.f_type, CGROUP2_SUPER_MAGIC)) {
-                log_debug("Found cgroup2 on /sys/fs/cgroup/, full unified hierarchy");
+                log_info("Found cgroup2 on /sys/fs/cgroup/, full unified hierarchy");
                 unified_cache = CGROUP_UNIFIED_ALL;
         } else if (F_TYPE_EQUAL(fs.f_type, TMPFS_MAGIC)) {
                 if (statfs("/sys/fs/cgroup/unified/", &fs) == 0 &&
                     F_TYPE_EQUAL(fs.f_type, CGROUP2_SUPER_MAGIC)) {
-                        log_debug("Found cgroup2 on /sys/fs/cgroup/unified, unified hierarchy for systemd controller");
+                        log_info("Found cgroup2 on /sys/fs/cgroup/unified, unified hierarchy for systemd controller");
                         unified_cache = CGROUP_UNIFIED_SYSTEMD;
                         unified_systemd_v232 = false;
                 } else {
                         if (statfs("/sys/fs/cgroup/systemd/", &fs) < 0)
-                                return log_debug_errno(errno, "statfs(\"/sys/fs/cgroup/systemd\" failed: %m");
+                                return log_info_errno(errno, "statfs(\"/sys/fs/cgroup/systemd\" failed: %m");
 
                         if (F_TYPE_EQUAL(fs.f_type, CGROUP2_SUPER_MAGIC)) {
-                                log_debug("Found cgroup2 on /sys/fs/cgroup/systemd, unified hierarchy for systemd controller (v232 variant)");
+                                log_info("Found cgroup2 on /sys/fs/cgroup/systemd, unified hierarchy for systemd controller (v232 variant)");
                                 unified_cache = CGROUP_UNIFIED_SYSTEMD;
                                 unified_systemd_v232 = true;
                         } else if (F_TYPE_EQUAL(fs.f_type, CGROUP_SUPER_MAGIC)) {
-                                log_debug("Found cgroup on /sys/fs/cgroup/systemd, legacy hierarchy");
+                                log_info("Found cgroup on /sys/fs/cgroup/systemd, legacy hierarchy");
                                 unified_cache = CGROUP_UNIFIED_NONE;
                         } else {
-                                log_debug("Unexpected filesystem type %llx mounted on /sys/fs/cgroup/systemd, assuming legacy hierarchy",
+                                log_info("Unexpected filesystem type %llx mounted on /sys/fs/cgroup/systemd, assuming legacy hierarchy",
                                           (unsigned long long) fs.f_type);
                                 unified_cache = CGROUP_UNIFIED_NONE;
                         }
                 }
         } else {
-                log_debug("Unknown filesystem type %llx mounted on /sys/fs/cgroup.",
+                log_info("Unknown filesystem type %llx mounted on /sys/fs/cgroup.",
                           (unsigned long long) fs.f_type);
                 return -ENOMEDIUM;
         }
@@ -2557,14 +2557,14 @@ int cg_enable_everywhere(CGroupMask supported, CGroupMask mask, const char *p) {
                         if (!f) {
                                 f = fopen(fs, "we");
                                 if (!f) {
-                                        log_debug_errno(errno, "Failed to open cgroup.subtree_control file of %s: %m", p);
+                                        log_info_errno(errno, "Failed to open cgroup.subtree_control file of %s: %m", p);
                                         break;
                                 }
                         }
 
                         r = write_string_stream(f, s, 0);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to enable controller %s for %s (%s): %m", n, p, fs);
+                                log_info_errno(r, "Failed to enable controller %s for %s (%s): %m", n, p, fs);
                 }
         }
 
diff --git a/src/basic/conf-files.c b/src/basic/conf-files.c
index c0ac202f5..64f68966f 100644
--- a/src/basic/conf-files.c
+++ b/src/basic/conf-files.c
@@ -59,7 +59,7 @@ static int files_add(Hashmap *h, const char *suffix, const char *root, unsigned
                 char *p;
 
                 if (!dirent_is_file_with_suffix(de, suffix)) {
-                        log_debug("Ignoring %s/%s, because it's not a regular file with suffix %s.", dirpath, de->d_name, strna(suffix));
+                        log_info("Ignoring %s/%s, because it's not a regular file with suffix %s.", dirpath, de->d_name, strna(suffix));
                         continue;
                 }
 
@@ -71,7 +71,7 @@ static int files_add(Hashmap *h, const char *suffix, const char *root, unsigned
                          * executable for us, because if such errors are stuff we should log about. */
 
                         if (fstatat(dirfd(dir), de->d_name, &st, 0) < 0) {
-                                log_debug_errno(errno, "Failed to stat %s/%s, ignoring: %m", dirpath, de->d_name);
+                                log_info_errno(errno, "Failed to stat %s/%s, ignoring: %m", dirpath, de->d_name);
                                 continue;
                         }
 
@@ -81,12 +81,12 @@ static int files_add(Hashmap *h, const char *suffix, const char *root, unsigned
                                  * or symlinks to them. */
                                 if (S_ISREG(st.st_mode)) {
                                         if ((st.st_mode & 0111) == 0) { /* not executable */
-                                                log_debug("Ignoring %s/%s, as it is not marked executable.",
+                                                log_info("Ignoring %s/%s, as it is not marked executable.",
                                                           dirpath, de->d_name);
                                                 continue;
                                         }
                                 } else {
-                                        log_debug("Ignoring %s/%s, as it is neither a regular file nor a mask.",
+                                        log_info("Ignoring %s/%s, as it is neither a regular file nor a mask.",
                                                   dirpath, de->d_name);
                                         continue;
                                 }
@@ -99,13 +99,13 @@ static int files_add(Hashmap *h, const char *suffix, const char *root, unsigned
 
                 r = hashmap_put(h, basename(p), p);
                 if (r == -EEXIST) {
-                        log_debug("Skipping overridden file: %s.", p);
+                        log_info("Skipping overridden file: %s.", p);
                         free(p);
                 } else if (r < 0) {
                         free(p);
                         return r;
                 } else if (r == 0) {
-                        log_debug("Duplicate file %s", p);
+                        log_info("Duplicate file %s", p);
                         free(p);
                 }
         }
@@ -141,7 +141,7 @@ static int conf_files_list_strv_internal(char ***strv, const char *suffix, const
                 if (r == -ENOMEM)
                         return r;
                 if (r < 0)
-                        log_debug_errno(r, "Failed to search for files in %s, ignoring: %m", *p);
+                        log_info_errno(r, "Failed to search for files in %s, ignoring: %m", *p);
         }
 
         files = hashmap_get_strv(fh);
diff --git a/src/basic/crypt-util.c b/src/basic/crypt-util.c
index 193cf65df..24d1416a1 100644
--- a/src/basic/crypt-util.c
+++ b/src/basic/crypt-util.c
@@ -22,6 +22,6 @@
 #include "log.h"
 
 void cryptsetup_log_glue(int level, const char *msg, void *usrptr) {
-        log_debug("%s", msg);
+        log_info("%s", msg);
 }
 #endif
diff --git a/src/basic/exec-util.c b/src/basic/exec-util.c
index 0829b3d83..f84e910a7 100644
--- a/src/basic/exec-util.c
+++ b/src/basic/exec-util.c
@@ -51,7 +51,7 @@ static int do_spawn(const char *path, char *argv[], int stdout_fd, pid_t *pid) {
         int r;
 
         if (null_or_empty_path(path)) {
-                log_debug("%s is empty (a mask).", path);
+                log_info("%s is empty (a mask).", path);
                 return 0;
         }
 
diff --git a/src/basic/fileio.c b/src/basic/fileio.c
index 26d617466..22bc3a872 100644
--- a/src/basic/fileio.c
+++ b/src/basic/fileio.c
@@ -1437,7 +1437,7 @@ int open_tmpfile_linkable(const char *target, int flags, char **ret_path) {
                         return fd;
                 }
 
-                log_debug_errno(errno, "Failed to use O_TMPFILE on %s: %m", dn);
+                log_info_errno(errno, "Failed to use O_TMPFILE on %s: %m", dn);
         }
 
         r = tempfn_random(target, NULL, &tmp);
@@ -1466,9 +1466,9 @@ int open_serialization_fd(const char *ident) {
                 if (fd < 0)
                         return fd;
 
-                log_debug("Serializing %s to %s.", ident, path);
+                log_info("Serializing %s to %s.", ident, path);
         } else
-                log_debug("Serializing %s to memfd.", ident);
+                log_info("Serializing %s to memfd.", ident);
 
         return fd;
 }
diff --git a/src/basic/journal-importer.c b/src/basic/journal-importer.c
index 11054589e..6fff7344c 100644
--- a/src/basic/journal-importer.c
+++ b/src/basic/journal-importer.c
@@ -68,7 +68,7 @@ size_t iovw_size(struct iovec_wrapper *iovw) {
 
 void journal_importer_cleanup(JournalImporter *imp) {
         if (imp->fd >= 0 && !imp->passive_fd) {
-                log_debug("Closing %s (fd=%d)", imp->name ?: "importer", imp->fd);
+                log_info("Closing %s (fd=%d)", imp->name ?: "importer", imp->fd);
                 safe_close(imp->fd);
         }
 
@@ -363,7 +363,7 @@ int journal_importer_process_data(JournalImporter *imp) {
                 assert(imp->data_size == 0);
 
                 r = get_data_size(imp);
-                // log_debug("get_data_size() -> %d", r);
+                // log_info("get_data_size() -> %d", r);
                 if (r < 0)
                         return r;
                 if (r == 0) {
@@ -383,7 +383,7 @@ int journal_importer_process_data(JournalImporter *imp) {
                 assert(imp->data_size > 0);
 
                 r = get_data_data(imp, &data);
-                // log_debug("get_data_data() -> %d", r);
+                // log_info("get_data_data() -> %d", r);
                 if (r < 0)
                         return r;
                 if (r == 0) {
@@ -407,7 +407,7 @@ int journal_importer_process_data(JournalImporter *imp) {
 
         case IMPORTER_STATE_DATA_FINISH:
                 r = get_data_newline(imp);
-                // log_debug("get_data_newline() -> %d", r);
+                // log_info("get_data_newline() -> %d", r);
                 if (r < 0)
                         return r;
                 if (r == 0) {
@@ -471,7 +471,7 @@ void journal_importer_drop_iovw(JournalImporter *imp) {
                         log_warning("Failed to reallocate buffer to (smaller) size %zu",
                                     target);
                 else {
-                        log_debug("Reallocated buffer from %zu to %zu bytes",
+                        log_info("Reallocated buffer from %zu to %zu bytes",
                                   imp->size, target);
                         imp->buf = tmp;
                         imp->size = target;
diff --git a/src/basic/locale-util.c b/src/basic/locale-util.c
index 266cb2993..cf003e144 100644
--- a/src/basic/locale-util.c
+++ b/src/basic/locale-util.c
@@ -323,9 +323,9 @@ int get_keymaps(char ***ret) {
                 r = nftw(dir, nftw_cb, 20, FTW_MOUNT|FTW_PHYS|FTW_ACTIONRETVAL);
 
                 if (r == FTW_STOP)
-                        log_debug("Directory not found %s", dir);
+                        log_info("Directory not found %s", dir);
                 else if (r < 0)
-                        log_debug_errno(r, "Can't add keymap: %m");
+                        log_info_errno(r, "Can't add keymap: %m");
         }
 
         l = set_get_strv(keymaps);
diff --git a/src/basic/log.h b/src/basic/log.h
index 5b5a25bd6..15a9e2e25 100644
--- a/src/basic/log.h
+++ b/src/basic/log.h
@@ -247,7 +247,7 @@ void log_assert_failed_return_realm(
 int log_emergency_level(void);
 
 /* Normal logging */
-#define log_debug(...)     log_full(LOG_DEBUG,   __VA_ARGS__)
+#define log_info(...)     log_full(LOG_DEBUG,   __VA_ARGS__)
 #define log_info(...)      log_full(LOG_INFO,    __VA_ARGS__)
 #define log_notice(...)    log_full(LOG_NOTICE,  __VA_ARGS__)
 #define log_warning(...)   log_full(LOG_WARNING, __VA_ARGS__)
@@ -255,7 +255,7 @@ int log_emergency_level(void);
 #define log_emergency(...) log_full(log_emergency_level(), __VA_ARGS__)
 
 /* Logging triggered by an errno-like error */
-#define log_debug_errno(error, ...)     log_full_errno(LOG_DEBUG,   error, __VA_ARGS__)
+#define log_info_errno(error, ...)     log_full_errno(LOG_DEBUG,   error, __VA_ARGS__)
 #define log_info_errno(error, ...)      log_full_errno(LOG_INFO,    error, __VA_ARGS__)
 #define log_notice_errno(error, ...)    log_full_errno(LOG_NOTICE,  error, __VA_ARGS__)
 #define log_warning_errno(error, ...)   log_full_errno(LOG_WARNING, error, __VA_ARGS__)
@@ -263,7 +263,7 @@ int log_emergency_level(void);
 #define log_emergency_errno(error, ...) log_full_errno(log_emergency_level(), error, __VA_ARGS__)
 
 #ifdef LOG_TRACE
-#  define log_trace(...) log_debug(__VA_ARGS__)
+#  define log_trace(...) log_info(__VA_ARGS__)
 #else
 #  define log_trace(...) do {} while (0)
 #endif
diff --git a/src/basic/mount-util.c b/src/basic/mount-util.c
index a8947cefc..8e336fc74 100644
--- a/src/basic/mount-util.c
+++ b/src/basic/mount-util.c
@@ -373,11 +373,11 @@ int umount_recursive(const char *prefix, int flags) {
                                 continue;
 
                         if (umount2(p, flags) < 0) {
-                                r = log_debug_errno(errno, "Failed to umount %s: %m", p);
+                                r = log_info_errno(errno, "Failed to umount %s: %m", p);
                                 continue;
                         }
 
-                        log_debug("Successfully unmounted %s", p);
+                        log_info("Successfully unmounted %s", p);
 
                         again = true;
                         n++;
@@ -491,7 +491,7 @@ int bind_remount_recursive_with_mountinfo(const char *prefix, bool ro, char **bl
 
                                         if (path_startswith(p, *i)) {
                                                 blacklisted = true;
-                                                log_debug("Not remounting %s, because blacklisted by %s, called for %s", p, *i, cleaned);
+                                                log_info("Not remounting %s, because blacklisted by %s, called for %s", p, *i, cleaned);
                                                 break;
                                         }
                                 }
@@ -540,7 +540,7 @@ int bind_remount_recursive_with_mountinfo(const char *prefix, bool ro, char **bl
                         if (mount(NULL, prefix, NULL, orig_flags|MS_BIND|MS_REMOUNT|(ro ? MS_RDONLY : 0), NULL) < 0)
                                 return -errno;
 
-                        log_debug("Made top-level directory %s a mount point.", prefix);
+                        log_info("Made top-level directory %s a mount point.", prefix);
 
                         x = strdup(cleaned);
                         if (!x)
@@ -574,7 +574,7 @@ int bind_remount_recursive_with_mountinfo(const char *prefix, bool ro, char **bl
                         if (mount(NULL, x, NULL, orig_flags|MS_BIND|MS_REMOUNT|(ro ? MS_RDONLY : 0), NULL) < 0)
                                 return -errno;
 
-                        log_debug("Remounted %s read-only.", x);
+                        log_info("Remounted %s read-only.", x);
                 }
         }
 }
@@ -815,19 +815,19 @@ int mount_verbose(
         fl = mount_flags_to_string(flags);
 
         if ((flags & MS_REMOUNT) && !what && !type)
-                log_debug("Remounting %s (%s \"%s\")...",
+                log_info("Remounting %s (%s \"%s\")...",
                           where, strnull(fl), strempty(options));
         else if (!what && !type)
-                log_debug("Mounting %s (%s \"%s\")...",
+                log_info("Mounting %s (%s \"%s\")...",
                           where, strnull(fl), strempty(options));
         else if ((flags & MS_BIND) && !type)
-                log_debug("Bind-mounting %s on %s (%s \"%s\")...",
+                log_info("Bind-mounting %s on %s (%s \"%s\")...",
                           what, where, strnull(fl), strempty(options));
         else if (flags & MS_MOVE)
-                log_debug("Moving mount %s → %s (%s \"%s\")...",
+                log_info("Moving mount %s → %s (%s \"%s\")...",
                           what, where, strnull(fl), strempty(options));
         else
-                log_debug("Mounting %s on %s (%s \"%s\")...",
+                log_info("Mounting %s on %s (%s \"%s\")...",
                           strna(type), where, strnull(fl), strempty(options));
         if (mount(what, where, type, flags, options) < 0)
                 return log_full_errno(error_log_level, errno,
@@ -837,7 +837,7 @@ int mount_verbose(
 }
 
 int umount_verbose(const char *what) {
-        log_debug("Umounting %s...", what);
+        log_info("Umounting %s...", what);
         if (umount(what) < 0)
                 return log_error_errno(errno, "Failed to unmount %s: %m", what);
         return 0;
diff --git a/src/basic/path-util.c b/src/basic/path-util.c
index df9462938..df89f154e 100644
--- a/src/basic/path-util.c
+++ b/src/basic/path-util.c
@@ -579,7 +579,7 @@ bool paths_check_timestamp(const char* const* paths, usec_t *timestamp, bool upd
                 if (*timestamp >= u)
                         continue;
 
-                log_debug("timestamp of '%s' changed", *i);
+                log_info("timestamp of '%s' changed", *i);
 
                 /* update timestamp */
                 if (update) {
@@ -945,11 +945,11 @@ int systemd_installation_has_version(const char *root, unsigned minimal_version)
 
                         r = safe_atou(t, &version);
                         if (r < 0) {
-                                log_debug_errno(r, "Found libsystemd shared at \"%s.so\", but failed to parse version: %m", *name);
+                                log_info_errno(r, "Found libsystemd shared at \"%s.so\", but failed to parse version: %m", *name);
                                 continue;
                         }
 
-                        log_debug("Found libsystemd shared at \"%s.so\", version %u (%s).",
+                        log_info("Found libsystemd shared at \"%s.so\", version %u (%s).",
                                   *name, version,
                                   version >= minimal_version ? "OK" : "too old");
                         if (version >= minimal_version)
diff --git a/src/basic/process-util.c b/src/basic/process-util.c
index dc7c9ef9e..19d2483d7 100644
--- a/src/basic/process-util.c
+++ b/src/basic/process-util.c
@@ -307,7 +307,7 @@ int rename_process(const char name[]) {
         /* First step, change the comm field. The main thread's comm is identical to the process comm. This means we
          * can use PR_SET_NAME, which sets the thread name for the calling thread. */
         if (prctl(PR_SET_NAME, name) < 0)
-                log_debug_errno(errno, "PR_SET_NAME failed: %m");
+                log_info_errno(errno, "PR_SET_NAME failed: %m");
         if (l > 15) /* Linux process names can be 15 chars at max */
                 truncated = true;
 
@@ -331,7 +331,7 @@ int rename_process(const char name[]) {
          * PR_SET_MM_ARG_{START,END} fails with EPERM later on anyway. After all geteuid() is dead cheap to call, but
          * mmap() is not. */
         if (geteuid() != 0)
-                log_debug("Skipping PR_SET_MM, as we don't have privileges.");
+                log_info("Skipping PR_SET_MM, as we don't have privileges.");
         else if (mm_size < l+1) {
                 size_t nn_size;
                 char *nn;
@@ -339,7 +339,7 @@ int rename_process(const char name[]) {
                 nn_size = PAGE_ALIGN(l+1);
                 nn = mmap(NULL, nn_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
                 if (nn == MAP_FAILED) {
-                        log_debug_errno(errno, "mmap() failed: %m");
+                        log_info_errno(errno, "mmap() failed: %m");
                         goto use_saved_argv;
                 }
 
@@ -347,7 +347,7 @@ int rename_process(const char name[]) {
 
                 /* Now, let's tell the kernel about this new memory */
                 if (prctl(PR_SET_MM, PR_SET_MM_ARG_START, (unsigned long) nn, 0, 0) < 0) {
-                        log_debug_errno(errno, "PR_SET_MM_ARG_START failed, proceeding without: %m");
+                        log_info_errno(errno, "PR_SET_MM_ARG_START failed, proceeding without: %m");
                         (void) munmap(nn, nn_size);
                         goto use_saved_argv;
                 }
@@ -355,7 +355,7 @@ int rename_process(const char name[]) {
                 /* And update the end pointer to the new end, too. If this fails, we don't really know what to do, it's
                  * pretty unlikely that we can rollback, hence we'll just accept the failure, and continue. */
                 if (prctl(PR_SET_MM, PR_SET_MM_ARG_END, (unsigned long) nn + l + 1, 0, 0) < 0)
-                        log_debug_errno(errno, "PR_SET_MM_ARG_END failed, proceeding without: %m");
+                        log_info_errno(errno, "PR_SET_MM_ARG_END failed, proceeding without: %m");
 
                 if (mm)
                         (void) munmap(mm, mm_size);
@@ -367,7 +367,7 @@ int rename_process(const char name[]) {
 
                 /* Update the end pointer, continuing regardless of any failure. */
                 if (prctl(PR_SET_MM, PR_SET_MM_ARG_END, (unsigned long) mm + l + 1, 0, 0) < 0)
-                        log_debug_errno(errno, "PR_SET_MM_ARG_END failed, proceeding without: %m");
+                        log_info_errno(errno, "PR_SET_MM_ARG_END failed, proceeding without: %m");
         }
 
 use_saved_argv:
@@ -697,7 +697,7 @@ int wait_for_terminate_and_check(const char *name, pid_t pid, WaitFlags flags) {
         if (!name) {
                 r = get_process_comm(pid, &buffer);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to acquire process name of " PID_FMT ", ignoring: %m", pid);
+                        log_info_errno(r, "Failed to acquire process name of " PID_FMT ", ignoring: %m", pid);
                 else
                         name = buffer;
         }
@@ -713,7 +713,7 @@ int wait_for_terminate_and_check(const char *name, pid_t pid, WaitFlags flags) {
                         log_full(flags & WAIT_LOG_NON_ZERO_EXIT_STATUS ? LOG_ERR : LOG_DEBUG,
                                  "%s failed with exit status %i.", strna(name), status.si_status);
                 else
-                        log_debug("%s succeeded.", name);
+                        log_info("%s succeeded.", name);
 
                 return status.si_status;
 
@@ -1227,7 +1227,7 @@ int safe_fork_full(
         if (pid > 0) {
                 /* We are in the parent process */
 
-                log_debug("Successfully forked off '%s' as PID " PID_FMT ".", strna(name), pid);
+                log_info("Successfully forked off '%s' as PID " PID_FMT ".", strna(name), pid);
 
                 if (flags & FORK_WAIT) {
                         r = wait_for_terminate_and_check(name, pid, (flags & FORK_LOG ? WAIT_LOG : 0));
@@ -1296,7 +1296,7 @@ int safe_fork_full(
                 if (ppid == 0)
                         /* Parent is in a differn't PID namespace. */;
                 else if (ppid != original_pid) {
-                        log_debug("Parent died early, raising SIGTERM.");
+                        log_info("Parent died early, raising SIGTERM.");
                         (void) raise(SIGTERM);
                         _exit(EXIT_FAILURE);
                 }
diff --git a/src/basic/selinux-util.c b/src/basic/selinux-util.c
index 0c6e99b1d..74cca8f61 100644
--- a/src/basic/selinux-util.c
+++ b/src/basic/selinux-util.c
@@ -100,7 +100,7 @@ int mac_selinux_init(void) {
 
                 l = after_mallinfo.uordblks > before_mallinfo.uordblks ? after_mallinfo.uordblks - before_mallinfo.uordblks : 0;
 
-                log_debug("Successfully loaded SELinux database in %s, size on heap is %iK.",
+                log_info("Successfully loaded SELinux database in %s, size on heap is %iK.",
                           format_timespan(timespan, sizeof(timespan), after_timestamp - before_timestamp, 0),
                           (l+1023)/1024);
         }
diff --git a/src/basic/smack-util.c b/src/basic/smack-util.c
index f0018f013..061f6f536 100644
--- a/src/basic/smack-util.c
+++ b/src/basic/smack-util.c
@@ -183,7 +183,7 @@ int mac_smack_fix(const char *path, bool ignore_enoent, bool ignore_erofs) {
                 if (ignore_erofs && errno == EROFS)
                         return 0;
 
-                r = log_debug_errno(errno, "Unable to fix SMACK label of %s: %m", path);
+                r = log_info_errno(errno, "Unable to fix SMACK label of %s: %m", path);
         }
 
         return r;
diff --git a/src/basic/socket-util.c b/src/basic/socket-util.c
index 2c70cade1..ff7d2dbb1 100644
--- a/src/basic/socket-util.c
+++ b/src/basic/socket-util.c
@@ -747,7 +747,7 @@ int socknameinfo_pretty(union sockaddr_union *sa, socklen_t salen, char **_ret)
                 if (r < 0)
                         return r;
 
-                log_debug_errno(saved_errno, "getnameinfo(%s) failed: %m", ret);
+                log_info_errno(saved_errno, "getnameinfo(%s) failed: %m", ret);
         } else {
                 ret = strdup(host);
                 if (!ret)
diff --git a/src/basic/terminal-util.c b/src/basic/terminal-util.c
index 42336e8fd..c26f14284 100644
--- a/src/basic/terminal-util.c
+++ b/src/basic/terminal-util.c
@@ -748,7 +748,7 @@ int get_kernel_consoles(char ***consoles) {
                         return -ENOMEM;
 
                 if (access(path, F_OK) < 0) {
-                        log_debug_errno(errno, "Console device %s is not accessible, skipping: %m", path);
+                        log_info_errno(errno, "Console device %s is not accessible, skipping: %m", path);
                         free(path);
                         continue;
                 }
@@ -759,7 +759,7 @@ int get_kernel_consoles(char ***consoles) {
         }
 
         if (strv_isempty(con)) {
-                log_debug("No devices found for system console");
+                log_info("No devices found for system console");
 
                 r = strv_extend(&con, "/dev/console");
                 if (r < 0)
diff --git a/src/basic/time-util.c b/src/basic/time-util.c
index 4a341e208..0729187e0 100644
--- a/src/basic/time-util.c
+++ b/src/basic/time-util.c
@@ -573,7 +573,7 @@ int dual_timestamp_deserialize(const char *value, dual_timestamp *t) {
 
         r = sscanf(value, "%" PRIu64 "%" PRIu64 "%n", &a, &b, &pos);
         if (r != 2) {
-                log_debug("Failed to parse dual timestamp value \"%s\".", value);
+                log_info("Failed to parse dual timestamp value \"%s\".", value);
                 return -EINVAL;
         }
 
@@ -594,7 +594,7 @@ int timestamp_deserialize(const char *value, usec_t *timestamp) {
 
         r = safe_atou64(value, timestamp);
         if (r < 0)
-                return log_debug_errno(r, "Failed to parse timestamp value \"%s\": %m", value);
+                return log_info_errno(r, "Failed to parse timestamp value \"%s\": %m", value);
 
         return r;
 }
diff --git a/src/basic/user-util.c b/src/basic/user-util.c
index 17a9b5a8f..9fbc9b656 100644
--- a/src/basic/user-util.c
+++ b/src/basic/user-util.c
@@ -686,7 +686,7 @@ int maybe_setgroups(size_t size, const gid_t *list) {
                         can_setgroups = streq(setgroups_content, "allow");
 
                 if (!can_setgroups) {
-                        log_debug("Skipping setgroups(), /proc/self/setgroups is set to 'deny'");
+                        log_info("Skipping setgroups(), /proc/self/setgroups is set to 'deny'");
                         return 0;
                 }
         }
diff --git a/src/basic/util.c b/src/basic/util.c
index c7f1513f3..7d0832e49 100644
--- a/src/basic/util.c
+++ b/src/basic/util.c
@@ -618,5 +618,5 @@ void disable_coredumps(void) {
 
         r = write_string_file("/proc/sys/kernel/core_pattern", "|/bin/false", 0);
         if (r < 0)
-                log_debug_errno(r, "Failed to turn off coredumps, ignoring: %m");
+                log_info_errno(r, "Failed to turn off coredumps, ignoring: %m");
 }
diff --git a/src/basic/verbs.c b/src/basic/verbs.c
index 47644670d..9f84eda07 100644
--- a/src/basic/verbs.c
+++ b/src/basic/verbs.c
@@ -45,7 +45,7 @@ bool running_in_chroot_or_offline(void) {
          */
         r = getenv_bool("SYSTEMD_OFFLINE");
         if (r < 0 && r != -ENXIO)
-                log_debug_errno(r, "Failed to parse $SYSTEMD_OFFLINE: %m");
+                log_info_errno(r, "Failed to parse $SYSTEMD_OFFLINE: %m");
         else if (r >= 0)
                 return r > 0;
 
@@ -59,7 +59,7 @@ bool running_in_chroot_or_offline(void) {
          */
         r = running_in_chroot();
         if (r < 0)
-                log_debug_errno(r, "running_in_chroot(): %m");
+                log_info_errno(r, "running_in_chroot(): %m");
 
         return r > 0;
 }
diff --git a/src/basic/virt.c b/src/basic/virt.c
index f4796b53b..f44d4ffe3 100644
--- a/src/basic/virt.c
+++ b/src/basic/virt.c
@@ -84,7 +84,7 @@ static int detect_vm_cpuid(void) {
                 sig.sig32[1] = ecx;
                 sig.sig32[2] = edx;
 
-                log_debug("Virtualization found, CPUID=%s", sig.text);
+                log_info("Virtualization found, CPUID=%s", sig.text);
 
                 for (j = 0; j < ELEMENTSOF(cpuid_vendor_table); j ++)
                         if (streq(sig.text, cpuid_vendor_table[j].cpuid))
@@ -93,7 +93,7 @@ static int detect_vm_cpuid(void) {
                 return VIRTUALIZATION_VM_OTHER;
         }
 #endif
-        log_debug("No virtualization found in CPUID");
+        log_info("No virtualization found in CPUID");
 
         return VIRTUALIZATION_NONE;
 }
@@ -111,7 +111,7 @@ static int detect_vm_device_tree(void) {
                 dir = opendir("/proc/device-tree");
                 if (!dir) {
                         if (errno == ENOENT) {
-                                log_debug_errno(errno, "/proc/device-tree: %m");
+                                log_info_errno(errno, "/proc/device-tree: %m");
                                 return VIRTUALIZATION_NONE;
                         }
                         return -errno;
@@ -119,16 +119,16 @@ static int detect_vm_device_tree(void) {
 
                 FOREACH_DIRENT(dent, dir, return -errno)
                         if (strstr(dent->d_name, "fw-cfg")) {
-                                log_debug("Virtualization QEMU: \"fw-cfg\" present in /proc/device-tree/%s", dent->d_name);
+                                log_info("Virtualization QEMU: \"fw-cfg\" present in /proc/device-tree/%s", dent->d_name);
                                 return VIRTUALIZATION_QEMU;
                         }
 
-                log_debug("No virtualization found in /proc/device-tree/*");
+                log_info("No virtualization found in /proc/device-tree/*");
                 return VIRTUALIZATION_NONE;
         } else if (r < 0)
                 return r;
 
-        log_debug("Virtualization %s found in /proc/device-tree/hypervisor/compatible", hvtype);
+        log_info("Virtualization %s found in /proc/device-tree/hypervisor/compatible", hvtype);
         if (streq(hvtype, "linux,kvm"))
                 return VIRTUALIZATION_KVM;
         else if (strstr(hvtype, "xen"))
@@ -136,7 +136,7 @@ static int detect_vm_device_tree(void) {
         else
                 return VIRTUALIZATION_VM_OTHER;
 #else
-        log_debug("This platform does not support /proc/device-tree");
+        log_info("This platform does not support /proc/device-tree");
         return VIRTUALIZATION_NONE;
 #endif
 }
@@ -184,13 +184,13 @@ static int detect_vm_dmi(void) {
 
                 for (j = 0; j < ELEMENTSOF(dmi_vendor_table); j++)
                         if (startswith(s, dmi_vendor_table[j].vendor)) {
-                                log_debug("Virtualization %s found in DMI (%s)", s, dmi_vendors[i]);
+                                log_info("Virtualization %s found in DMI (%s)", s, dmi_vendors[i]);
                                 return dmi_vendor_table[j].id;
                         }
         }
 #endif
 
-        log_debug("No virtualization found in DMI");
+        log_info("No virtualization found in DMI");
 
         return VIRTUALIZATION_NONE;
 }
@@ -200,11 +200,11 @@ static int detect_vm_xen(void) {
         /* Check for Dom0 will be executed later in detect_vm_xen_dom0
            The presence of /proc/xen indicates some form of a Xen domain */
         if (access("/proc/xen", F_OK) < 0) {
-                log_debug("Virtualization XEN not found, /proc/xen does not exist");
+                log_info("Virtualization XEN not found, /proc/xen does not exist");
                 return VIRTUALIZATION_NONE;
         }
 
-        log_debug("Virtualization XEN found (/proc/xen exists)");
+        log_info("Virtualization XEN found (/proc/xen exists)");
         return VIRTUALIZATION_XEN;
 }
 
@@ -227,18 +227,18 @@ static int detect_vm_xen_dom0(void) {
                 r = sscanf(domcap, "%lx", &features);
                 if (r == 1) {
                         r = !!(features & (1U << XENFEAT_dom0));
-                        log_debug("Virtualization XEN, found %s with value %08lx, "
+                        log_info("Virtualization XEN, found %s with value %08lx, "
                                   "XENFEAT_dom0 (indicating the 'hardware domain') is%s set.",
                                   PATH_FEATURES, features, r ? "" : " not");
                         return r;
                 }
-                log_debug("Virtualization XEN, found %s, unhandled content '%s'",
+                log_info("Virtualization XEN, found %s, unhandled content '%s'",
                           PATH_FEATURES, domcap);
         }
 
         r = read_one_line_file("/proc/xen/capabilities", &domcap);
         if (r == -ENOENT) {
-                log_debug("Virtualization XEN because /proc/xen/capabilities does not exist");
+                log_info("Virtualization XEN because /proc/xen/capabilities does not exist");
                 return 0;
         }
         if (r < 0)
@@ -249,11 +249,11 @@ static int detect_vm_xen_dom0(void) {
                 if (streq(cap, "control_d"))
                         break;
         if (!cap) {
-                log_debug("Virtualization XEN DomU found (/proc/xen/capabilites)");
+                log_info("Virtualization XEN DomU found (/proc/xen/capabilites)");
                 return 0;
         }
 
-        log_debug("Virtualization XEN Dom0 ignored (/proc/xen/capabilities)");
+        log_info("Virtualization XEN Dom0 ignored (/proc/xen/capabilities)");
         return 1;
 }
 
@@ -267,7 +267,7 @@ static int detect_vm_hypervisor(void) {
         if (r < 0)
                 return r;
 
-        log_debug("Virtualization %s found in /sys/hypervisor/type", hvtype);
+        log_info("Virtualization %s found in /sys/hypervisor/type", hvtype);
 
         if (streq(hvtype, "xen"))
                 return VIRTUALIZATION_XEN;
@@ -285,11 +285,11 @@ static int detect_vm_uml(void) {
                 return r;
 
         if (strstr(cpuinfo_contents, "\nvendor_id\t: User Mode Linux\n")) {
-                log_debug("UML virtualization found in /proc/cpuinfo");
+                log_info("UML virtualization found in /proc/cpuinfo");
                 return VIRTUALIZATION_UML;
         }
 
-        log_debug("No virtualization found in /proc/cpuinfo.");
+        log_info("No virtualization found in /proc/cpuinfo.");
         return VIRTUALIZATION_NONE;
 }
 
@@ -305,13 +305,13 @@ static int detect_vm_zvm(void) {
         if (r < 0)
                 return r;
 
-        log_debug("Virtualization %s found in /proc/sysinfo", t);
+        log_info("Virtualization %s found in /proc/sysinfo", t);
         if (streq(t, "z/VM"))
                 return VIRTUALIZATION_ZVM;
         else
                 return VIRTUALIZATION_KVM;
 #else
-        log_debug("This platform does not support /proc/sysinfo");
+        log_info("This platform does not support /proc/sysinfo");
         return VIRTUALIZATION_NONE;
 #endif
 }
@@ -422,7 +422,7 @@ finish:
                 r = VIRTUALIZATION_VM_OTHER;
 
         cached_found = r;
-        log_debug("Found VM virtualization %s", virtualization_to_string(r));
+        log_info("Found VM virtualization %s", virtualization_to_string(r));
         return r;
 }
 
@@ -475,7 +475,7 @@ int detect_container(void) {
                 goto translate_name;
         }
         if (r != -ENOENT)
-                return log_debug_errno(r, "Failed to read /run/systemd/container: %m");
+                return log_info_errno(r, "Failed to read /run/systemd/container: %m");
 
         /* Fallback for cases where PID 1 was not systemd (for example, cases where init=/bin/sh is used. */
         r = getenv_for_pid(1, "container", &m);
@@ -484,7 +484,7 @@ int detect_container(void) {
                 goto translate_name;
         }
         if (r < 0) /* This only works if we have CAP_SYS_PTRACE, hence let's better ignore failures here */
-                log_debug_errno(r, "Failed to read $container of PID 1, ignoring: %m");
+                log_info_errno(r, "Failed to read $container of PID 1, ignoring: %m");
 
         /* Interestingly /proc/1/sched actually shows the host's PID for what we see as PID 1. Hence, if the PID shown
          * there is not 1, we know we are in a PID namespace. and hence a container. */
@@ -517,7 +517,7 @@ translate_name:
         r = VIRTUALIZATION_CONTAINER_OTHER;
 
 finish:
-        log_debug("Found container virtualization %s.", virtualization_to_string(r));
+        log_info("Found container virtualization %s.", virtualization_to_string(r));
         cached_found = r;
         return r;
 }
@@ -542,32 +542,32 @@ static int userns_has_mapping(const char *name) {
 
         f = fopen(name, "re");
         if (!f) {
-                log_debug_errno(errno, "Failed to open %s: %m", name);
+                log_info_errno(errno, "Failed to open %s: %m", name);
                 return errno == ENOENT ? false : -errno;
         }
 
         n = getline(&buf, &n_allocated, f);
         if (n < 0) {
                 if (feof(f)) {
-                        log_debug("%s is empty, we're in an uninitialized user namespace", name);
+                        log_info("%s is empty, we're in an uninitialized user namespace", name);
                         return true;
                 }
 
-                return log_debug_errno(errno, "Failed to read %s: %m", name);
+                return log_info_errno(errno, "Failed to read %s: %m", name);
         }
 
         r = sscanf(buf, "%"PRIu32" %"PRIu32" %"PRIu32, &a, &b, &c);
         if (r < 3)
-                return log_debug_errno(errno, "Failed to parse %s: %m", name);
+                return log_info_errno(errno, "Failed to parse %s: %m", name);
 
         if (a == 0 && b == 0 && c == UINT32_MAX) {
                 /* The kernel calls mappings_overlap() and does not allow overlaps */
-                log_debug("%s has a full 1:1 mapping", name);
+                log_info("%s has a full 1:1 mapping", name);
                 return false;
         }
 
         /* Anything else implies that we are in a user namespace */
-        log_debug("Mapping found in %s, we're in a user namespace", name);
+        log_info("Mapping found in %s, we're in a user namespace", name);
         return true;
 }
 
@@ -591,14 +591,14 @@ int running_in_userns(void) {
          */
         r = read_one_line_file("/proc/self/setgroups", &line);
         if (r < 0) {
-                log_debug_errno(r, "/proc/self/setgroups: %m");
+                log_info_errno(r, "/proc/self/setgroups: %m");
                 return r == -ENOENT ? false : r;
         }
 
         truncate_nl(line);
         r = streq(line, "deny");
         /* See user_namespaces(7) for a description of this "setgroups" contents. */
-        log_debug("/proc/self/setgroups contains \"%s\", %s user namespace", line, r ? "in" : "not in");
+        log_info("/proc/self/setgroups contains \"%s\", %s user namespace", line, r ? "in" : "not in");
         return r;
 }
 
diff --git a/src/binfmt/binfmt.c b/src/binfmt/binfmt.c
index eb888e88e..76cd7bf00 100644
--- a/src/binfmt/binfmt.c
+++ b/src/binfmt/binfmt.c
@@ -84,7 +84,7 @@ static int apply_file(const char *path, bool ignore_enoent) {
                 return log_error_errno(r, "Failed to open file '%s', ignoring: %m", path);
         }
 
-        log_debug("apply: %s", path);
+        log_info("apply: %s", path);
         for (;;) {
                 char l[LINE_MAX], *p;
                 int k;
diff --git a/src/boot/bootctl.c b/src/boot/bootctl.c
index ae034f5cd..6012d5278 100644
--- a/src/boot/bootctl.c
+++ b/src/boot/bootctl.c
@@ -88,7 +88,7 @@ static int acquire_esp(
 
         free_and_replace(arg_path, np);
 
-        log_debug("Using EFI System Partition at %s.", arg_path);
+        log_info("Using EFI System Partition at %s.", arg_path);
 
         return 0;
 }
diff --git a/src/cgroups-agent/cgroups-agent.c b/src/cgroups-agent/cgroups-agent.c
index 05d12ebb4..24f834af6 100644
--- a/src/cgroups-agent/cgroups-agent.c
+++ b/src/cgroups-agent/cgroups-agent.c
@@ -47,7 +47,7 @@ int main(int argc, char *argv[]) {
 
         fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0);
         if (fd < 0) {
-                log_debug_errno(errno, "Failed to allocate socket: %m");
+                log_info_errno(errno, "Failed to allocate socket: %m");
                 return EXIT_FAILURE;
         }
 
@@ -55,12 +55,12 @@ int main(int argc, char *argv[]) {
 
         n = sendto(fd, argv[1], l, 0, &sa.sa, SOCKADDR_UN_LEN(sa.un));
         if (n < 0) {
-                log_debug_errno(errno, "Failed to send cgroups agent message: %m");
+                log_info_errno(errno, "Failed to send cgroups agent message: %m");
                 return EXIT_FAILURE;
         }
 
         if ((size_t) n != l) {
-                log_debug("Datagram size mismatch");
+                log_info("Datagram size mismatch");
                 return EXIT_FAILURE;
         }
 
diff --git a/src/cgtop/cgtop.c b/src/cgtop/cgtop.c
index 1a73fb099..9b2b043d9 100644
--- a/src/cgtop/cgtop.c
+++ b/src/cgtop/cgtop.c
@@ -926,7 +926,7 @@ int main(int argc, char *argv[]) {
                 log_error_errno(r, "Failed to get root control group path: %m");
                 goto finish;
         } else
-                log_debug("Cgroup path: %s", root);
+                log_info("Cgroup path: %s", root);
 
         a = hashmap_new(&string_hash_ops);
         b = hashmap_new(&string_hash_ops);
diff --git a/src/core/automount.c b/src/core/automount.c
index c191336c0..5382c9638 100644
--- a/src/core/automount.c
+++ b/src/core/automount.c
@@ -358,7 +358,7 @@ static int open_dev_autofs(Manager *m) {
                 return -errno;
         }
 
-        log_debug("Autofs kernel version %i.%i", param.ver_major, param.ver_minor);
+        log_info("Autofs kernel version %i.%i", param.ver_major, param.ver_minor);
 
         return m->dev_autofs_fd;
 }
@@ -412,7 +412,7 @@ static int autofs_protocol(int dev_autofs_fd, int ioctl_fd) {
 
         minor = param.protosubver.sub_version;
 
-        log_debug("Autofs protocol version %i.%i", major, minor);
+        log_info("Autofs protocol version %i.%i", major, minor);
         return 0;
 }
 
diff --git a/src/core/bpf-firewall.c b/src/core/bpf-firewall.c
index f3f40fb0e..6c81855d3 100644
--- a/src/core/bpf-firewall.c
+++ b/src/core/bpf-firewall.c
@@ -494,7 +494,7 @@ int bpf_firewall_compile(Unit *u) {
         if (r < 0)
                 return r;
         if (r == 0) {
-                log_debug("BPF firewalling not supported on this systemd, proceeding without.");
+                log_info("BPF firewalling not supported on this systemd, proceeding without.");
                 return -EOPNOTSUPP;
         }
 
@@ -556,7 +556,7 @@ int bpf_firewall_install(Unit *u) {
         if (r < 0)
                 return r;
         if (r == 0) {
-                log_debug("BPF firewalling not supported on this systemd, proceeding without.");
+                log_info("BPF firewalling not supported on this systemd, proceeding without.");
                 return -EOPNOTSUPP;
         }
 
@@ -666,7 +666,7 @@ int bpf_firewall_supported(void) {
                 return supported;
 
         if (geteuid() != 0) {
-                log_debug("Not enough privileges, BPF firewalling is not supported.");
+                log_info("Not enough privileges, BPF firewalling is not supported.");
                 return supported = false;
         }
 
@@ -674,7 +674,7 @@ int bpf_firewall_supported(void) {
         if (r < 0)
                 return log_error_errno(r, "Can't determine whether the unified hierarchy is used: %m");
         if (r == 0) {
-                log_debug("Not running with unified cgroups, BPF firewalling is not supported.");
+                log_info("Not running with unified cgroups, BPF firewalling is not supported.");
                 return supported = false;
         }
 
@@ -684,26 +684,26 @@ int bpf_firewall_supported(void) {
                          1,
                          BPF_F_NO_PREALLOC);
         if (fd < 0) {
-                log_debug_errno(r, "Can't allocate BPF LPM TRIE map, BPF firewalling is not supported: %m");
+                log_info_errno(r, "Can't allocate BPF LPM TRIE map, BPF firewalling is not supported: %m");
                 return supported = false;
         }
 
         safe_close(fd);
 
         if (bpf_program_new(BPF_PROG_TYPE_CGROUP_SKB, &program) < 0) {
-                log_debug_errno(r, "Can't allocate CGROUP SKB BPF program, BPF firewalling is not supported: %m");
+                log_info_errno(r, "Can't allocate CGROUP SKB BPF program, BPF firewalling is not supported: %m");
                 return supported = false;
         }
 
         r = bpf_program_add_instructions(program, trivial, ELEMENTSOF(trivial));
         if (r < 0) {
-                log_debug_errno(r, "Can't add trivial instructions to CGROUP SKB BPF program, BPF firewalling is not supported: %m");
+                log_info_errno(r, "Can't add trivial instructions to CGROUP SKB BPF program, BPF firewalling is not supported: %m");
                 return supported = false;
         }
 
         r = bpf_program_load_kernel(program, NULL, 0);
         if (r < 0) {
-                log_debug_errno(r, "Can't load kernel CGROUP SKB BPF program, BPF firewalling is not supported: %m");
+                log_info_errno(r, "Can't load kernel CGROUP SKB BPF program, BPF firewalling is not supported: %m");
                 return supported = false;
         }
 
@@ -726,9 +726,9 @@ int bpf_firewall_supported(void) {
                 if (errno == EBADF) /* YAY! */
                         return supported = true;
 
-                log_debug_errno(errno, "Didn't get EBADF from BPF_PROG_ATTACH, BPF firewalling is not supported: %m");
+                log_info_errno(errno, "Didn't get EBADF from BPF_PROG_ATTACH, BPF firewalling is not supported: %m");
         } else
-                log_debug("Wut? kernel accepted our invalid BPF_PROG_ATTACH call? Something is weird, assuming BPF firewalling is broken and hence not supported.");
+                log_info("Wut? kernel accepted our invalid BPF_PROG_ATTACH call? Something is weird, assuming BPF firewalling is broken and hence not supported.");
 
         return supported = false;
 }
diff --git a/src/core/cgroup.c b/src/core/cgroup.c
index 97b375656..31c4e8d0d 100644
--- a/src/core/cgroup.c
+++ b/src/core/cgroup.c
@@ -1930,7 +1930,7 @@ static int on_cgroup_empty_event(sd_event_source *s, void *userdata) {
                 /* More stuff queued, let's make sure we remain enabled */
                 r = sd_event_source_set_enabled(s, SD_EVENT_ONESHOT);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to reenable cgroup empty event source: %m");
+                        log_info_errno(r, "Failed to reenable cgroup empty event source: %m");
         }
 
         unit_add_to_gc_queue(u);
@@ -1983,7 +1983,7 @@ void unit_add_to_cgroup_empty_queue(Unit *u) {
         /* Trigger the defer event */
         r = sd_event_source_set_enabled(u->manager->cgroup_empty_event_source, SD_EVENT_ONESHOT);
         if (r < 0)
-                log_debug_errno(r, "Failed to enable cgroup empty event source: %m");
+                log_info_errno(r, "Failed to enable cgroup empty event source: %m");
 }
 
 static int on_cgroup_inotify_event(sd_event_source *s, int fd, uint32_t revents, void *userdata) {
@@ -2077,15 +2077,15 @@ int manager_setup_cgroup(Manager *m) {
         if (all_unified < 0)
                 return log_error_errno(all_unified, "Couldn't determine whether we are in all unified mode: %m");
         if (all_unified > 0)
-                log_debug("Unified cgroup hierarchy is located at %s.", path);
+                log_info("Unified cgroup hierarchy is located at %s.", path);
         else {
                 r = cg_unified_controller(SYSTEMD_CGROUP_CONTROLLER);
                 if (r < 0)
                         return log_error_errno(r, "Failed to determine whether systemd's own controller is in unified mode: %m");
                 if (r > 0)
-                        log_debug("Unified cgroup hierarchy is located at %s. Controllers are on legacy hierarchies.", path);
+                        log_info("Unified cgroup hierarchy is located at %s. Controllers are on legacy hierarchies.", path);
                 else
-                        log_debug("Using cgroup controller " SYSTEMD_CGROUP_CONTROLLER_LEGACY ". File system hierarchy is at %s.", path);
+                        log_info("Using cgroup controller " SYSTEMD_CGROUP_CONTROLLER_LEGACY ". File system hierarchy is at %s.", path);
         }
 
         /* 3. Allocate cgroup empty defer event source */
@@ -2137,9 +2137,9 @@ int manager_setup_cgroup(Manager *m) {
                 if (r < 0)
                         log_warning_errno(r, "Failed to install release agent, ignoring: %m");
                 else if (r > 0)
-                        log_debug("Installed release agent.");
+                        log_info("Installed release agent.");
                 else if (r == 0)
-                        log_debug("Release agent already installed.");
+                        log_info("Release agent already installed.");
         }
 
         /* 5. Make sure we are in the special "init.scope" unit in the root slice. */
@@ -2168,7 +2168,7 @@ int manager_setup_cgroup(Manager *m) {
         if (r < 0)
                 return log_error_errno(r, "Failed to determine supported controllers: %m");
         for (c = 0; c < _CGROUP_CONTROLLER_MAX; c++)
-                log_debug("Controller '%s' supported: %s", cgroup_controller_to_string(c), yes_no(m->cgroup_supported & CGROUP_CONTROLLER_TO_MASK(c)));
+                log_info("Controller '%s' supported: %s", cgroup_controller_to_string(c), yes_no(m->cgroup_supported & CGROUP_CONTROLLER_TO_MASK(c)));
 
         return 0;
 }
@@ -2273,7 +2273,7 @@ int manager_notify_cgroup_empty(Manager *m, const char *cgroup) {
         /* Called on the legacy hierarchy whenever we get an explicit cgroup notification from the cgroup agent process
          * or from the --system instance */
 
-        log_debug("Got cgroup empty notification for: %s", cgroup);
+        log_info("Got cgroup empty notification for: %s", cgroup);
 
         u = manager_get_unit_by_cgroup(m, cgroup);
         if (!u)
diff --git a/src/core/dbus-job.c b/src/core/dbus-job.c
index 0802fc977..8fbe0fcb4 100644
--- a/src/core/dbus-job.c
+++ b/src/core/dbus-job.c
@@ -198,7 +198,7 @@ void bus_job_send_change_signal(Job *j) {
 
         r = bus_foreach_bus(j->manager, j->bus_track, j->sent_dbus_new_signal ? send_changed_signal : send_new_signal, j);
         if (r < 0)
-                log_debug_errno(r, "Failed to send job change signal for %u: %m", j->id);
+                log_info_errno(r, "Failed to send job change signal for %u: %m", j->id);
 
         j->sent_dbus_new_signal = true;
 }
@@ -242,7 +242,7 @@ void bus_job_send_removed_signal(Job *j) {
 
         r = bus_foreach_bus(j->manager, j->bus_track, send_removed_signal, j);
         if (r < 0)
-                log_debug_errno(r, "Failed to send job remove signal for %u: %m", j->id);
+                log_info_errno(r, "Failed to send job remove signal for %u: %m", j->id);
 }
 
 static int bus_job_track_handler(sd_bus_track *t, void *userdata) {
diff --git a/src/core/dbus-manager.c b/src/core/dbus-manager.c
index 4fe374867..42bb9e890 100644
--- a/src/core/dbus-manager.c
+++ b/src/core/dbus-manager.c
@@ -1973,7 +1973,7 @@ static int reply_unit_file_changes_and_free(
         if (unit_file_changes_have_modification(changes, n_changes)) {
                 r = bus_foreach_bus(m, NULL, send_unit_files_changed, NULL);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to send UnitFilesChanged signal: %m");
+                        log_info_errno(r, "Failed to send UnitFilesChanged signal: %m");
         }
 
         r = sd_bus_message_new_method_return(message, &reply);
@@ -2591,7 +2591,7 @@ void bus_manager_send_finished(
                                 total_usec
                         });
         if (r < 0)
-                log_debug_errno(r, "Failed to send finished signal: %m");
+                log_info_errno(r, "Failed to send finished signal: %m");
 }
 
 static int send_reloading(sd_bus *bus, void *userdata) {
@@ -2618,7 +2618,7 @@ void bus_manager_send_reloading(Manager *m, bool active) {
 
         r = bus_foreach_bus(m, NULL, send_reloading, INT_TO_PTR(active));
         if (r < 0)
-                log_debug_errno(r, "Failed to send reloading signal: %m");
+                log_info_errno(r, "Failed to send reloading signal: %m");
 }
 
 static int send_changed_signal(sd_bus *bus, void *userdata) {
@@ -2637,5 +2637,5 @@ void bus_manager_send_change_signal(Manager *m) {
 
         r = bus_foreach_bus(m, NULL, send_changed_signal, NULL);
         if (r < 0)
-                log_debug_errno(r, "Failed to send manager change signal: %m");
+                log_info_errno(r, "Failed to send manager change signal: %m");
 }
diff --git a/src/core/dbus.c b/src/core/dbus.c
index 1c3fca353..0c7ddb962 100644
--- a/src/core/dbus.c
+++ b/src/core/dbus.c
@@ -95,7 +95,7 @@ int bus_forward_agent_released(Manager *m, const char *path) {
                                "Released",
                                "s", path);
         if (r < 0)
-                return log_debug_errno(r, "Failed to propagate agent release message: %m");
+                return log_info_errno(r, "Failed to propagate agent release message: %m");
 
         return 1;
 }
@@ -143,7 +143,7 @@ static int signal_disconnected(sd_bus_message *message, void *userdata, sd_bus_e
         if (bus == m->system_bus)
                 destroy_bus(m, &m->system_bus);
         if (set_remove(m->private_buses, bus)) {
-                log_debug("Got disconnect on private connection.");
+                log_info("Got disconnect on private connection.");
                 destroy_bus(m, &bus);
         }
 
@@ -193,7 +193,7 @@ failed:
         if (!sd_bus_error_is_set(&error))
                 sd_bus_error_set_errno(&error, r);
 
-        log_debug("D-Bus activation failed for %s: %s", name, bus_error_message(&error, r));
+        log_info("D-Bus activation failed for %s: %s", name, bus_error_message(&error, r));
 
         r = sd_bus_message_new_signal(sd_bus_message_get_bus(message), &reply, "/org/freedesktop/systemd1", "org.freedesktop.systemd1.Activator", "ActivationFailure");
         if (r < 0) {
@@ -719,7 +719,7 @@ static int bus_on_connection(sd_event_source *s, int fd, uint32_t revents, void
 
         bus = NULL;
 
-        log_debug("Accepted new private connection.");
+        log_info("Accepted new private connection.");
 
         return 0;
 }
@@ -841,7 +841,7 @@ static int bus_setup_api(Manager *m, sd_bus *bus) {
         if (r < 0)
                 return r;
 
-        log_debug("Successfully connected to API bus.");
+        log_info("Successfully connected to API bus.");
         return 0;
 }
 
@@ -902,7 +902,7 @@ static int bus_setup_system(Manager *m, sd_bus *bus) {
                         log_warning_errno(r, "Failed to request Released match on system bus: %m");
         }
 
-        log_debug("Successfully connected to system bus.");
+        log_info("Successfully connected to system bus.");
         return 0;
 }
 
@@ -1008,7 +1008,7 @@ static int bus_init_private(Manager *m) {
         m->private_listen_event_source = s;
         fd = -1;
 
-        log_debug("Successfully created private D-Bus server.");
+        log_info("Successfully created private D-Bus server.");
 
         return 0;
 }
diff --git a/src/core/dynamic-user.c b/src/core/dynamic-user.c
index 3da31bf87..c6c028e59 100644
--- a/src/core/dynamic-user.c
+++ b/src/core/dynamic-user.c
@@ -696,23 +696,23 @@ void dynamic_user_deserialize_one(Manager *m, const char *value, FDSet *fds) {
 
         r = extract_many_words(&value, NULL, 0, &name, &s0, &s1, NULL);
         if (r != 3 || !isempty(value)) {
-                log_debug("Unable to parse dynamic user line.");
+                log_info("Unable to parse dynamic user line.");
                 return;
         }
 
         if (safe_atoi(s0, &fd0) < 0 || !fdset_contains(fds, fd0)) {
-                log_debug("Unable to process dynamic user fd specification.");
+                log_info("Unable to process dynamic user fd specification.");
                 return;
         }
 
         if (safe_atoi(s1, &fd1) < 0 || !fdset_contains(fds, fd1)) {
-                log_debug("Unable to process dynamic user fd specification.");
+                log_info("Unable to process dynamic user fd specification.");
                 return;
         }
 
         r = dynamic_user_add(m, name, (int[]) { fd0, fd1 }, NULL);
         if (r < 0) {
-                log_debug_errno(r, "Failed to add dynamic user: %m");
+                log_info_errno(r, "Failed to add dynamic user: %m");
                 return;
         }
 
@@ -735,7 +735,7 @@ void dynamic_user_vacuum(Manager *m, bool close_user) {
                         continue;
 
                 if (close_user) {
-                        log_debug("Removing orphaned dynamic user %s", d->name);
+                        log_info("Removing orphaned dynamic user %s", d->name);
                         (void) dynamic_user_close(d);
                 }
 
diff --git a/src/core/execute.c b/src/core/execute.c
index 0df3971df..1aa69066e 100644
--- a/src/core/execute.c
+++ b/src/core/execute.c
@@ -4717,7 +4717,7 @@ void exec_runtime_destroy(ExecRuntime *rt) {
                 return;
 
         if (rt->tmp_dir) {
-                log_debug("Spawning thread to nuke %s", rt->tmp_dir);
+                log_info("Spawning thread to nuke %s", rt->tmp_dir);
 
                 r = asynchronous_job(remove_tmpdir_thread, rt->tmp_dir);
                 if (r < 0) {
@@ -4729,7 +4729,7 @@ void exec_runtime_destroy(ExecRuntime *rt) {
         }
 
         if (rt->var_tmp_dir) {
-                log_debug("Spawning thread to nuke %s", rt->var_tmp_dir);
+                log_info("Spawning thread to nuke %s", rt->var_tmp_dir);
 
                 r = asynchronous_job(remove_tmpdir_thread, rt->var_tmp_dir);
                 if (r < 0) {
diff --git a/src/core/ima-setup.c b/src/core/ima-setup.c
index 80319622a..3c892599b 100644
--- a/src/core/ima-setup.c
+++ b/src/core/ima-setup.c
@@ -41,7 +41,7 @@ int ima_setup(void) {
         char line[page_size()];
 
         if (access(IMA_SECFS_DIR, F_OK) < 0) {
-                log_debug("IMA support is disabled in the kernel, ignoring.");
+                log_info("IMA support is disabled in the kernel, ignoring.");
                 return 0;
         }
 
@@ -51,7 +51,7 @@ int ima_setup(void) {
         }
 
         if (access(IMA_POLICY_PATH, F_OK) < 0) {
-                log_debug("No IMA custom policy file "IMA_POLICY_PATH", ignoring.");
+                log_info("No IMA custom policy file "IMA_POLICY_PATH", ignoring.");
                 return 0;
         }
 
diff --git a/src/core/job.c b/src/core/job.c
index c6de8d27e..ba5fcfdc3 100644
--- a/src/core/job.c
+++ b/src/core/job.c
@@ -242,7 +242,7 @@ int job_install_deserialized(Job *j) {
         assert(!j->installed);
 
         if (j->type < 0 || j->type >= _JOB_TYPE_MAX_IN_TRANSACTION) {
-                log_debug("Invalid job type %s in deserialization.", strna(job_type_to_string(j->type)));
+                log_info("Invalid job type %s in deserialization.", strna(job_type_to_string(j->type)));
                 return -EINVAL;
         }
 
@@ -1098,16 +1098,16 @@ int job_deserialize(Job *j, FILE *f) {
                 if (streq(l, "job-id")) {
 
                         if (safe_atou32(v, &j->id) < 0)
-                                log_debug("Failed to parse job id value %s", v);
+                                log_info("Failed to parse job id value %s", v);
 
                 } else if (streq(l, "job-type")) {
                         JobType t;
 
                         t = job_type_from_string(v);
                         if (t < 0)
-                                log_debug("Failed to parse job type %s", v);
+                                log_info("Failed to parse job type %s", v);
                         else if (t >= _JOB_TYPE_MAX_IN_TRANSACTION)
-                                log_debug("Cannot deserialize job of type %s", v);
+                                log_info("Cannot deserialize job of type %s", v);
                         else
                                 j->type = t;
 
@@ -1116,7 +1116,7 @@ int job_deserialize(Job *j, FILE *f) {
 
                         s = job_state_from_string(v);
                         if (s < 0)
-                                log_debug("Failed to parse job state %s", v);
+                                log_info("Failed to parse job state %s", v);
                         else
                                 job_set_state(j, s);
 
@@ -1125,7 +1125,7 @@ int job_deserialize(Job *j, FILE *f) {
 
                         b = parse_boolean(v);
                         if (b < 0)
-                                log_debug("Failed to parse job irreversible flag %s", v);
+                                log_info("Failed to parse job irreversible flag %s", v);
                         else
                                 j->irreversible = j->irreversible || b;
 
@@ -1134,7 +1134,7 @@ int job_deserialize(Job *j, FILE *f) {
 
                         b = parse_boolean(v);
                         if (b < 0)
-                                log_debug("Failed to parse job sent_dbus_new_signal flag %s", v);
+                                log_info("Failed to parse job sent_dbus_new_signal flag %s", v);
                         else
                                 j->sent_dbus_new_signal = j->sent_dbus_new_signal || b;
 
@@ -1143,7 +1143,7 @@ int job_deserialize(Job *j, FILE *f) {
 
                         b = parse_boolean(v);
                         if (b < 0)
-                                log_debug("Failed to parse job ignore_order flag %s", v);
+                                log_info("Failed to parse job ignore_order flag %s", v);
                         else
                                 j->ignore_order = j->ignore_order || b;
 
@@ -1151,7 +1151,7 @@ int job_deserialize(Job *j, FILE *f) {
                         unsigned long long ull;
 
                         if (sscanf(v, "%llu", &ull) != 1)
-                                log_debug("Failed to parse job-begin value %s", v);
+                                log_info("Failed to parse job-begin value %s", v);
                         else
                                 j->begin_usec = ull;
 
@@ -1159,7 +1159,7 @@ int job_deserialize(Job *j, FILE *f) {
                         unsigned long long ull;
 
                         if (sscanf(v, "%llu", &ull) != 1)
-                                log_debug("Failed to parse job-begin-running value %s", v);
+                                log_info("Failed to parse job-begin-running value %s", v);
                         else
                                 j->begin_running_usec = ull;
 
@@ -1210,7 +1210,7 @@ int job_coldplug(Job *j) {
                         timeout_time, 0,
                         job_dispatch_timer, j);
         if (r < 0)
-                log_debug_errno(r, "Failed to restart timeout for job: %m");
+                log_info_errno(r, "Failed to restart timeout for job: %m");
 
         (void) sd_event_source_set_description(j->timer_event_source, "job-timeout");
 
diff --git a/src/core/kmod-setup.c b/src/core/kmod-setup.c
index a2809d03f..e10b76260 100644
--- a/src/core/kmod-setup.c
+++ b/src/core/kmod-setup.c
@@ -127,7 +127,7 @@ int kmod_setup(void) {
                         continue;
 
                 if (kmod_table[i].warn_if_module)
-                        log_debug("Your kernel apparently lacks built-in %s support. Might be "
+                        log_info("Your kernel apparently lacks built-in %s support. Might be "
                                   "a good idea to compile it in. We'll now try to work around "
                                   "this by loading the module...", kmod_table[i].module);
 
@@ -148,7 +148,7 @@ int kmod_setup(void) {
 
                 r = kmod_module_probe_insert_module(mod, KMOD_PROBE_APPLY_BLACKLIST, NULL, NULL, NULL, NULL);
                 if (r == 0)
-                        log_debug("Inserted module '%s'", kmod_module_get_name(mod));
+                        log_info("Inserted module '%s'", kmod_module_get_name(mod));
                 else if (r == KMOD_PROBE_APPLY_BLACKLIST)
                         log_info("Module '%s' is blacklisted", kmod_module_get_name(mod));
                 else {
diff --git a/src/core/load-fragment.c b/src/core/load-fragment.c
index 00408c4b8..7eb9f898d 100644
--- a/src/core/load-fragment.c
+++ b/src/core/load-fragment.c
@@ -4673,7 +4673,7 @@ static int load_from_path(Unit *u, const char *path) {
                          * EACCES means that the directory or file permissions are wrong.
                          */
                         if (r == -EACCES)
-                                log_debug_errno(r, "Cannot access \"%s\": %m", filename);
+                                log_info_errno(r, "Cannot access \"%s\": %m", filename);
                         else if (!IN_SET(r, -ENOENT, -ENOTDIR))
                                 return r;
 
diff --git a/src/core/loopback-setup.c b/src/core/loopback-setup.c
index 1528034e8..e2984cde3 100644
--- a/src/core/loopback-setup.c
+++ b/src/core/loopback-setup.c
@@ -48,9 +48,9 @@ static int generic_handler(sd_netlink *rtnl, sd_netlink_message *m, void *userda
 
         r = sd_netlink_message_get_errno(m);
         if (r < 0)
-                log_debug_errno(r, "%s: %m", s->error_message);
+                log_info_errno(r, "%s: %m", s->error_message);
         else
-                log_debug("%s", s->success_message);
+                log_info("%s", s->success_message);
 
         s->rcode = r;
         return 0;
diff --git a/src/core/machine-id-setup.c b/src/core/machine-id-setup.c
index 1b7424800..96234dcb9 100644
--- a/src/core/machine-id-setup.c
+++ b/src/core/machine-id-setup.c
@@ -207,7 +207,7 @@ int machine_id_commit(const char *root) {
         if (r < 0)
                 return log_error_errno(r, "Failed to determine whether %s is a mount point: %m", etc_machine_id);
         if (r == 0) {
-                log_debug("%s is not a mount point. Nothing to do.", etc_machine_id);
+                log_info("%s is not a mount point. Nothing to do.", etc_machine_id);
                 return 0;
         }
 
diff --git a/src/core/main.c b/src/core/main.c
index 56200a8fa..b8109ffd4 100644
--- a/src/core/main.c
+++ b/src/core/main.c
@@ -263,7 +263,7 @@ static void install_crash_handler(void) {
          * cannot set up a crash handler */
         r = sigaction_many(&sa, SIGNALS_CRASH_HANDLER, -1);
         if (r < 0)
-                log_debug_errno(r, "I had trouble setting up the crash handler, ignoring: %m");
+                log_info_errno(r, "I had trouble setting up the crash handler, ignoring: %m");
 }
 
 static int console_setup(void) {
@@ -1704,7 +1704,7 @@ static void do_reexecute(
                 valgrind_summary_hack();
 
                 (void) execv(args[0], (char* const*) args);
-                log_debug_errno(errno, "Failed to execute our own binary, trying fallback: %m");
+                log_info_errno(errno, "Failed to execute our own binary, trying fallback: %m");
         }
 
         /* Try the fallback, if there is any, without any serialization. We pass the original argv[] and envp[]. (Well,
@@ -1841,7 +1841,7 @@ static int invoke_main_loop(
                 case MANAGER_EXIT:
 
                         if (MANAGER_IS_USER(m)) {
-                                log_debug("Exit.");
+                                log_info("Exit.");
 
                                 *ret_reexecute = false;
                                 *ret_retval = m->return_value;
@@ -1916,7 +1916,7 @@ static void log_execution_mode(bool *ret_first_boot) {
                         _cleanup_free_ char *t;
 
                         t = uid_to_name(getuid());
-                        log_debug(PACKAGE_STRING " running in %suser mode for user " UID_FMT "/%s. (" SYSTEMD_FEATURES ")",
+                        log_info(PACKAGE_STRING " running in %suser mode for user " UID_FMT "/%s. (" SYSTEMD_FEATURES ")",
                                   arg_action == ACTION_TEST ? " test" : "", getuid(), strna(t));
                 }
 
@@ -2023,7 +2023,7 @@ static int do_queue_default_job(
         Unit *target = NULL;
         int r;
 
-        log_debug("Activating default unit: %s", arg_default_unit);
+        log_info("Activating default unit: %s", arg_default_unit);
 
         r = manager_load_unit(m, arg_default_unit, NULL, &error, &target);
         if (r < 0)
@@ -2054,7 +2054,7 @@ static int do_queue_default_job(
 
         r = manager_add_job(m, JOB_START, target, JOB_ISOLATE, &error, &default_unit_job);
         if (r == -EPERM) {
-                log_debug_errno(r, "Default target could not be isolated, starting instead: %s", bus_error_message(&error, r));
+                log_info_errno(r, "Default target could not be isolated, starting instead: %s", bus_error_message(&error, r));
 
                 sd_bus_error_free(&error);
 
diff --git a/src/core/manager.c b/src/core/manager.c
index e837a46f5..104b86e12 100644
--- a/src/core/manager.c
+++ b/src/core/manager.c
@@ -375,7 +375,7 @@ static int manager_setup_time_change(Manager *m) {
                 return log_error_errno(errno, "Failed to create timerfd: %m");
 
         if (timerfd_settime(m->time_change_fd, TFD_TIMER_ABSTIME|TFD_TIMER_CANCEL_ON_SET, &its, NULL) < 0) {
-                log_debug_errno(errno, "Failed to set up TFD_TIMER_CANCEL_ON_SET, ignoring: %m");
+                log_info_errno(errno, "Failed to set up TFD_TIMER_CANCEL_ON_SET, ignoring: %m");
                 m->time_change_fd = safe_close(m->time_change_fd);
                 return 0;
         }
@@ -386,7 +386,7 @@ static int manager_setup_time_change(Manager *m) {
 
         (void) sd_event_source_set_description(m->time_change_event_source, "manager-time-change");
 
-        log_debug("Set up TFD_TIMER_CANCEL_ON_SET timerfd.");
+        log_info("Set up TFD_TIMER_CANCEL_ON_SET timerfd.");
 
         return 0;
 }
@@ -836,7 +836,7 @@ static int manager_setup_notify(Manager *m) {
                 m->notify_fd = fd;
                 fd = -1;
 
-                log_debug("Using notification socket %s", m->notify_socket);
+                log_info("Using notification socket %s", m->notify_socket);
         }
 
         if (!m->notify_event_source) {
@@ -1100,7 +1100,7 @@ static unsigned manager_dispatch_gc_unit_queue(Manager *m) {
 
         assert(m);
 
-        /* log_debug("Running GC..."); */
+        /* log_info("Running GC..."); */
 
         m->gc_marker += _GC_OFFSET_MAX;
         if (m->gc_marker + _GC_OFFSET_MAX <= _GC_OFFSET_MAX)
@@ -1269,7 +1269,7 @@ void manager_enumerate(Manager *m) {
          * that it might know */
         for (c = 0; c < _UNIT_TYPE_MAX; c++) {
                 if (!unit_type_supported(c)) {
-                        log_debug("Unit type .%s is not supported on this system.", unit_type_to_string(c));
+                        log_info("Unit type .%s is not supported on this system.", unit_type_to_string(c));
                         continue;
                 }
 
@@ -2133,7 +2133,7 @@ static int manager_dispatch_sigchld(sd_event_source *source, void *userdata) {
 
                 (void) get_process_comm(si.si_pid, &name);
 
-                log_debug("Child "PID_FMT" (%s) died (code=%s, status=%i/%s)",
+                log_info("Child "PID_FMT" (%s) died (code=%s, status=%i/%s)",
                           si.si_pid, strna(name),
                           sigchld_code_to_string(si.si_code),
                           si.si_status,
@@ -2195,7 +2195,7 @@ static void manager_start_target(Manager *m, const char *name, JobMode mode) {
         _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;
         int r;
 
-        log_debug("Activating special unit %s", name);
+        log_info("Activating special unit %s", name);
 
         r = manager_add_job_by_name(m, JOB_START, name, mode, &error, NULL);
         if (r < 0)
@@ -2836,7 +2836,7 @@ int manager_deserialize(Manager *m, FILE *f, FDSet *fds) {
         assert(m);
         assert(f);
 
-        log_debug("Deserializing state...");
+        log_info("Deserializing state...");
 
         m->n_reloading++;
 
@@ -3560,7 +3560,7 @@ void manager_set_show_status(Manager *m, ShowStatus mode) {
                 return;
 
         if (m->show_status != mode)
-                log_debug("%s showing of status.",
+                log_info("%s showing of status.",
                           mode == SHOW_STATUS_NO ? "Disabling" : "Enabling");
         m->show_status = mode;
 
@@ -3804,7 +3804,7 @@ static void manager_unref_uid_internal(
                 hashmap_remove(*uid_refs, UID_TO_PTR(uid));
 
                 if (c & DESTROY_IPC_FLAG) {
-                        log_debug("%s " UID_FMT " is no longer referenced, cleaning up its IPC.",
+                        log_info("%s " UID_FMT " is no longer referenced, cleaning up its IPC.",
                                   _clean_ipc == clean_ipc_by_uid ? "UID" : "GID",
                                   uid);
                         (void) _clean_ipc(uid);
@@ -3894,7 +3894,7 @@ static void manager_vacuum_uid_refs_internal(
                         continue;
 
                 if (c & DESTROY_IPC_FLAG) {
-                        log_debug("Found unreferenced %s " UID_FMT " after reload/reexec. Cleaning up.",
+                        log_info("Found unreferenced %s " UID_FMT " after reload/reexec. Cleaning up.",
                                   _clean_ipc == clean_ipc_by_uid ? "UID" : "GID",
                                   uid);
                         (void) _clean_ipc(uid);
@@ -3966,7 +3966,7 @@ static void manager_deserialize_uid_refs_one_internal(
 
         r = parse_uid(value, &uid);
         if (r < 0 || uid == 0) {
-                log_debug("Unable to parse UID reference serialization");
+                log_info("Unable to parse UID reference serialization");
                 return;
         }
 
@@ -3984,7 +3984,7 @@ static void manager_deserialize_uid_refs_one_internal(
 
         r = hashmap_replace(*uid_refs, UID_TO_PTR(uid), UINT32_TO_PTR(c));
         if (r < 0) {
-                log_debug("Failed to add UID reference entry");
+                log_info("Failed to add UID reference entry");
                 return;
         }
 }
@@ -4048,7 +4048,7 @@ int manager_dispatch_user_lookup_fd(sd_event_source *source, int fd, uint32_t re
         buffer.unit_name[n] = 0;
         u = manager_get_unit(m, buffer.unit_name);
         if (!u) {
-                log_debug("Got user lookup message but unit doesn't exist, ignoring.");
+                log_info("Got user lookup message but unit doesn't exist, ignoring.");
                 return 0;
         }
 
diff --git a/src/core/mount-setup.c b/src/core/mount-setup.c
index a0c5f5aaa..e16dc6e86 100644
--- a/src/core/mount-setup.c
+++ b/src/core/mount-setup.c
@@ -187,7 +187,7 @@ static int mount_one(const MountPoint *p, bool relabel) {
         else
                 (void) mkdir_p(p->where, 0755);
 
-        log_debug("Mounting %s to %s of type %s with options %s.",
+        log_info("Mounting %s to %s of type %s with options %s.",
                   p->what,
                   p->where,
                   p->type,
diff --git a/src/core/mount.c b/src/core/mount.c
index 4c12542bd..75805ae20 100644
--- a/src/core/mount.c
+++ b/src/core/mount.c
@@ -1801,7 +1801,7 @@ static int mount_dispatch_io(sd_event_source *source, int fd, uint32_t revents,
                                 return log_error_errno(r, "Failed to drain libmount events");
                 } while (r == 0);
 
-                log_debug("libmount event [rescan: %s]", yes_no(rescan));
+                log_info("libmount event [rescan: %s]", yes_no(rescan));
                 if (!rescan)
                         return 0;
         }
diff --git a/src/core/namespace.c b/src/core/namespace.c
index 70089f212..802a42609 100644
--- a/src/core/namespace.c
+++ b/src/core/namespace.c
@@ -388,7 +388,7 @@ static void drop_duplicates(MountEntry *m, unsigned *n) {
                 /* The first one wins (which is the one with the more restrictive mode), see mount_path_compare()
                  * above. */
                 if (previous && path_equal(mount_entry_path(f), mount_entry_path(previous))) {
-                        log_debug("%s is duplicate.", mount_entry_path(f));
+                        log_info("%s is duplicate.", mount_entry_path(f));
                         previous->read_only = previous->read_only || mount_entry_read_only(f); /* Propagate the read-only flag to the remaining entry */
                         mount_entry_done(f);
                         continue;
@@ -417,7 +417,7 @@ static void drop_inaccessible(MountEntry *m, unsigned *n) {
                 /* If we found a path set for INACCESSIBLE earlier, and this entry has it as prefix we should drop
                  * it, as inaccessible paths really should drop the entire subtree. */
                 if (clear && path_startswith(mount_entry_path(f), clear)) {
-                        log_debug("%s is masked by %s.", mount_entry_path(f), clear);
+                        log_info("%s is masked by %s.", mount_entry_path(f), clear);
                         mount_entry_done(f);
                         continue;
                 }
@@ -457,7 +457,7 @@ static void drop_nop(MountEntry *m, unsigned *n) {
 
                         /* We found it, let's see if it's the same mode, if so, we can drop this entry */
                         if (found && p->mode == f->mode) {
-                                log_debug("%s is redundant by %s", mount_entry_path(f), mount_entry_path(p));
+                                log_info("%s is redundant by %s", mount_entry_path(f), mount_entry_path(p));
                                 mount_entry_done(f);
                                 continue;
                         }
@@ -485,7 +485,7 @@ static void drop_outside_root(const char *root_directory, MountEntry *m, unsigne
         for (f = m, t = m; f < m + *n; f++) {
 
                 if (!path_startswith(mount_entry_path(f), root_directory)) {
-                        log_debug("%s is outside of root directory.", mount_entry_path(f));
+                        log_info("%s is outside of root directory.", mount_entry_path(f));
                         mount_entry_done(f);
                         continue;
                 }
@@ -521,7 +521,7 @@ static int clone_device_node(const char *d, const char *temporary_mount) {
         r = mknod(dn, st.st_mode, st.st_rdev);
         mac_selinux_create_file_clear();
         if (r < 0)
-                return log_debug_errno(errno, "mknod failed for %s: %m", d);
+                return log_info_errno(errno, "mknod failed for %s: %m", d);
 
         return 1;
 }
@@ -663,12 +663,12 @@ static int mount_bind_dev(MountEntry *m) {
 
         r = path_is_mount_point(mount_entry_path(m), NULL, 0);
         if (r < 0)
-                return log_debug_errno(r, "Unable to determine whether /dev is already mounted: %m");
+                return log_info_errno(r, "Unable to determine whether /dev is already mounted: %m");
         if (r > 0) /* make this a NOP if /dev is already a mount point */
                 return 0;
 
         if (mount("/dev", mount_entry_path(m), NULL, MS_BIND|MS_REC, NULL) < 0)
-                return log_debug_errno(errno, "Failed to bind mount %s: %m", mount_entry_path(m));
+                return log_info_errno(errno, "Failed to bind mount %s: %m", mount_entry_path(m));
 
         return 1;
 }
@@ -682,13 +682,13 @@ static int mount_sysfs(MountEntry *m) {
 
         r = path_is_mount_point(mount_entry_path(m), NULL, 0);
         if (r < 0)
-                return log_debug_errno(r, "Unable to determine whether /sys is already mounted: %m");
+                return log_info_errno(r, "Unable to determine whether /sys is already mounted: %m");
         if (r > 0) /* make this a NOP if /sys is already a mount point */
                 return 0;
 
         /* Bind mount the host's version so that we get all child mounts of it, too. */
         if (mount("/sys", mount_entry_path(m), NULL, MS_BIND|MS_REC, NULL) < 0)
-                return log_debug_errno(errno, "Failed to mount %s: %m", mount_entry_path(m));
+                return log_info_errno(errno, "Failed to mount %s: %m", mount_entry_path(m));
 
         return 1;
 }
@@ -702,13 +702,13 @@ static int mount_procfs(MountEntry *m) {
 
         r = path_is_mount_point(mount_entry_path(m), NULL, 0);
         if (r < 0)
-                return log_debug_errno(r, "Unable to determine whether /proc is already mounted: %m");
+                return log_info_errno(r, "Unable to determine whether /proc is already mounted: %m");
         if (r > 0) /* make this a NOP if /proc is already a mount point */
                 return 0;
 
         /* Mount a new instance, so that we get the one that matches our user namespace, if we are running in one */
         if (mount("proc", mount_entry_path(m), "proc", MS_NOSUID|MS_NOEXEC|MS_NODEV, NULL) < 0)
-                return log_debug_errno(errno, "Failed to mount %s: %m", mount_entry_path(m));
+                return log_info_errno(errno, "Failed to mount %s: %m", mount_entry_path(m));
 
         return 1;
 }
@@ -722,7 +722,7 @@ static int mount_empty_dir(MountEntry *m) {
         (void) umount_recursive(mount_entry_path(m), 0);
 
         if (mount("tmpfs", mount_entry_path(m), "tmpfs", MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_STRICTATIME, "mode=755") < 0)
-                return log_debug_errno(errno, "Failed to mount %s: %m", mount_entry_path(m));
+                return log_info_errno(errno, "Failed to mount %s: %m", mount_entry_path(m));
 
         return 1;
 }
@@ -746,13 +746,13 @@ static int mount_entry_chase(
                            IN_SET(m->mode, BIND_MOUNT, BIND_MOUNT_RECURSIVE, PRIVATE_TMP, PRIVATE_VAR_TMP, PRIVATE_DEV, BIND_DEV, EMPTY_DIR, SYSFS, PROCFS) ? CHASE_NONEXISTENT : 0,
                            &chased);
         if (r == -ENOENT && m->ignore) {
-                log_debug_errno(r, "Path %s does not exist, ignoring.", path);
+                log_info_errno(r, "Path %s does not exist, ignoring.", path);
                 return 0;
         }
         if (r < 0)
-                return log_debug_errno(r, "Failed to follow symlinks on %s: %m", path);
+                return log_info_errno(r, "Failed to follow symlinks on %s: %m", path);
 
-        log_debug("Followed symlinks %s → %s.", path, chased);
+        log_info("Followed symlinks %s → %s.", path, chased);
 
         free(*location);
         *location = chased;
@@ -776,7 +776,7 @@ static int apply_mount(
         if (r <= 0)
                 return r;
 
-        log_debug("Applying namespace mount on %s", mount_entry_path(m));
+        log_info("Applying namespace mount on %s", mount_entry_path(m));
 
         switch (m->mode) {
 
@@ -789,11 +789,11 @@ static int apply_mount(
                 (void) umount_recursive(mount_entry_path(m), 0);
 
                 if (lstat(mount_entry_path(m), &target) < 0)
-                        return log_debug_errno(errno, "Failed to lstat() %s to determine what to mount over it: %m", mount_entry_path(m));
+                        return log_info_errno(errno, "Failed to lstat() %s to determine what to mount over it: %m", mount_entry_path(m));
 
                 what = mode_to_inaccessible_node(target.st_mode);
                 if (!what) {
-                        log_debug("File type not supported for inaccessible mounts. Note that symlinks are not allowed");
+                        log_info("File type not supported for inaccessible mounts. Note that symlinks are not allowed");
                         return -ELOOP;
                 }
                 break;
@@ -803,7 +803,7 @@ static int apply_mount(
         case READWRITE:
                 r = path_is_mount_point(mount_entry_path(m), root_directory, 0);
                 if (r < 0)
-                        return log_debug_errno(r, "Failed to determine whether %s is already a mount point: %m", mount_entry_path(m));
+                        return log_info_errno(r, "Failed to determine whether %s is already a mount point: %m", mount_entry_path(m));
                 if (r > 0) /* Nothing to do here, it is already a mount. We just later toggle the MS_RDONLY bit for the mount point if needed. */
                         return 0;
                 /* This isn't a mount point yet, let's make it one. */
@@ -884,10 +884,10 @@ static int apply_mount(
                 }
 
                 if (r < 0)
-                        return log_debug_errno(r, "Failed to mount %s to %s: %m", what, mount_entry_path(m));
+                        return log_info_errno(r, "Failed to mount %s to %s: %m", what, mount_entry_path(m));
         }
 
-        log_debug("Successfully mounted %s to %s", what, mount_entry_path(m));
+        log_info("Successfully mounted %s to %s", what, mount_entry_path(m));
         return 0;
 }
 
diff --git a/src/core/path.c b/src/core/path.c
index 8a5ec0a72..d57292641 100644
--- a/src/core/path.c
+++ b/src/core/path.c
@@ -681,7 +681,7 @@ static int path_dispatch_io(sd_event_source *source, int fd, uint32_t revents, v
         if (!IN_SET(p->state, PATH_WAITING, PATH_RUNNING))
                 return 0;
 
-        /* log_debug("inotify wakeup on %s.", u->id); */
+        /* log_info("inotify wakeup on %s.", u->id); */
 
         LIST_FOREACH(spec, s, p->specs)
                 if (path_spec_owns_inotify_fd(s, fd))
diff --git a/src/core/scope.c b/src/core/scope.c
index 468dd8121..3d0394de9 100644
--- a/src/core/scope.c
+++ b/src/core/scope.c
@@ -109,7 +109,7 @@ static void scope_set_state(Scope *s, ScopeState state) {
                 unit_unwatch_all_pids(UNIT(s));
 
         if (state != old_state)
-                log_debug("%s changed %s -> %s", UNIT(s)->id, scope_state_to_string(old_state), scope_state_to_string(state));
+                log_info("%s changed %s -> %s", UNIT(s)->id, scope_state_to_string(old_state), scope_state_to_string(state));
 
         unit_notify(UNIT(s), state_translation_table[old_state], state_translation_table[state], true);
 }
diff --git a/src/core/selinux-access.c b/src/core/selinux-access.c
index 475c3181c..aca2bd2dd 100644
--- a/src/core/selinux-access.c
+++ b/src/core/selinux-access.c
@@ -262,7 +262,7 @@ int mac_selinux_generic_access_check(
         if (r < 0)
                 r = sd_bus_error_setf(error, SD_BUS_ERROR_ACCESS_DENIED, "SELinux policy denies access.");
 
-        log_debug("SELinux access check scon=%s tcon=%s tclass=%s perm=%s path=%s cmdline=%s: %i", scon, fcon, tclass, permission, path, cl, r);
+        log_info("SELinux access check scon=%s tcon=%s tclass=%s perm=%s path=%s cmdline=%s: %i", scon, fcon, tclass, permission, path, cl, r);
 
 finish:
         freecon(fcon);
diff --git a/src/core/selinux-setup.c b/src/core/selinux-setup.c
index 713554210..5f4e08492 100644
--- a/src/core/selinux-setup.c
+++ b/src/core/selinux-setup.c
@@ -114,7 +114,7 @@ int mac_selinux_setup(bool *loaded_policy) {
 
                         log_warning("Failed to load new SELinux policy. Continuing with old policy.");
                 } else
-                        log_debug("Unable to load SELinux policy. Ignoring.");
+                        log_info("Unable to load SELinux policy. Ignoring.");
         }
 #endif
 
diff --git a/src/core/shutdown.c b/src/core/shutdown.c
index cc31b33f1..5aeac7183 100644
--- a/src/core/shutdown.c
+++ b/src/core/shutdown.c
@@ -426,7 +426,7 @@ int main(int argc, char *argv[]) {
                         goto initrd_jump;
                 }
 
-                log_debug("After %u retries, couldn't finalize remaining %s%s%s%s trying again.",
+                log_info("After %u retries, couldn't finalize remaining %s%s%s%s trying again.",
                           retries + 1,
                           need_umount ? " file systems," : "",
                           need_swapoff ? " swap devices," : "",
diff --git a/src/core/slice.c b/src/core/slice.c
index fef47b04f..580602de7 100644
--- a/src/core/slice.c
+++ b/src/core/slice.c
@@ -50,7 +50,7 @@ static void slice_set_state(Slice *t, SliceState state) {
         t->state = state;
 
         if (state != old_state)
-                log_debug("%s changed %s -> %s",
+                log_info("%s changed %s -> %s",
                           UNIT(t)->id,
                           slice_state_to_string(old_state),
                           slice_state_to_string(state));
@@ -265,12 +265,12 @@ static int slice_deserialize_item(Unit *u, const char *key, const char *value, F
 
                 state = slice_state_from_string(value);
                 if (state < 0)
-                        log_debug("Failed to parse state value %s", value);
+                        log_info("Failed to parse state value %s", value);
                 else
                         s->deserialized_state = state;
 
         } else
-                log_debug("Unknown serialization key '%s'", key);
+                log_info("Unknown serialization key '%s'", key);
 
         return 0;
 }
diff --git a/src/core/smack-setup.c b/src/core/smack-setup.c
index b0d3612d6..eec316dc1 100644
--- a/src/core/smack-setup.c
+++ b/src/core/smack-setup.c
@@ -332,10 +332,10 @@ int mac_smack_setup(bool *loaded_policy) {
         r = write_access2_rules("/etc/smack/accesses.d/");
         switch(r) {
         case -ENOENT:
-                log_debug("Smack is not enabled in the kernel.");
+                log_info("Smack is not enabled in the kernel.");
                 return 0;
         case ENOENT:
-                log_debug("Smack access rules directory '/etc/smack/accesses.d/' not found");
+                log_info("Smack access rules directory '/etc/smack/accesses.d/' not found");
                 return 0;
         case 0:
                 log_info("Successfully loaded Smack policies.");
@@ -364,10 +364,10 @@ int mac_smack_setup(bool *loaded_policy) {
         r = write_cipso2_rules("/etc/smack/cipso.d/");
         switch(r) {
         case -ENOENT:
-                log_debug("Smack/CIPSO is not enabled in the kernel.");
+                log_info("Smack/CIPSO is not enabled in the kernel.");
                 return 0;
         case ENOENT:
-                log_debug("Smack/CIPSO access rules directory '/etc/smack/cipso.d/' not found");
+                log_info("Smack/CIPSO access rules directory '/etc/smack/cipso.d/' not found");
                 break;
         case 0:
                 log_info("Successfully loaded Smack/CIPSO policies.");
@@ -380,10 +380,10 @@ int mac_smack_setup(bool *loaded_policy) {
         r = write_netlabel_rules("/etc/smack/netlabel.d/");
         switch(r) {
         case -ENOENT:
-                log_debug("Smack/CIPSO is not enabled in the kernel.");
+                log_info("Smack/CIPSO is not enabled in the kernel.");
                 return 0;
         case ENOENT:
-                log_debug("Smack network host rules directory '/etc/smack/netlabel.d/' not found");
+                log_info("Smack network host rules directory '/etc/smack/netlabel.d/' not found");
                 break;
         case 0:
                 log_info("Successfully loaded Smack network host rules.");
@@ -396,10 +396,10 @@ int mac_smack_setup(bool *loaded_policy) {
         r = write_onlycap_list();
         switch(r) {
         case -ENOENT:
-                log_debug("Smack is not enabled in the kernel.");
+                log_info("Smack is not enabled in the kernel.");
                 break;
         case ENOENT:
-                log_debug("Smack onlycap list file '/etc/smack/onlycap' not found");
+                log_info("Smack onlycap list file '/etc/smack/onlycap' not found");
                 break;
         case 0:
                 log_info("Successfully wrote Smack onlycap list.");
diff --git a/src/core/swap.c b/src/core/swap.c
index 70097ff2b..25f5179ea 100644
--- a/src/core/swap.c
+++ b/src/core/swap.c
@@ -1293,7 +1293,7 @@ static void swap_enumerate(Manager *m) {
                 m->proc_swaps = fopen("/proc/swaps", "re");
                 if (!m->proc_swaps) {
                         if (errno == ENOENT)
-                                log_debug("Not swap enabled, skipping enumeration");
+                                log_info("Not swap enabled, skipping enumeration");
                         else
                                 log_error_errno(errno, "Failed to open /proc/swaps: %m");
 
diff --git a/src/core/target.c b/src/core/target.c
index 756cbbfb6..4c6938595 100644
--- a/src/core/target.c
+++ b/src/core/target.c
@@ -39,7 +39,7 @@ static void target_set_state(Target *t, TargetState state) {
         t->state = state;
 
         if (state != old_state)
-                log_debug("%s changed %s -> %s",
+                log_info("%s changed %s -> %s",
                           UNIT(t)->id,
                           target_state_to_string(old_state),
                           target_state_to_string(state));
@@ -179,12 +179,12 @@ static int target_deserialize_item(Unit *u, const char *key, const char *value,
 
                 state = target_state_from_string(value);
                 if (state < 0)
-                        log_debug("Failed to parse state value %s", value);
+                        log_info("Failed to parse state value %s", value);
                 else
                         s->deserialized_state = state;
 
         } else
-                log_debug("Unknown serialization key '%s'", key);
+                log_info("Unknown serialization key '%s'", key);
 
         return 0;
 }
diff --git a/src/core/transaction.c b/src/core/transaction.c
index 32ad66002..78ef37d89 100644
--- a/src/core/transaction.c
+++ b/src/core/transaction.c
@@ -318,7 +318,7 @@ rescan:
                                 goto next_unit;
                 }
 
-                /* log_debug("Found redundant job %s/%s, dropping.", j->unit->id, job_type_to_string(j->type)); */
+                /* log_info("Found redundant job %s/%s, dropping.", j->unit->id, job_type_to_string(j->type)); */
                 transaction_delete_job(tr, j, false);
                 goto rescan;
         next_unit:;
@@ -513,14 +513,14 @@ static void transaction_collect_garbage(Transaction *tr) {
 rescan:
         HASHMAP_FOREACH(j, tr->jobs, i) {
                 if (tr->anchor_job == j || j->object_list) {
-                        /* log_debug("Keeping job %s/%s because of %s/%s", */
+                        /* log_info("Keeping job %s/%s because of %s/%s", */
                         /*           j->unit->id, job_type_to_string(j->type), */
                         /*           j->object_list->subject ? j->object_list->subject->unit->id : "root", */
                         /*           j->object_list->subject ? job_type_to_string(j->object_list->subject->type) : "root"); */
                         continue;
                 }
 
-                /* log_debug("Garbage collecting job %s/%s", j->unit->id, job_type_to_string(j->type)); */
+                /* log_info("Garbage collecting job %s/%s", j->unit->id, job_type_to_string(j->type)); */
                 transaction_delete_job(tr, j, true);
                 goto rescan;
         }
@@ -820,7 +820,7 @@ static Job* transaction_add_one_job(Transaction *tr, JobType type, Unit *unit, b
         if (is_new)
                 *is_new = true;
 
-        /* log_debug("Added job %s/%s to transaction.", unit->id, job_type_to_string(type)); */
+        /* log_info("Added job %s/%s to transaction.", unit->id, job_type_to_string(type)); */
 
         return j;
 }
@@ -914,7 +914,7 @@ int transaction_add_job_and_dependencies(
         if (MANAGER_IS_RELOADING(unit->manager))
                 unit_coldplug(unit);
 
-        /* log_debug("Pulling in %s/%s from %s/%s", */
+        /* log_info("Pulling in %s/%s from %s/%s", */
         /*           unit->id, job_type_to_string(type), */
         /*           by ? by->unit->id : "NA", */
         /*           by ? job_type_to_string(by->type) : "NA"); */
diff --git a/src/coredump/coredump.c b/src/coredump/coredump.c
index fdcea22f5..24eb8c95c 100644
--- a/src/coredump/coredump.c
+++ b/src/coredump/coredump.c
@@ -787,7 +787,7 @@ static int submit_coredump(
                 else
                         log_warning_errno(r, "Failed to generate stack trace: %m");
         } else
-                log_debug("Not generating stack trace: core size %"PRIu64" is greater than %"PRIu64" (the configured maximum)",
+                log_info("Not generating stack trace: core size %"PRIu64" is greater than %"PRIu64" (the configured maximum)",
                           coredump_size, arg_process_size_max);
 
         if (!core_message)
@@ -890,7 +890,7 @@ static int process_socket(int fd) {
         log_parse_environment();
         log_open();
 
-        log_debug("Processing coredump received on stdin...");
+        log_info("Processing coredump received on stdin...");
 
         for (;;) {
                 union {
@@ -1235,7 +1235,7 @@ static int process_kernel(int argc, char* argv[]) {
         size_t i, n_iovec, n_to_free = 0;
         int r;
 
-        log_debug("Processing coredump received from the kernel...");
+        log_info("Processing coredump received from the kernel...");
 
         if (argc < CONTEXT_COMM + 1) {
                 log_error("Not enough arguments passed by the kernel (%i, expected %i).", argc - 1, CONTEXT_COMM + 1 - 1);
@@ -1291,7 +1291,7 @@ static int process_backtrace(int argc, char *argv[]) {
                 .fd = STDIN_FILENO,
         };
 
-        log_debug("Processing backtrace on stdin...");
+        log_info("Processing backtrace on stdin...");
 
         if (argc < CONTEXT_COMM + 1) {
                 log_error("Not enough arguments passed (%i, expected %i).", argc - 1, CONTEXT_COMM + 1 - 1);
@@ -1389,8 +1389,8 @@ int main(int argc, char *argv[]) {
         /* Ignore all parse errors */
         (void) parse_config();
 
-        log_debug("Selected storage '%s'.", coredump_storage_to_string(arg_storage));
-        log_debug("Selected compression %s.", yes_no(arg_compress));
+        log_info("Selected storage '%s'.", coredump_storage_to_string(arg_storage));
+        log_info("Selected compression %s.", yes_no(arg_compress));
 
         r = sd_listen_fds(false);
         if (r < 0) {
diff --git a/src/coredump/coredumpctl.c b/src/coredump/coredumpctl.c
index 96e4a3e7e..874d825f2 100644
--- a/src/coredump/coredumpctl.c
+++ b/src/coredump/coredumpctl.c
@@ -98,7 +98,7 @@ static int add_match(sd_journal *j, const char *match) {
         if (!pattern)
                 return log_oom();
 
-        log_debug("Adding match: %s", pattern);
+        log_info("Adding match: %s", pattern);
         r = sd_journal_add_match(j, pattern, 0);
         if (r < 0)
                 return log_error_errno(r, "Failed to add match \"%s\": %m", match);
@@ -778,7 +778,7 @@ static int save_core(sd_journal *j, FILE *file, char **path, bool *unlink_temp)
                 fdt = mkostemp_safe(temp);
                 if (fdt < 0)
                         return log_error_errno(fdt, "Failed to create temporary file: %m");
-                log_debug("Created temporary file %s", temp);
+                log_info("Created temporary file %s", temp);
 
                 fd = fdt;
         } else {
@@ -854,7 +854,7 @@ static int save_core(sd_journal *j, FILE *file, char **path, bool *unlink_temp)
 error:
         if (temp) {
                 unlink(temp);
-                log_debug("Removed temporary file %s", temp);
+                log_info("Removed temporary file %s", temp);
         }
         return r;
 }
@@ -942,7 +942,7 @@ finish:
         (void) default_signals(SIGINT, -1);
 
         if (unlink_path) {
-                log_debug("Removed temporary file %s", path);
+                log_info("Removed temporary file %s", path);
                 unlink(path);
         }
 
@@ -996,7 +996,7 @@ static int check_units_active(void) {
                                 &id,  NULL,  NULL,  &state,  &substate,
                                 NULL,  NULL,  NULL,  NULL,  NULL)) > 0) {
                 bool found = !STR_IN_SET(state, "inactive", "dead", "failed");
-                log_debug("Unit %s is %s/%s, %scounting it.", id, state, substate, found ? "" : "not ");
+                log_info("Unit %s is %s/%s, %scounting it.", id, state, substate, found ? "" : "not ");
                 c += found;
         }
         if (r < 0)
@@ -1052,7 +1052,7 @@ int main(int argc, char *argv[]) {
                 _cleanup_free_ char *filter;
 
                 filter = journal_make_match_string(j);
-                log_debug("Journal filter: %s", filter);
+                log_info("Journal filter: %s", filter);
         }
 
         units_active = check_units_active(); /* error is treated the same as 0 */
diff --git a/src/cryptsetup/cryptsetup.c b/src/cryptsetup/cryptsetup.c
index 7255ff418..e6addf170 100644
--- a/src/cryptsetup/cryptsetup.c
+++ b/src/cryptsetup/cryptsetup.c
@@ -632,7 +632,7 @@ int main(int argc, char *argv[]) {
                 mlockall(MCL_FUTURE);
 
                 if (arg_header) {
-                        log_debug("LUKS header: %s", arg_header);
+                        log_info("LUKS header: %s", arg_header);
                         r = crypt_init(&cd, arg_header);
                 } else
                         r = crypt_init(&cd, argv[3]);
diff --git a/src/delta/delta.c b/src/delta/delta.c
index 645b0b227..7256f70b0 100644
--- a/src/delta/delta.c
+++ b/src/delta/delta.c
@@ -220,7 +220,7 @@ static int enumerate_dir_d(
         if (!path)
                 return -ENOMEM;
 
-        log_debug("Looking at %s", path);
+        log_info("Looking at %s", path);
 
         unit = strdup(drop);
         if (!unit)
@@ -251,7 +251,7 @@ static int enumerate_dir_d(
                         return -ENOMEM;
                 d = p + strlen(toppath) + 1;
 
-                log_debug("Adding at top: %s %s %s", d, special_glyph(ARROW), p);
+                log_info("Adding at top: %s %s %s", d, special_glyph(ARROW), p);
                 k = ordered_hashmap_put(top, d, p);
                 if (k >= 0) {
                         p = strdup(p);
@@ -263,7 +263,7 @@ static int enumerate_dir_d(
                         return k;
                 }
 
-                log_debug("Adding at bottom: %s %s %s", d, special_glyph(ARROW), p);
+                log_info("Adding at bottom: %s %s %s", d, special_glyph(ARROW), p);
                 free(ordered_hashmap_remove(bottom, d));
                 k = ordered_hashmap_put(bottom, d, p);
                 if (k < 0) {
@@ -286,7 +286,7 @@ static int enumerate_dir_d(
                 if (!p)
                         return -ENOMEM;
 
-                log_debug("Adding to drops: %s %s %s %s %s",
+                log_info("Adding to drops: %s %s %s %s %s",
                           unit, special_glyph(ARROW), basename(p), special_glyph(ARROW), p);
                 k = ordered_hashmap_put(h, basename(p), p);
                 if (k < 0) {
@@ -316,7 +316,7 @@ static int enumerate_dir(
         assert(drops);
         assert(path);
 
-        log_debug("Looking at %s", path);
+        log_info("Looking at %s", path);
 
         d = opendir(path);
         if (!d) {
@@ -367,7 +367,7 @@ static int enumerate_dir(
                 if (!p)
                         return -ENOMEM;
 
-                log_debug("Adding at top: %s %s %s", basename(p), special_glyph(ARROW), p);
+                log_info("Adding at top: %s %s %s", basename(p), special_glyph(ARROW), p);
                 r = ordered_hashmap_put(top, basename(p), p);
                 if (r >= 0) {
                         p = strdup(p);
@@ -376,7 +376,7 @@ static int enumerate_dir(
                 } else if (r != -EEXIST)
                         return r;
 
-                log_debug("Adding at bottom: %s %s %s", basename(p), special_glyph(ARROW), p);
+                log_info("Adding at bottom: %s %s %s", basename(p), special_glyph(ARROW), p);
                 free(ordered_hashmap_remove(bottom, basename(p)));
                 r = ordered_hashmap_put(bottom, basename(p), p);
                 if (r < 0)
@@ -403,7 +403,7 @@ static bool should_skip_path(const char *prefix, const char *suffix) {
                         continue;
 
                 if (path_equal(target, strjoina(p, "/", suffix))) {
-                        log_debug("%s redirects to %s, skipping.", dirname, target);
+                        log_info("%s redirects to %s, skipping.", dirname, target);
                         return true;
                 }
         }
diff --git a/src/fsck/fsck.c b/src/fsck/fsck.c
index 97d824aca..32cb981a0 100644
--- a/src/fsck/fsck.c
+++ b/src/fsck/fsck.c
@@ -343,7 +343,7 @@ int main(int argc, char *argv[]) {
 
                 /* Virtual root devices don't need an fsck */
                 if (major(st.st_dev) == 0) {
-                        log_debug("Root directory is virtual or btrfs, skipping check.");
+                        log_info("Root directory is virtual or btrfs, skipping check.");
                         r = 0;
                         goto finish;
                 }
diff --git a/src/fstab-generator/fstab-generator.c b/src/fstab-generator/fstab-generator.c
index f392f8909..12329027e 100644
--- a/src/fstab-generator/fstab-generator.c
+++ b/src/fstab-generator/fstab-generator.c
@@ -573,7 +573,7 @@ static int parse_fstab(bool initrd) {
                                 if (streq(canonical_where, where))
                                         canonical_where = mfree(canonical_where);
                                 else
-                                        log_debug("Canonicalized what=%s where=%s to %s",
+                                        log_info("Canonicalized what=%s where=%s to %s",
                                                   what, where, canonical_where);
                         }
                 }
@@ -582,7 +582,7 @@ static int parse_fstab(bool initrd) {
                 growfs = fstab_test_option(me->mnt_opts, "x-systemd.growfs\0");
                 noauto = fstab_test_yes_no_option(me->mnt_opts, "noauto\0" "auto\0");
                 nofail = fstab_test_yes_no_option(me->mnt_opts, "nofail\0" "fail\0");
-                log_debug("Found entry what=%s where=%s type=%s makefs=%s nofail=%s noauto=%s",
+                log_info("Found entry what=%s where=%s type=%s makefs=%s nofail=%s noauto=%s",
                           what, where, me->mnt_type,
                           yes_no(makefs),
                           yes_no(noauto), yes_no(nofail));
@@ -629,19 +629,19 @@ static int add_sysroot_mount(void) {
         int r;
 
         if (isempty(arg_root_what)) {
-                log_debug("Could not find a root= entry on the kernel command line.");
+                log_info("Could not find a root= entry on the kernel command line.");
                 return 0;
         }
 
         if (streq(arg_root_what, "gpt-auto")) {
                 /* This is handled by the gpt-auto generator */
-                log_debug("Skipping root directory handling, as gpt-auto was requested.");
+                log_info("Skipping root directory handling, as gpt-auto was requested.");
                 return 0;
         }
 
         if (path_equal(arg_root_what, "/dev/nfs")) {
                 /* This is handled by the kernel or the initrd */
-                log_debug("Skipping root directory handling, as /dev/nfs was requested.");
+                log_info("Skipping root directory handling, as /dev/nfs was requested.");
                 return 0;
         }
 
@@ -657,7 +657,7 @@ static int add_sysroot_mount(void) {
         else
                 opts = arg_root_options;
 
-        log_debug("Found entry what=%s where=/sysroot type=%s", what, strna(arg_root_fstype));
+        log_info("Found entry what=%s where=/sysroot type=%s", what, strna(arg_root_fstype));
 
         if (is_device_path(what)) {
                 r = generator_write_initrd_root_device_deps(arg_dest, what);
@@ -717,7 +717,7 @@ static int add_sysroot_usr_mount(void) {
         else
                 opts = arg_usr_options;
 
-        log_debug("Found entry what=%s where=/sysroot/usr type=%s", what, strna(arg_usr_fstype));
+        log_info("Found entry what=%s where=/sysroot/usr type=%s", what, strna(arg_usr_fstype));
         return add_mount(arg_dest,
                          what,
                          "/sysroot/usr",
@@ -924,7 +924,7 @@ int main(int argc, char *argv[]) {
         if (arg_fstab_enabled) {
                 int k;
 
-                log_debug("Parsing /etc/fstab");
+                log_info("Parsing /etc/fstab");
 
                 /* Parse the local /etc/fstab, possibly from the initrd */
                 k = parse_fstab(false);
@@ -933,7 +933,7 @@ int main(int argc, char *argv[]) {
 
                 /* If running in the initrd also parse the /etc/fstab from the host */
                 if (in_initrd()) {
-                        log_debug("Parsing /sysroot/etc/fstab");
+                        log_info("Parsing /sysroot/etc/fstab");
 
                         k = parse_fstab(true);
                         if (k < 0)
diff --git a/src/getty-generator/getty-generator.c b/src/getty-generator/getty-generator.c
index f475aef66..552950386 100644
--- a/src/getty-generator/getty-generator.c
+++ b/src/getty-generator/getty-generator.c
@@ -68,7 +68,7 @@ static int add_serial_getty(const char *tty) {
 
         assert(tty);
 
-        log_debug("Automatically adding serial getty for /dev/%s.", tty);
+        log_info("Automatically adding serial getty for /dev/%s.", tty);
 
         r = unit_name_from_path_instance("serial-getty", tty, ".service", &n);
         if (r < 0)
@@ -83,7 +83,7 @@ static int add_container_getty(const char *tty) {
 
         assert(tty);
 
-        log_debug("Automatically adding container getty for /dev/pts/%s.", tty);
+        log_info("Automatically adding container getty for /dev/pts/%s.", tty);
 
         r = unit_name_from_path_instance("container-getty", tty, ".service", &n);
         if (r < 0)
@@ -148,7 +148,7 @@ int main(int argc, char *argv[]) {
         if (detect_container() > 0) {
                 _cleanup_free_ char *container_ttys = NULL;
 
-                log_debug("Automatically adding console shell.");
+                log_info("Automatically adding console shell.");
 
                 if (add_symlink("console-getty.service", "console-getty.service") < 0)
                         return EXIT_FAILURE;
diff --git a/src/gpt-auto-generator/gpt-auto-generator.c b/src/gpt-auto-generator/gpt-auto-generator.c
index cbdbc5afe..979eb1039 100644
--- a/src/gpt-auto-generator/gpt-auto-generator.c
+++ b/src/gpt-auto-generator/gpt-auto-generator.c
@@ -184,7 +184,7 @@ static int add_mount(
         assert(where);
         assert(description);
 
-        log_debug("Adding %s: %s %s", where, what, strna(fstype));
+        log_info("Adding %s: %s %s", where, what, strna(fstype));
 
         if (streq_ptr(fstype, "crypto_LUKS")) {
 
@@ -277,7 +277,7 @@ static int add_partition_mount(
         assert(p);
 
         if (path_is_busy(where)) {
-                log_debug("%s already populated, ignoring.", where);
+                log_info("%s already populated, ignoring.", where);
                 return 0;
         }
 
@@ -304,11 +304,11 @@ static int add_swap(const char *path) {
         if (r < 0)
                 return log_error_errno(r, "Failed to parse fstab: %m");
         if (r > 0) {
-                log_debug("swap specified in fstab, ignoring.");
+                log_info("swap specified in fstab, ignoring.");
                 return 0;
         }
 
-        log_debug("Adding swap: %s", path);
+        log_info("Adding swap: %s", path);
 
         r = unit_name_from_path(path, ".swap", &name);
         if (r < 0)
@@ -414,7 +414,7 @@ static int add_esp(DissectedPartition *p) {
         assert(p);
 
         if (in_initrd()) {
-                log_debug("In initrd, ignoring the ESP.");
+                log_info("In initrd, ignoring the ESP.");
                 return 0;
         }
 
@@ -426,12 +426,12 @@ static int add_esp(DissectedPartition *p) {
         if (r < 0)
                 return log_error_errno(r, "Failed to parse fstab: %m");
         if (r > 0) {
-                log_debug("%s specified in fstab, ignoring.", esp);
+                log_info("%s specified in fstab, ignoring.", esp);
                 return 0;
         }
 
         if (path_is_busy(esp)) {
-                log_debug("%s already populated, ignoring.", esp);
+                log_info("%s already populated, ignoring.", esp);
                 return 0;
         }
 
@@ -442,18 +442,18 @@ static int add_esp(DissectedPartition *p) {
 
                 r = efi_loader_get_device_part_uuid(&loader_uuid);
                 if (r == -ENOENT) {
-                        log_debug("EFI loader partition unknown.");
+                        log_info("EFI loader partition unknown.");
                         return 0;
                 }
                 if (r < 0)
                         return log_error_errno(r, "Failed to read ESP partition UUID: %m");
 
                 if (!sd_id128_equal(p->uuid, loader_uuid)) {
-                        log_debug("Partition for %s does not appear to be the partition we are booted from.", esp);
+                        log_info("Partition for %s does not appear to be the partition we are booted from.", esp);
                         return 0;
                 }
         } else
-                log_debug("Not an EFI boot, skipping ESP check.");
+                log_info("Not an EFI boot, skipping ESP check.");
 
         return add_automount("boot",
                              p->node,
@@ -492,41 +492,41 @@ static int open_parent(dev_t devnum, int *ret) {
         if (!name)
                 name = udev_device_get_syspath(d);
         if (!name) {
-                log_debug("Device %u:%u does not have a name, ignoring.", major(devnum), minor(devnum));
+                log_info("Device %u:%u does not have a name, ignoring.", major(devnum), minor(devnum));
                 goto not_found;
         }
 
         parent = udev_device_get_parent(d);
         if (!parent) {
-                log_debug("%s: not a partitioned device, ignoring.", name);
+                log_info("%s: not a partitioned device, ignoring.", name);
                 goto not_found;
         }
 
         /* Does it have a devtype? */
         devtype = udev_device_get_devtype(parent);
         if (!devtype) {
-                log_debug("%s: parent doesn't have a device type, ignoring.", name);
+                log_info("%s: parent doesn't have a device type, ignoring.", name);
                 goto not_found;
         }
 
         /* Is this a disk or a partition? We only care for disks... */
         if (!streq(devtype, "disk")) {
-                log_debug("%s: parent isn't a raw disk, ignoring.", name);
+                log_info("%s: parent isn't a raw disk, ignoring.", name);
                 goto not_found;
         }
 
         /* Does it have a device node? */
         node = udev_device_get_devnode(parent);
         if (!node) {
-                log_debug("%s: parent device does not have device node, ignoring.", name);
+                log_info("%s: parent device does not have device node, ignoring.", name);
                 goto not_found;
         }
 
-        log_debug("%s: root device %s.", name, node);
+        log_info("%s: root device %s.", name, node);
 
         pn = udev_device_get_devnum(parent);
         if (major(pn) == 0) {
-                log_debug("%s: parent device is not a proper block device, ignoring.", name);
+                log_info("%s: parent device is not a proper block device, ignoring.", name);
                 goto not_found;
         }
 
@@ -554,7 +554,7 @@ static int enumerate_partitions(dev_t devnum) {
 
         r = dissect_image(fd, NULL, 0, DISSECT_IMAGE_GPT_ONLY, &m);
         if (r == -ENOPKG) {
-                log_debug_errno(r, "No suitable partition table found, ignoring.");
+                log_info_errno(r, "No suitable partition table found, ignoring.");
                 return 0;
         }
         if (r < 0)
@@ -643,13 +643,13 @@ static int add_root_mount(void) {
         int r;
 
         if (!is_efi_boot()) {
-                log_debug("Not a EFI boot, not creating root mount.");
+                log_info("Not a EFI boot, not creating root mount.");
                 return 0;
         }
 
         r = efi_loader_get_device_part_uuid(NULL);
         if (r == -ENOENT) {
-                log_debug("EFI loader partition unknown, exiting.");
+                log_info("EFI loader partition unknown, exiting.");
                 return 0;
         } else if (r < 0)
                 return log_error_errno(r, "Failed to read ESP partition UUID: %m");
@@ -694,7 +694,7 @@ static int add_mounts(void) {
                 if (r < 0)
                         return log_error_errno(r, "Failed to determine block device of /usr file system: %m");
                 if (r == 0) {
-                        log_debug("Neither root nor /usr file system are on a (single) block device.");
+                        log_info("Neither root nor /usr file system are on a (single) block device.");
                         return 0;
                 }
         }
@@ -721,7 +721,7 @@ int main(int argc, char *argv[]) {
         umask(0022);
 
         if (detect_container() > 0) {
-                log_debug("In a container, exiting.");
+                log_info("In a container, exiting.");
                 return EXIT_SUCCESS;
         }
 
@@ -730,7 +730,7 @@ int main(int argc, char *argv[]) {
                 log_warning_errno(r, "Failed to parse kernel command line, ignoring: %m");
 
         if (!arg_enabled) {
-                log_debug("Disabled, exiting.");
+                log_info("Disabled, exiting.");
                 return EXIT_SUCCESS;
         }
 
diff --git a/src/hwdb/hwdb.c b/src/hwdb/hwdb.c
index 4540260f9..7c92c9c6c 100644
--- a/src/hwdb/hwdb.c
+++ b/src/hwdb/hwdb.c
@@ -441,17 +441,17 @@ static int trie_store(struct trie *trie, const char *filename) {
         /* write succeeded */
         fclose(t.f);
 
-        log_debug("=== trie on-disk ===");
-        log_debug("size:             %8"PRIi64" bytes", size);
-        log_debug("header:           %8zu bytes", sizeof(struct trie_header_f));
-        log_debug("nodes:            %8"PRIu64" bytes (%8"PRIu64")",
+        log_info("=== trie on-disk ===");
+        log_info("size:             %8"PRIi64" bytes", size);
+        log_info("header:           %8zu bytes", sizeof(struct trie_header_f));
+        log_info("nodes:            %8"PRIu64" bytes (%8"PRIu64")",
                   t.nodes_count * sizeof(struct trie_node_f), t.nodes_count);
-        log_debug("child pointers:   %8"PRIu64" bytes (%8"PRIu64")",
+        log_info("child pointers:   %8"PRIu64" bytes (%8"PRIu64")",
                   t.children_count * sizeof(struct trie_child_entry_f), t.children_count);
-        log_debug("value pointers:   %8"PRIu64" bytes (%8"PRIu64")",
+        log_info("value pointers:   %8"PRIu64" bytes (%8"PRIu64")",
                   t.values_count * sizeof(struct trie_value_entry2_f), t.values_count);
-        log_debug("string store:     %8zu bytes", trie->strings->len);
-        log_debug("strings start:    %8"PRIu64, t.strings_off);
+        log_info("string store:     %8zu bytes", trie->strings->len);
+        log_info("strings start:    %8"PRIu64, t.strings_off);
         return 0;
 
  error_fclose:
@@ -659,24 +659,24 @@ static int hwdb_update(int argc, char *argv[], void *userdata) {
                 return log_error_errno(r, "Failed to enumerate hwdb files: %m");
 
         STRV_FOREACH(f, files) {
-                log_debug("Reading file \"%s\"", *f);
+                log_info("Reading file \"%s\"", *f);
                 import_file(trie, *f, file_priority++);
         }
 
         strbuf_complete(trie->strings);
 
-        log_debug("=== trie in-memory ===");
-        log_debug("nodes:            %8zu bytes (%8zu)",
+        log_info("=== trie in-memory ===");
+        log_info("nodes:            %8zu bytes (%8zu)",
                   trie->nodes_count * sizeof(struct trie_node), trie->nodes_count);
-        log_debug("children arrays:  %8zu bytes (%8zu)",
+        log_info("children arrays:  %8zu bytes (%8zu)",
                   trie->children_count * sizeof(struct trie_child_entry), trie->children_count);
-        log_debug("values arrays:    %8zu bytes (%8zu)",
+        log_info("values arrays:    %8zu bytes (%8zu)",
                   trie->values_count * sizeof(struct trie_value_entry), trie->values_count);
-        log_debug("strings:          %8zu bytes",
+        log_info("strings:          %8zu bytes",
                   trie->strings->len);
-        log_debug("strings incoming: %8zu bytes (%8zu)",
+        log_info("strings incoming: %8zu bytes (%8zu)",
                   trie->strings->in_len, trie->strings->in_count);
-        log_debug("strings dedup'ed: %8zu bytes (%8zu)",
+        log_info("strings dedup'ed: %8zu bytes (%8zu)",
                   trie->strings->dedup_len, trie->strings->dedup_count);
 
         hwdb_bin = path_join(arg_root, arg_hwdb_bin_dir, "hwdb.bin");
diff --git a/src/import/curl-util.c b/src/import/curl-util.c
index 62bbaa500..da999cc5f 100644
--- a/src/import/curl-util.c
+++ b/src/import/curl-util.c
@@ -60,7 +60,7 @@ static int curl_glue_on_io(sd_event_source *s, int fd, uint32_t revents, void *u
                 action = 0;
 
         if (curl_multi_socket_action(g->curl, translated_fd, action, &k) < 0) {
-                log_debug("Failed to propagate IO event.");
+                log_info("Failed to propagate IO event.");
                 return -EINVAL;
         }
 
@@ -170,7 +170,7 @@ static int curl_glue_on_timer(sd_event_source *s, uint64_t usec, void *userdata)
         assert(g);
 
         if (curl_multi_socket_action(g->curl, CURL_SOCKET_TIMEOUT, 0, &k) != CURLM_OK) {
-                log_debug("Failed to propagate timeout.");
+                log_info("Failed to propagate timeout.");
                 return -EINVAL;
         }
 
diff --git a/src/import/export-tar.c b/src/import/export-tar.c
index dafe3e1c8..7a802a25c 100644
--- a/src/import/export-tar.c
+++ b/src/import/export-tar.c
@@ -296,7 +296,7 @@ int tar_export_start(TarExport *e, const char *path, int fd, ImportCompressType
                 /* Let's try to make a snapshot, if we can, so that the export is atomic */
                 r = btrfs_subvol_snapshot_fd(sfd, e->temp_path, BTRFS_SNAPSHOT_READ_ONLY|BTRFS_SNAPSHOT_RECURSIVE);
                 if (r < 0) {
-                        log_debug_errno(r, "Couldn't create snapshot %s of %s, not exporting atomically: %m", e->temp_path, path);
+                        log_info_errno(r, "Couldn't create snapshot %s of %s, not exporting atomically: %m", e->temp_path, path);
                         e->temp_path = mfree(e->temp_path);
                 }
         }
diff --git a/src/import/importd.c b/src/import/importd.c
index 98ee1a2fa..e08f137f6 100644
--- a/src/import/importd.c
+++ b/src/import/importd.c
@@ -319,7 +319,7 @@ static int transfer_on_pid(sd_event_source *s, const siginfo_t *si, void *userda
                 if (si->si_status != 0)
                         log_error("Import process failed with exit code %i.", si->si_status);
                 else {
-                        log_debug("Import process succeeded.");
+                        log_info("Import process succeeded.");
                         success = true;
                 }
 
@@ -637,7 +637,7 @@ static int manager_on_notify(sd_event_source *s, int fd, uint32_t revents, void
 
         t->progress_percent = percent;
 
-        log_debug("Got percentage from client: %u%%", percent);
+        log_info("Got percentage from client: %u%%", percent);
         return 0;
 }
 
diff --git a/src/import/pull-job.c b/src/import/pull-job.c
index 2b7176679..a08d1b423 100644
--- a/src/import/pull-job.c
+++ b/src/import/pull-job.c
@@ -187,7 +187,7 @@ void pull_job_curl_on_finished(CurlGlue *g, CURL *curl, CURLcode result) {
                         goto finish;
                 }
 
-                log_debug("SHA256 of %s is %s.", j->url, j->checksum);
+                log_info("SHA256 of %s is %s.", j->url, j->checksum);
         }
 
         if (j->disk_fd >= 0 && j->allow_sparse) {
@@ -358,7 +358,7 @@ static int pull_job_detect_compression(PullJob *j) {
         if (r == 0)
                 return 0;
 
-        log_debug("Stream is compressed: %s", import_compress_type_to_string(j->compress.type));
+        log_info("Stream is compressed: %s", import_compress_type_to_string(j->compress.type));
 
         r = pull_job_open_disk(j);
         if (r < 0)
diff --git a/src/import/pull-raw.c b/src/import/pull-raw.c
index 880cb84ba..6f0340c29 100644
--- a/src/import/pull-raw.c
+++ b/src/import/pull-raw.c
@@ -230,7 +230,7 @@ static void raw_pull_report_progress(RawPull *i, RawProgress p) {
         }
 
         sd_notifyf(false, "X_IMPORT_PROGRESS=%u", percent);
-        log_debug("Combined progress %u%%", percent);
+        log_info("Combined progress %u%%", percent);
 }
 
 static int raw_pull_maybe_convert_qcow2(RawPull *i) {
@@ -318,7 +318,7 @@ static int raw_pull_copy_auxiliary_file(
         if (r == -EEXIST)
                 log_warning_errno(r, "File %s already exists, not replacing.", local);
         else if (r == -ENOENT)
-                log_debug_errno(r, "Skipping creation of auxiliary file, since none was found.");
+                log_info_errno(r, "Skipping creation of auxiliary file, since none was found.");
         else if (r < 0)
                 log_warning_errno(r, "Failed to copy file %s, ignoring: %m", local);
         else
diff --git a/src/import/pull-tar.c b/src/import/pull-tar.c
index 6ee63bdad..90ef5747e 100644
--- a/src/import/pull-tar.c
+++ b/src/import/pull-tar.c
@@ -214,7 +214,7 @@ static void tar_pull_report_progress(TarPull *i, TarProgress p) {
         }
 
         sd_notifyf(false, "X_IMPORT_PROGRESS=%u", percent);
-        log_debug("Combined progress %u%%", percent);
+        log_info("Combined progress %u%%", percent);
 }
 
 static int tar_pull_determine_path(TarPull *i, const char *suffix, char **field) {
@@ -262,7 +262,7 @@ static int tar_pull_make_local_copy(TarPull *i) {
                 if (r == -EEXIST)
                         log_warning_errno(r, "Settings file %s already exists, not replacing.", local_settings);
                 else if (r == -ENOENT)
-                        log_debug_errno(r, "Skipping creation of settings file, since none was found.");
+                        log_info_errno(r, "Skipping creation of settings file, since none was found.");
                 else if (r < 0)
                         log_warning_errno(r, "Failed to copy settings files %s, ignoring: %m", local_settings);
                 else
diff --git a/src/initctl/initctl.c b/src/initctl/initctl.c
index c1af13d15..19a6712cf 100644
--- a/src/initctl/initctl.c
+++ b/src/initctl/initctl.c
@@ -119,7 +119,7 @@ static void change_runlevel(Server *s, int runlevel) {
         else
                 mode = "replace-irreversibly";
 
-        log_debug("Running request %s/start/%s", target, mode);
+        log_info("Running request %s/start/%s", target, mode);
 
         r = sd_bus_call_method(
                         s->bus,
@@ -390,7 +390,7 @@ int main(int argc, char *argv[]) {
         if (server_init(&server, (unsigned) n) < 0)
                 return EXIT_FAILURE;
 
-        log_debug("systemd-initctl running as pid "PID_FMT, getpid_cached());
+        log_info("systemd-initctl running as pid "PID_FMT, getpid_cached());
 
         sd_notify(false,
                   "READY=1\n"
@@ -417,7 +417,7 @@ int main(int argc, char *argv[]) {
 
         r = EXIT_SUCCESS;
 
-        log_debug("systemd-initctl stopped as pid "PID_FMT, getpid_cached());
+        log_info("systemd-initctl stopped as pid "PID_FMT, getpid_cached());
 
 fail:
         sd_notify(false,
diff --git a/src/journal-remote/journal-remote-parse.c b/src/journal-remote/journal-remote-parse.c
index 2c4e28ad7..c241d9de8 100644
--- a/src/journal-remote/journal-remote-parse.c
+++ b/src/journal-remote/journal-remote-parse.c
@@ -31,7 +31,7 @@ void source_free(RemoteSource *source) {
 
         journal_importer_cleanup(&source->importer);
 
-        log_debug("Writer ref count %i", source->writer->n_ref);
+        log_info("Writer ref count %i", source->writer->n_ref);
         writer_unref(source->writer);
 
         sd_event_source_unref(source->event);
@@ -48,7 +48,7 @@ RemoteSource* source_new(int fd, bool passive_fd, char *name, Writer *writer) {
 
         RemoteSource *source;
 
-        log_debug("Creating source for %sfd:%d (%s)",
+        log_info("Creating source for %sfd:%d (%s)",
                   passive_fd ? "passive " : "", fd, name);
 
         assert(fd >= 0);
diff --git a/src/journal-remote/journal-remote-write.c b/src/journal-remote/journal-remote-write.c
index c5c6abbd5..03fcee229 100644
--- a/src/journal-remote/journal-remote-write.c
+++ b/src/journal-remote/journal-remote-write.c
@@ -57,7 +57,7 @@ Writer* writer_free(Writer *w) {
                 return NULL;
 
         if (w->journal) {
-                log_debug("Closing journal file %s.", w->journal->path);
+                log_info("Closing journal file %s.", w->journal->path);
                 journal_file_close(w->journal);
         }
 
@@ -113,14 +113,14 @@ int writer_write(Writer *w,
                 return 1;
         }
 
-        log_debug_errno(r, "%s: Write failed, rotating: %m", w->journal->path);
+        log_info_errno(r, "%s: Write failed, rotating: %m", w->journal->path);
         r = do_rotate(&w->journal, compress, seal);
         if (r < 0)
                 return r;
         else
-                log_debug("%s: Successfully rotated journal", w->journal->path);
+                log_info("%s: Successfully rotated journal", w->journal->path);
 
-        log_debug("Retrying write.");
+        log_info("Retrying write.");
         r = journal_file_append_entry(w->journal, ts, iovw->iovec, iovw->count,
                                       &w->seqnum, NULL, NULL);
         if (r < 0)
diff --git a/src/journal-remote/journal-remote.c b/src/journal-remote/journal-remote.c
index 66d5369a5..b7f576c9a 100644
--- a/src/journal-remote/journal-remote.c
+++ b/src/journal-remote/journal-remote.c
@@ -196,7 +196,7 @@ static int open_output(Writer *w, const char* host) {
                 log_error_errno(r, "Failed to open output journal %s: %m",
                                 output);
         else
-                log_debug("Opened output file %s", w->journal->path);
+                log_info("Opened output file %s", w->journal->path);
         return r;
 }
 
@@ -379,7 +379,7 @@ static int add_source(RemoteServer *s, int fd, char* name, bool own_name) {
                 if (r == 0)
                         sd_event_source_set_enabled(source->buffer_event, SD_EVENT_OFF);
         } else if (r == -EPERM) {
-                log_debug("Falling back to sd_event_add_defer for fd:%d (%s)", fd, name);
+                log_info("Falling back to sd_event_add_defer for fd:%d (%s)", fd, name);
                 r = sd_event_add_defer(s->events, &source->event,
                                        dispatch_blocking_source_event, source);
                 if (r == 0)
@@ -462,7 +462,7 @@ static int request_meta(void **connection_cls, int fd, char *hostname) {
                 return log_oom();
         }
 
-        log_debug("Added RemoteSource as connection metadata %p", source);
+        log_info("Added RemoteSource as connection metadata %p", source);
 
         *connection_cls = source;
         return 0;
@@ -478,7 +478,7 @@ static void request_meta_free(void *cls,
         s = *connection_cls;
 
         if (s) {
-                log_debug("Cleaning up connection metadata %p", s);
+                log_info("Cleaning up connection metadata %p", s);
                 source_free(s);
                 *connection_cls = NULL;
         }
@@ -699,7 +699,7 @@ static int setup_microhttpd_server(RemoteServer *s,
                 goto error;
         }
 
-        log_debug("Started MHD %s daemon on fd:%d (wrapper @ %p)",
+        log_info("Started MHD %s daemon on fd:%d (wrapper @ %p)",
                   key ? "HTTPS" : "HTTP", fd, d);
 
 
@@ -887,7 +887,7 @@ static int remoteserver_init(RemoteServer *s,
         if (n < 0)
                 return log_error_errno(n, "Failed to read listening file descriptors from environment: %m");
         else
-                log_debug("Received %d descriptors", n);
+                log_info("Received %d descriptors", n);
 
         if (MAX(http_socket, https_socket) >= SD_LISTEN_FDS_START + n) {
                 log_error("Received fewer sockets than expected");
@@ -896,7 +896,7 @@ static int remoteserver_init(RemoteServer *s,
 
         for (fd = SD_LISTEN_FDS_START; fd < SD_LISTEN_FDS_START + n; fd++) {
                 if (sd_is_socket(fd, AF_UNSPEC, 0, true)) {
-                        log_debug("Received a listening socket (fd:%d)", fd);
+                        log_info("Received a listening socket (fd:%d)", fd);
 
                         if (fd == http_socket)
                                 r = setup_microhttpd_server(s, fd, NULL, NULL, NULL);
@@ -911,7 +911,7 @@ static int remoteserver_init(RemoteServer *s,
                         if (r < 0)
                                 return log_error_errno(r, "Failed to retrieve remote name: %m");
 
-                        log_debug("Received a connection socket (fd:%d) from %s", fd, hostname);
+                        log_info("Received a connection socket (fd:%d) from %s", fd, hostname);
 
                         r = add_source(s, fd, hostname, true);
                 } else {
@@ -971,7 +971,7 @@ static int remoteserver_init(RemoteServer *s,
         }
 
         if (arg_listen_raw) {
-                log_debug("Listening on a socket...");
+                log_info("Listening on a socket...");
                 r = setup_raw_socket(s, arg_listen_raw);
                 if (r < 0)
                         return r;
@@ -993,12 +993,12 @@ static int remoteserver_init(RemoteServer *s,
                 const char *output_name;
 
                 if (streq(*file, "-")) {
-                        log_debug("Using standard input as source.");
+                        log_info("Using standard input as source.");
 
                         fd = STDIN_FILENO;
                         output_name = "stdin";
                 } else {
-                        log_debug("Reading file %s...", *file);
+                        log_info("Reading file %s...", *file);
 
                         fd = open(*file, O_RDONLY|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);
                         if (fd < 0)
@@ -1080,14 +1080,14 @@ static int handle_raw_source(sd_event_source *event,
         if (journal_importer_eof(&source->importer)) {
                 size_t remaining;
 
-                log_debug("EOF reached with source %s (fd=%d)",
+                log_info("EOF reached with source %s (fd=%d)",
                           source->importer.name, source->importer.fd);
 
                 remaining = journal_importer_bytes_remaining(&source->importer);
                 if (remaining > 0)
                         log_notice("Premature EOF. %zu bytes lost.", remaining);
                 remove_source(s, source->importer.fd);
-                log_debug("%zu active sources remaining", s->active);
+                log_info("%zu active sources remaining", s->active);
                 return 0;
         } else if (r == -E2BIG) {
                 log_notice_errno(E2BIG, "Entry too big, skipped");
@@ -1095,7 +1095,7 @@ static int handle_raw_source(sd_event_source *event,
         } else if (r == -EAGAIN) {
                 return 0;
         } else if (r < 0) {
-                log_debug_errno(r, "Closing connection: %m");
+                log_info_errno(r, "Closing connection: %m");
                 remove_source(server, fd);
                 return 0;
         } else
@@ -1150,7 +1150,7 @@ static int accept_connection(const char* type, int fd,
                              SocketAddress *addr, char **hostname) {
         int fd2, r;
 
-        log_debug("Accepting new %s connection on fd:%d", type, fd);
+        log_info("Accepting new %s connection on fd:%d", type, fd);
         fd2 = accept4(fd, &addr->sockaddr.sa, &addr->size, SOCK_NONBLOCK|SOCK_CLOEXEC);
         if (fd2 < 0)
                 return log_error_errno(errno, "accept() on fd:%d failed: %m", fd);
@@ -1175,7 +1175,7 @@ static int accept_connection(const char* type, int fd,
                         return r;
                 }
 
-                log_debug("Accepted %s %s connection from %s",
+                log_info("Accepted %s %s connection from %s",
                           type,
                           socket_address_family(addr) == AF_INET ? "IP" : "IPv6",
                           a);
@@ -1543,7 +1543,7 @@ static int parse_argv(int argc, char *argv[]) {
                 return -EINVAL;
         }
 
-        log_debug("Full config: SplitMode=%s Key=%s Cert=%s Trust=%s",
+        log_info("Full config: SplitMode=%s Key=%s Cert=%s Trust=%s",
                   journal_write_split_mode_to_string(arg_split_mode),
                   strna(arg_key),
                   strna(arg_cert),
@@ -1611,9 +1611,9 @@ int main(int argc, char **argv) {
         if (r < 0)
                 log_error_errno(r, "Failed to enable watchdog: %m");
         else
-                log_debug("Watchdog is %sd.", enable_disable(r > 0));
+                log_info("Watchdog is %sd.", enable_disable(r > 0));
 
-        log_debug("%s running as pid "PID_FMT,
+        log_info("%s running as pid "PID_FMT,
                   program_invocation_short_name, getpid_cached());
         sd_notify(false,
                   "READY=1\n"
diff --git a/src/journal-remote/journal-upload-journal.c b/src/journal-remote/journal-upload-journal.c
index 6c214d27f..98fac5a68 100644
--- a/src/journal-remote/journal-upload-journal.c
+++ b/src/journal-remote/journal-upload-journal.c
@@ -254,7 +254,7 @@ static inline void check_update_watchdog(Uploader *u) {
         after = now(CLOCK_MONOTONIC);
         elapsed_time = usec_sub_unsigned(after, u->watchdog_timestamp);
         if (elapsed_time > u->watchdog_usec / 2) {
-                log_debug("Update watchdog timer");
+                log_info("Update watchdog timer");
                 sd_notify(false, "WATCHDOG=1");
                 u->watchdog_timestamp = after;
         }
@@ -282,7 +282,7 @@ static size_t journal_input_callback(void *buf, size_t size, size_t nmemb, void
                                 return CURL_READFUNC_ABORT;
                         } else if (r == 0) {
                                 if (u->input_event)
-                                        log_debug("No more entries, waiting for journal.");
+                                        log_info("No more entries, waiting for journal.");
                                 else {
                                         log_info("No more entries, closing journal.");
                                         close_journal_input(u);
@@ -308,7 +308,7 @@ static size_t journal_input_callback(void *buf, size_t size, size_t nmemb, void
                         /* This means that all available space was used up */
                         break;
 
-                log_debug("Entry %zu (%s) has been uploaded.",
+                log_info("Entry %zu (%s) has been uploaded.",
                           u->entries_sent, u->current_cursor);
         }
 
@@ -319,7 +319,7 @@ void close_journal_input(Uploader *u) {
         assert(u);
 
         if (u->journal) {
-                log_debug("Closing journal input.");
+                log_info("Closing journal input.");
 
                 sd_journal_close(u->journal);
                 u->journal = NULL;
@@ -373,7 +373,7 @@ static int dispatch_journal_input(sd_event_source *event,
         if (u->uploading)
                 return 0;
 
-        log_debug("Detected journal input, checking for new data.");
+        log_info("Detected journal input, checking for new data.");
         return check_journal_input(u);
 }
 
@@ -407,10 +407,10 @@ int open_journal_for_upload(Uploader *u,
                 if (r < 0)
                         return log_error_errno(r, "Failed to register input event: %m");
 
-                log_debug("Listening for journal events on fd:%d, timeout %d",
+                log_info("Listening for journal events on fd:%d, timeout %d",
                           fd, u->timeout == (uint64_t) -1 ? -1 : (int) u->timeout);
         } else
-                log_debug("Not listening for journal events.");
+                log_info("Not listening for journal events.");
 
         if (cursor) {
                 r = sd_journal_seek_cursor(j, cursor);
diff --git a/src/journal-remote/journal-upload.c b/src/journal-remote/journal-upload.c
index 0b74ca98a..23c2bb845 100644
--- a/src/journal-remote/journal-upload.c
+++ b/src/journal-remote/journal-upload.c
@@ -87,7 +87,7 @@ static size_t output_callback(char *buf,
 
         assert(u);
 
-        log_debug("The server answers (%zu bytes): %.*s",
+        log_info("The server answers (%zu bytes): %.*s",
                   size*nmemb, (int)(size*nmemb), buf);
 
         if (nmemb && !u->answer) {
@@ -170,12 +170,12 @@ static int load_cursor_state(Uploader *u) {
                            NULL);
 
         if (r == -ENOENT)
-                log_debug("State file %s is not present.", u->state_file);
+                log_info("State file %s is not present.", u->state_file);
         else if (r < 0)
                 return log_error_errno(r, "Failed to read state file %s: %m",
                                        u->state_file);
         else
-                log_debug("Last cursor was %s", u->last_cursor);
+                log_info("Last cursor was %s", u->last_cursor);
 
         return 0;
 }
@@ -309,14 +309,14 @@ static size_t fd_input_callback(void *buf, size_t size, size_t nmemb, void *user
                 return 0;
 
         r = read(u->input, buf, size * nmemb);
-        log_debug("%s: allowed %zu, read %zd", __func__, size*nmemb, r);
+        log_info("%s: allowed %zu, read %zd", __func__, size*nmemb, r);
 
         if (r > 0)
                 return r;
 
         u->uploading = false;
         if (r == 0) {
-                log_debug("Reached EOF");
+                log_info("Reached EOF");
                 close_fd_input(u);
                 return 0;
         } else {
@@ -344,7 +344,7 @@ static int dispatch_fd_input(sd_event_source *event,
         assert(fd >= 0);
 
         if (revents & EPOLLHUP) {
-                log_debug("Received HUP");
+                log_info("Received HUP");
                 close_fd_input(u);
                 return 0;
         }
@@ -526,7 +526,7 @@ static int perform_upload(Uploader *u) {
                           u->url, status, strna(u->answer));
                 return -EIO;
         } else
-                log_debug("Upload finished successfully with code %ld: %s",
+                log_info("Upload finished successfully with code %ld: %s",
                           status, strna(u->answer));
 
         free_and_replace(u->last_cursor, u->current_cursor);
@@ -810,7 +810,7 @@ int main(int argc, char **argv) {
         if (r < 0)
                 goto cleanup;
 
-        log_debug("%s running as pid "PID_FMT,
+        log_info("%s running as pid "PID_FMT,
                   program_invocation_short_name, getpid_cached());
 
         use_journal = optind >= argc;
@@ -847,7 +847,7 @@ int main(int argc, char **argv) {
                         if (optind >= argc)
                                 break;
 
-                        log_debug("Using %s as input.", argv[optind]);
+                        log_info("Using %s as input.", argv[optind]);
                         r = open_file_for_upload(&u, argv[optind++]);
                 }
                 if (r < 0)
diff --git a/src/journal-remote/microhttpd-util.c b/src/journal-remote/microhttpd-util.c
index 2466c4f2b..2b9c3a222 100644
--- a/src/journal-remote/microhttpd-util.c
+++ b/src/journal-remote/microhttpd-util.c
@@ -61,7 +61,7 @@ static int mhd_respond_internal(struct MHD_Connection *connection,
         if (!response)
                 return MHD_NO;
 
-        log_debug("Queueing response %u: %s", code, buffer);
+        log_info("Queueing response %u: %s", code, buffer);
         MHD_add_response_header(response, "Content-Type", "text/plain");
         r = MHD_queue_response(connection, code, response);
         MHD_destroy_response(response);
@@ -142,7 +142,7 @@ static void log_func_gnutls(int level, const char *message) {
                 if (gnutls_log_map[level].enabled)
                         log_internal(gnutls_log_map[level].level, 0, NULL, 0, NULL, "gnutls %d/%s: %s", level, gnutls_log_map[level].names[1], message);
         } else {
-                log_debug("Received GNUTLS message with unknown level %d.", level);
+                log_info("Received GNUTLS message with unknown level %d.", level);
                 log_internal(LOG_DEBUG, 0, NULL, 0, NULL, "gnutls: %s", message);
         }
 }
@@ -152,7 +152,7 @@ static void log_reset_gnutls_level(void) {
 
         for (i = ELEMENTSOF(gnutls_log_map) - 1; i >= 0; i--)
                 if (gnutls_log_map[i].enabled) {
-                        log_debug("Setting gnutls log level to %d", i);
+                        log_info("Setting gnutls log level to %d", i);
                         gnutls_global_set_log_level(i);
                         break;
                 }
@@ -210,7 +210,7 @@ static int verify_cert_authorized(gnutls_session_t session) {
         if (r < 0)
                 return log_error_errno(r, "gnutls_certificate_verification_status_print failed: %m");
 
-        log_debug("Certificate status: %s", out.data);
+        log_info("Certificate status: %s", out.data);
         gnutls_free(out.data);
 
         return status == 0 ? 0 : -EPERM;
@@ -312,7 +312,7 @@ int check_permissions(struct MHD_Connection *connection, int *code, char **hostn
                 return -EPERM;
         }
 
-        log_debug("Connection from %s", buf);
+        log_info("Connection from %s", buf);
 
         if (hostname) {
                 *hostname = buf;
diff --git a/src/journal/catalog.c b/src/journal/catalog.c
index 6775535b1..04898786a 100644
--- a/src/journal/catalog.c
+++ b/src/journal/catalog.c
@@ -283,7 +283,7 @@ int catalog_import_file(Hashmap *h, const char *path) {
         if (r < 0)
                 log_error_errno(r, "Failed to determine language for file %s: %m", path);
         if (r == 1)
-                log_debug("File %s has language %s.", path, deflang);
+                log_info("File %s has language %s.", path, deflang);
 
         for (;;) {
                 char line[LINE_MAX];
@@ -487,7 +487,7 @@ int catalog_update(const char* database, const char* root, const char* const* di
         }
 
         STRV_FOREACH(f, files) {
-                log_debug("Reading file '%s'", *f);
+                log_info("Reading file '%s'", *f);
                 r = catalog_import_file(h, *f);
                 if (r < 0) {
                         log_error_errno(r, "Failed to import file '%s': %m", *f);
@@ -499,7 +499,7 @@ int catalog_update(const char* database, const char* root, const char* const* di
                 log_info("No items in catalog.");
                 goto finish;
         } else
-                log_debug("Found %u items in catalog.", hashmap_size(h));
+                log_info("Found %u items in catalog.", hashmap_size(h));
 
         items = new(CatalogItem, hashmap_size(h));
         if (!items) {
@@ -509,7 +509,7 @@ int catalog_update(const char* database, const char* root, const char* const* di
 
         n = 0;
         HASHMAP_FOREACH_KEY(payload, i, h, j) {
-                log_debug("Found " SD_ID128_FORMAT_STR ", language %s",
+                log_info("Found " SD_ID128_FORMAT_STR ", language %s",
                           SD_ID128_FORMAT_VAL(i->id),
                           isempty(i->language) ? "C" : i->language);
 
@@ -532,7 +532,7 @@ int catalog_update(const char* database, const char* root, const char* const* di
                 r = log_error_errno(sz, "Failed to write %s: %m", database);
         else {
                 r = 0;
-                log_debug("%s: wrote %u items, with %zu bytes of strings, %"PRIi64" total size.",
+                log_info("%s: wrote %u items, with %zu bytes of strings, %"PRIi64" total size.",
                           database, n, sb->len, sz);
         }
 
diff --git a/src/journal/compress.c b/src/journal/compress.c
index 92eb3874f..ceea43f06 100644
--- a/src/journal/compress.c
+++ b/src/journal/compress.c
@@ -433,7 +433,7 @@ int compress_stream_xz(int fdf, int fdt, uint64_t max_bytes) {
                                 return k;
 
                         if (ret == LZMA_STREAM_END) {
-                                log_debug("XZ compression finished (%"PRIu64" -> %"PRIu64" bytes, %.1f%%)",
+                                log_info("XZ compression finished (%"PRIu64" -> %"PRIu64" bytes, %.1f%%)",
                                           s.total_in, s.total_out,
                                           (double) s.total_out / s.total_in * 100);
 
@@ -470,7 +470,7 @@ int compress_stream_lz4(int fdf, int fdt, uint64_t max_bytes) {
                 return -ENOMEM;
 
         if (fstat(fdf, &st) < 0)
-                return log_debug_errno(errno, "fstat() failed: %m");
+                return log_info_errno(errno, "fstat() failed: %m");
 
         frame_size = LZ4F_compressBound(LZ4_BUFSIZE, &preferences);
         size =  frame_size + 64*1024; /* add some space for header and trailer */
@@ -486,7 +486,7 @@ int compress_stream_lz4(int fdf, int fdt, uint64_t max_bytes) {
         if (src == MAP_FAILED)
                 return -errno;
 
-        log_debug("Buffer size is %zu bytes, header size %zu bytes.", size, n);
+        log_info("Buffer size is %zu bytes, header size %zu bytes.", size, n);
 
         while (total_in < (size_t) st.st_size) {
                 ssize_t k;
@@ -504,7 +504,7 @@ int compress_stream_lz4(int fdf, int fdt, uint64_t max_bytes) {
                 total_out += n;
 
                 if (max_bytes != (uint64_t) -1 && total_out > (size_t) max_bytes) {
-                        log_debug("Compressed stream longer than %"PRIu64" bytes", max_bytes);
+                        log_info("Compressed stream longer than %"PRIu64" bytes", max_bytes);
                         return -EFBIG;
                 }
 
@@ -530,7 +530,7 @@ int compress_stream_lz4(int fdf, int fdt, uint64_t max_bytes) {
         if (r < 0)
                 goto cleanup;
 
-        log_debug("LZ4 compression finished (%zu -> %zu bytes, %.1f%%)",
+        log_info("LZ4 compression finished (%zu -> %zu bytes, %.1f%%)",
                   total_in, total_out,
                   (double) total_out / total_in * 100);
  cleanup:
@@ -555,7 +555,7 @@ int decompress_stream_xz(int fdf, int fdt, uint64_t max_bytes) {
 
         ret = lzma_stream_decoder(&s, UINT64_MAX, 0);
         if (ret != LZMA_OK) {
-                log_debug("Failed to initialize XZ decoder: code %u", ret);
+                log_info("Failed to initialize XZ decoder: code %u", ret);
                 return -ENOMEM;
         }
 
@@ -581,7 +581,7 @@ int decompress_stream_xz(int fdf, int fdt, uint64_t max_bytes) {
 
                 ret = lzma_code(&s, action);
                 if (!IN_SET(ret, LZMA_OK, LZMA_STREAM_END)) {
-                        log_debug("Decompression failed: code %u", ret);
+                        log_info("Decompression failed: code %u", ret);
                         return -EBADMSG;
                 }
 
@@ -602,7 +602,7 @@ int decompress_stream_xz(int fdf, int fdt, uint64_t max_bytes) {
                                 return k;
 
                         if (ret == LZMA_STREAM_END) {
-                                log_debug("XZ decompression finished (%"PRIu64" -> %"PRIu64" bytes, %.1f%%)",
+                                log_info("XZ decompression finished (%"PRIu64" -> %"PRIu64" bytes, %.1f%%)",
                                           s.total_in, s.total_out,
                                           (double) s.total_out / s.total_in * 100);
 
@@ -611,7 +611,7 @@ int decompress_stream_xz(int fdf, int fdt, uint64_t max_bytes) {
                 }
         }
 #else
-        log_debug("Cannot decompress file. Compiled without XZ support.");
+        log_info("Cannot decompress file. Compiled without XZ support.");
         return -EPROTONOSUPPORT;
 #endif
 }
@@ -631,7 +631,7 @@ int decompress_stream_lz4(int in, int out, uint64_t max_bytes) {
                 return -ENOMEM;
 
         if (fstat(in, &st) < 0)
-                return log_debug_errno(errno, "fstat() failed: %m");
+                return log_info_errno(errno, "fstat() failed: %m");
 
         buf = malloc(LZ4_BUFSIZE);
         if (!buf)
@@ -655,7 +655,7 @@ int decompress_stream_lz4(int in, int out, uint64_t max_bytes) {
                 total_out += produced;
 
                 if (max_bytes != (uint64_t) -1 && total_out > (size_t) max_bytes) {
-                        log_debug("Decompressed stream longer than %"PRIu64" bytes", max_bytes);
+                        log_info("Decompressed stream longer than %"PRIu64" bytes", max_bytes);
                         r = -EFBIG;
                         goto cleanup;
                 }
@@ -665,14 +665,14 @@ int decompress_stream_lz4(int in, int out, uint64_t max_bytes) {
                         goto cleanup;
         }
 
-        log_debug("LZ4 decompression finished (%zu -> %zu bytes, %.1f%%)",
+        log_info("LZ4 decompression finished (%zu -> %zu bytes, %.1f%%)",
                   total_in, total_out,
                   total_in > 0 ? (double) total_out / total_in * 100 : 0.0);
  cleanup:
         munmap(src, st.st_size);
         return r;
 #else
-        log_debug("Cannot decompress file. Compiled without LZ4 support.");
+        log_info("Cannot decompress file. Compiled without LZ4 support.");
         return -EPROTONOSUPPORT;
 #endif
 }
diff --git a/src/journal/journal-authenticate.c b/src/journal/journal-authenticate.c
index cff64749a..8d283b723 100644
--- a/src/journal/journal-authenticate.c
+++ b/src/journal/journal-authenticate.c
@@ -62,7 +62,7 @@ int journal_file_append_tag(JournalFile *f) {
         o->tag.seqnum = htole64(journal_file_tag_seqnum(f));
         o->tag.epoch = htole64(FSPRG_GetEpoch(f->fsprg_state));
 
-        log_debug("Writing tag %"PRIu64" for epoch %"PRIu64"",
+        log_info("Writing tag %"PRIu64" for epoch %"PRIu64"",
                   le64toh(o->tag.seqnum),
                   FSPRG_GetEpoch(f->fsprg_state));
 
@@ -154,7 +154,7 @@ int journal_file_fsprg_evolve(JournalFile *f, uint64_t realtime) {
 
         epoch = FSPRG_GetEpoch(f->fsprg_state);
         if (epoch < goal)
-                log_debug("Evolving FSPRG key from epoch %"PRIu64" to %"PRIu64".", epoch, goal);
+                log_info("Evolving FSPRG key from epoch %"PRIu64" to %"PRIu64".", epoch, goal);
 
         for (;;) {
                 if (epoch > goal)
@@ -197,7 +197,7 @@ int journal_file_fsprg_seek(JournalFile *f, uint64_t goal) {
                         return -ENOMEM;
         }
 
-        log_debug("Seeking FSPRG key to %"PRIu64".", goal);
+        log_info("Seeking FSPRG key to %"PRIu64".", goal);
 
         msk = alloca(FSPRG_mskinbytes(FSPRG_RECOMMENDED_SECPAR));
         FSPRG_GenMK(msk, NULL, f->fsprg_seed, f->fsprg_seed_size, FSPRG_RECOMMENDED_SECPAR);
@@ -448,7 +448,7 @@ int journal_file_append_first_tag(JournalFile *f) {
         if (!f->seal)
                 return 0;
 
-        log_debug("Calculating first tag...");
+        log_info("Calculating first tag...");
 
         r = journal_file_hmac_put_header(f);
         if (r < 0)
diff --git a/src/journal/journal-file.c b/src/journal/journal-file.c
index 3353b3a0d..f0b319ecd 100644
--- a/src/journal/journal-file.c
+++ b/src/journal/journal-file.c
@@ -138,7 +138,7 @@ static void journal_file_set_offline_internal(JournalFile *f) {
                         return;
 
                 case OFFLINE_JOINED:
-                        log_debug("OFFLINE_JOINED unexpected offline state for journal_file_set_offline_internal()");
+                        log_info("OFFLINE_JOINED unexpected offline state for journal_file_set_offline_internal()");
                         return;
                 }
         }
@@ -527,7 +527,7 @@ static bool warn_wrong_flags(const JournalFile *f, bool compatible) {
 
         if (flags & ~supported) {
                 if (flags & ~any)
-                        log_debug("Journal file %s has unknown %s flags 0x%"PRIx32,
+                        log_info("Journal file %s has unknown %s flags 0x%"PRIx32,
                                   f->path, type, flags & ~any);
                 flags = (flags & any) & ~supported;
                 if (flags) {
@@ -545,7 +545,7 @@ static bool warn_wrong_flags(const JournalFile *f, bool compatible) {
                         assert(n < ELEMENTSOF(strv));
 
                         t = strv_join((char**) strv, ", ");
-                        log_debug("Journal file %s uses %s %s %s disabled at compilation time.",
+                        log_info("Journal file %s uses %s %s %s disabled at compilation time.",
                                   f->path, type, n > 1 ? "flags" : "flag", strnull(t));
                 }
                 return true;
@@ -615,10 +615,10 @@ static int journal_file_verify_header(JournalFile *f) {
                 if (state == STATE_ARCHIVED)
                         return -ESHUTDOWN; /* Already archived */
                 else if (state == STATE_ONLINE) {
-                        log_debug("Journal file %s is already online. Assuming unclean closing.", f->path);
+                        log_info("Journal file %s is already online. Assuming unclean closing.", f->path);
                         return -EBUSY;
                 } else if (state != STATE_OFFLINE) {
-                        log_debug("Journal file %s has unknown state %i.", f->path, state);
+                        log_info("Journal file %s has unknown state %i.", f->path, state);
                         return -EBUSY;
                 }
 
@@ -629,7 +629,7 @@ static int journal_file_verify_header(JournalFile *f) {
                  * be strictly ordered in the entries in the file anymore, and we can't have that since it breaks
                  * bisection. */
                 if (le64toh(f->header->tail_entry_realtime) > now(CLOCK_REALTIME)) {
-                        log_debug("Journal file %s is from the future, refusing to append new data to it that'd be older.", f->path);
+                        log_info("Journal file %s is from the future, refusing to append new data to it that'd be older.", f->path);
                         return -ETXTBSY;
                 }
         }
@@ -789,13 +789,13 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
 
         case OBJECT_DATA: {
                 if ((le64toh(o->data.entry_offset) == 0) ^ (le64toh(o->data.n_entries) == 0)) {
-                        log_debug("Bad n_entries: %"PRIu64": %"PRIu64,
+                        log_info("Bad n_entries: %"PRIu64": %"PRIu64,
                                         le64toh(o->data.n_entries), offset);
                         return -EBADMSG;
                 }
 
                 if (le64toh(o->object.size) - offsetof(DataObject, payload) <= 0) {
-                        log_debug("Bad object size (<= %zu): %"PRIu64": %"PRIu64,
+                        log_info("Bad object size (<= %zu): %"PRIu64": %"PRIu64,
                               offsetof(DataObject, payload),
                               le64toh(o->object.size),
                               offset);
@@ -806,7 +806,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
                     !VALID64(le64toh(o->data.next_field_offset)) ||
                     !VALID64(le64toh(o->data.entry_offset)) ||
                     !VALID64(le64toh(o->data.entry_array_offset))) {
-                        log_debug("Invalid offset, next_hash_offset="OFSfmt", next_field_offset="OFSfmt
+                        log_info("Invalid offset, next_hash_offset="OFSfmt", next_field_offset="OFSfmt
                                 ", entry_offset="OFSfmt", entry_array_offset="OFSfmt": %"PRIu64,
                               le64toh(o->data.next_hash_offset),
                               le64toh(o->data.next_field_offset),
@@ -821,7 +821,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
 
         case OBJECT_FIELD:
                 if (le64toh(o->object.size) - offsetof(FieldObject, payload) <= 0) {
-                        log_debug(
+                        log_info(
                               "Bad field size (<= %zu): %"PRIu64": %"PRIu64,
                               offsetof(FieldObject, payload),
                               le64toh(o->object.size),
@@ -831,7 +831,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
 
                 if (!VALID64(le64toh(o->field.next_hash_offset)) ||
                     !VALID64(le64toh(o->field.head_data_offset))) {
-                        log_debug(
+                        log_info(
                               "Invalid offset, next_hash_offset="OFSfmt
                               ", head_data_offset="OFSfmt": %"PRIu64,
                               le64toh(o->field.next_hash_offset),
@@ -843,7 +843,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
 
         case OBJECT_ENTRY:
                 if ((le64toh(o->object.size) - offsetof(EntryObject, items)) % sizeof(EntryItem) != 0) {
-                        log_debug(
+                        log_info(
                               "Bad entry size (<= %zu): %"PRIu64": %"PRIu64,
                               offsetof(EntryObject, items),
                               le64toh(o->object.size),
@@ -852,7 +852,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
                 }
 
                 if ((le64toh(o->object.size) - offsetof(EntryObject, items)) / sizeof(EntryItem) <= 0) {
-                        log_debug(
+                        log_info(
                               "Invalid number items in entry: %"PRIu64": %"PRIu64,
                               (le64toh(o->object.size) - offsetof(EntryObject, items)) / sizeof(EntryItem),
                               offset);
@@ -860,7 +860,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
                 }
 
                 if (le64toh(o->entry.seqnum) <= 0) {
-                        log_debug(
+                        log_info(
                               "Invalid entry seqnum: %"PRIx64": %"PRIu64,
                               le64toh(o->entry.seqnum),
                               offset);
@@ -868,7 +868,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
                 }
 
                 if (!VALID_REALTIME(le64toh(o->entry.realtime))) {
-                        log_debug(
+                        log_info(
                               "Invalid entry realtime timestamp: %"PRIu64": %"PRIu64,
                               le64toh(o->entry.realtime),
                               offset);
@@ -876,7 +876,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
                 }
 
                 if (!VALID_MONOTONIC(le64toh(o->entry.monotonic))) {
-                        log_debug(
+                        log_info(
                               "Invalid entry monotonic timestamp: %"PRIu64": %"PRIu64,
                               le64toh(o->entry.monotonic),
                               offset);
@@ -889,7 +889,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
         case OBJECT_FIELD_HASH_TABLE:
                 if ((le64toh(o->object.size) - offsetof(HashTableObject, items)) % sizeof(HashItem) != 0 ||
                     (le64toh(o->object.size) - offsetof(HashTableObject, items)) / sizeof(HashItem) <= 0) {
-                        log_debug(
+                        log_info(
                               "Invalid %s hash table size: %"PRIu64": %"PRIu64,
                               o->object.type == OBJECT_DATA_HASH_TABLE ? "data" : "field",
                               le64toh(o->object.size),
@@ -902,7 +902,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
         case OBJECT_ENTRY_ARRAY:
                 if ((le64toh(o->object.size) - offsetof(EntryArrayObject, items)) % sizeof(le64_t) != 0 ||
                     (le64toh(o->object.size) - offsetof(EntryArrayObject, items)) / sizeof(le64_t) <= 0) {
-                        log_debug(
+                        log_info(
                               "Invalid object entry array size: %"PRIu64": %"PRIu64,
                               le64toh(o->object.size),
                               offset);
@@ -910,7 +910,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
                 }
 
                 if (!VALID64(le64toh(o->entry_array.next_entry_array_offset))) {
-                        log_debug(
+                        log_info(
                               "Invalid object entry array next_entry_array_offset: "OFSfmt": %"PRIu64,
                               le64toh(o->entry_array.next_entry_array_offset),
                               offset);
@@ -921,7 +921,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
 
         case OBJECT_TAG:
                 if (le64toh(o->object.size) != sizeof(TagObject)) {
-                        log_debug(
+                        log_info(
                               "Invalid object tag size: %"PRIu64": %"PRIu64,
                               le64toh(o->object.size),
                               offset);
@@ -929,7 +929,7 @@ static int journal_file_check_object(JournalFile *f, uint64_t offset, Object *o)
                 }
 
                 if (!VALID_EPOCH(le64toh(o->tag.epoch))) {
-                        log_debug(
+                        log_info(
                               "Invalid object tag epoch: %"PRIu64": %"PRIu64,
                               le64toh(o->tag.epoch),
                               offset);
@@ -954,13 +954,13 @@ int journal_file_move_to_object(JournalFile *f, ObjectType type, uint64_t offset
 
         /* Objects may only be located at multiple of 64 bit */
         if (!VALID64(offset)) {
-                log_debug("Attempt to move to object at non-64bit boundary: %" PRIu64, offset);
+                log_info("Attempt to move to object at non-64bit boundary: %" PRIu64, offset);
                 return -EBADMSG;
         }
 
         /* Object may not be located in the file header */
         if (offset < le64toh(f->header->header_size)) {
-                log_debug("Attempt to move to object located in file header: %" PRIu64, offset);
+                log_info("Attempt to move to object located in file header: %" PRIu64, offset);
                 return -EBADMSG;
         }
 
@@ -972,26 +972,26 @@ int journal_file_move_to_object(JournalFile *f, ObjectType type, uint64_t offset
         s = le64toh(o->object.size);
 
         if (s == 0) {
-                log_debug("Attempt to move to uninitialized object: %" PRIu64, offset);
+                log_info("Attempt to move to uninitialized object: %" PRIu64, offset);
                 return -EBADMSG;
         }
         if (s < sizeof(ObjectHeader)) {
-                log_debug("Attempt to move to overly short object: %" PRIu64, offset);
+                log_info("Attempt to move to overly short object: %" PRIu64, offset);
                 return -EBADMSG;
         }
 
         if (o->object.type <= OBJECT_UNUSED) {
-                log_debug("Attempt to move to object with invalid type: %" PRIu64, offset);
+                log_info("Attempt to move to object with invalid type: %" PRIu64, offset);
                 return -EBADMSG;
         }
 
         if (s < minimum_header_size(o)) {
-                log_debug("Attempt to move to truncated object: %" PRIu64, offset);
+                log_info("Attempt to move to truncated object: %" PRIu64, offset);
                 return -EBADMSG;
         }
 
         if (type > OBJECT_UNUSED && o->object.type != type) {
-                log_debug("Attempt to move to object of unexpected type: %" PRIu64, offset);
+                log_info("Attempt to move to object of unexpected type: %" PRIu64, offset);
                 return -EBADMSG;
         }
 
@@ -1106,7 +1106,7 @@ static int journal_file_setup_data_hash_table(JournalFile *f) {
         if (s < DEFAULT_DATA_HASH_TABLE_SIZE)
                 s = DEFAULT_DATA_HASH_TABLE_SIZE;
 
-        log_debug("Reserving %"PRIu64" entries in hash table.", s / sizeof(HashItem));
+        log_info("Reserving %"PRIu64" entries in hash table.", s / sizeof(HashItem));
 
         r = journal_file_append_object(f,
                                        OBJECT_DATA_HASH_TABLE,
@@ -1585,7 +1585,7 @@ static int journal_file_append_data(
                         o->object.size = htole64(offsetof(Object, data.payload) + rsize);
                         o->object.flags |= compression;
 
-                        log_debug("Compressed data object %"PRIu64" -> %zu using %s",
+                        log_info("Compressed data object %"PRIu64" -> %zu using %s",
                                   size, rsize, object_compressed_to_string(compression));
                 } else
                         /* Compression didn't work, we don't really care why, let's continue without compression */
@@ -1813,7 +1813,7 @@ static int journal_file_link_entry(JournalFile *f, Object *o, uint64_t offset) {
         if (r < 0)
                 return r;
 
-        /* log_debug("=> %s seqnr=%"PRIu64" n_entries=%"PRIu64, f->path, o->entry.seqnum, f->header->n_entries); */
+        /* log_info("=> %s seqnr=%"PRIu64" n_entries=%"PRIu64, f->path, o->entry.seqnum, f->header->n_entries); */
 
         if (f->header->head_entry_realtime == 0)
                 f->header->head_entry_realtime = o->entry.realtime;
@@ -1894,7 +1894,7 @@ void journal_file_post_change(JournalFile *f) {
         __sync_synchronize();
 
         if (ftruncate(f->fd, f->last_stat.st_size) < 0)
-                log_debug_errno(errno, "Failed to truncate file to its own size: %m");
+                log_info_errno(errno, "Failed to truncate file to its own size: %m");
 }
 
 static int post_change_thunk(sd_event_source *timer, uint64_t usec, void *userdata) {
@@ -1917,7 +1917,7 @@ static void schedule_post_change(JournalFile *f) {
 
         r = sd_event_source_get_enabled(timer, &enabled);
         if (r < 0) {
-                log_debug_errno(r, "Failed to get ftruncate timer state: %m");
+                log_info_errno(r, "Failed to get ftruncate timer state: %m");
                 goto fail;
         }
 
@@ -1926,19 +1926,19 @@ static void schedule_post_change(JournalFile *f) {
 
         r = sd_event_now(sd_event_source_get_event(timer), CLOCK_MONOTONIC, &now);
         if (r < 0) {
-                log_debug_errno(r, "Failed to get clock's now for scheduling ftruncate: %m");
+                log_info_errno(r, "Failed to get clock's now for scheduling ftruncate: %m");
                 goto fail;
         }
 
         r = sd_event_source_set_time(timer, now+f->post_change_timer_period);
         if (r < 0) {
-                log_debug_errno(r, "Failed to set time for scheduling ftruncate: %m");
+                log_info_errno(r, "Failed to set time for scheduling ftruncate: %m");
                 goto fail;
         }
 
         r = sd_event_source_set_enabled(timer, SD_EVENT_ONESHOT);
         if (r < 0) {
-                log_debug_errno(r, "Failed to enable scheduled ftruncate: %m");
+                log_info_errno(r, "Failed to enable scheduled ftruncate: %m");
                 goto fail;
         }
 
@@ -2254,7 +2254,7 @@ static int generic_array_bisect(
                 else
                         r = test_object(f, p, needle);
                 if (r == -EBADMSG) {
-                        log_debug_errno(r, "Encountered invalid entry while bisecting, cutting algorithm short. (1)");
+                        log_info_errno(r, "Encountered invalid entry while bisecting, cutting algorithm short. (1)");
                         n = i;
                         continue;
                 }
@@ -2337,7 +2337,7 @@ static int generic_array_bisect(
                                 else
                                         r = test_object(f, p, needle);
                                 if (r == -EBADMSG) {
-                                        log_debug_errno(r, "Encountered invalid entry while bisecting, cutting algorithm short. (2)");
+                                        log_info_errno(r, "Encountered invalid entry while bisecting, cutting algorithm short. (2)");
                                         right = n = i;
                                         continue;
                                 }
@@ -2776,7 +2776,7 @@ int journal_file_next_entry(
 
                 /* OK, so this entry is borked. Most likely some entry didn't get synced to disk properly, let's see if
                  * the next one might work for us instead. */
-                log_debug_errno(r, "Entry item %" PRIu64 " is bad, skipping over it.", i);
+                log_info_errno(r, "Entry item %" PRIu64 " is bad, skipping over it.", i);
 
                 r = bump_array_index(&i, direction, n);
                 if (r <= 0)
@@ -2785,7 +2785,7 @@ int journal_file_next_entry(
 
         /* Ensure our array is properly ordered. */
         if (p > 0 && !check_properly_ordered(ofs, p, direction)) {
-                log_debug("%s: entry array not properly ordered at entry %" PRIu64, f->path, i);
+                log_info("%s: entry array not properly ordered at entry %" PRIu64, f->path, i);
                 return -EBADMSG;
         }
 
@@ -2852,7 +2852,7 @@ int journal_file_next_entry_for_data(
                 if (r != -EBADMSG)
                         return r;
 
-                log_debug_errno(r, "Data entry item %" PRIu64 " is bad, skipping over it.", i);
+                log_info_errno(r, "Data entry item %" PRIu64 " is bad, skipping over it.", i);
 
                 r = bump_array_index(&i, direction, n);
                 if (r <= 0)
@@ -2861,7 +2861,7 @@ int journal_file_next_entry_for_data(
 
         /* Ensure our array is properly ordered. */
         if (p > 0 && check_properly_ordered(ofs, p, direction)) {
-                log_debug("%s data entry array not properly ordered at entry %" PRIu64, f->path, i);
+                log_info("%s data entry array not properly ordered at entry %" PRIu64, f->path, i);
                 return -EBADMSG;
         }
 
@@ -3218,7 +3218,7 @@ static int journal_file_warn_btrfs(JournalFile *f) {
                 return log_warning_errno(r, "Failed to read file attributes: %m");
 
         if (attrs & FS_NOCOW_FL) {
-                log_debug("Detected btrfs file system with copy-on-write disabled, all is good.");
+                log_info("Detected btrfs file system with copy-on-write disabled, all is good.");
                 return 0;
         }
 
@@ -3691,7 +3691,7 @@ void journal_default_metrics(JournalMetrics *m, int fd) {
         if (fstatvfs(fd, &ss) >= 0)
                 fs_size = ss.f_frsize * ss.f_blocks;
         else {
-                log_debug_errno(errno, "Failed to detremine disk size: %m");
+                log_info_errno(errno, "Failed to detremine disk size: %m");
                 fs_size = 0;
         }
 
@@ -3763,7 +3763,7 @@ void journal_default_metrics(JournalMetrics *m, int fd) {
         if (m->n_max_files == (uint64_t) -1)
                 m->n_max_files = DEFAULT_N_MAX_FILES;
 
-        log_debug("Fixed min_use=%s max_use=%s max_size=%s min_size=%s keep_free=%s n_max_files=%" PRIu64,
+        log_info("Fixed min_use=%s max_use=%s max_size=%s min_size=%s keep_free=%s n_max_files=%" PRIu64,
                   format_bytes(a, sizeof(a), m->min_use),
                   format_bytes(b, sizeof(b), m->max_use),
                   format_bytes(c, sizeof(c), m->max_size),
@@ -3843,7 +3843,7 @@ bool journal_file_rotate_suggested(JournalFile *f, usec_t max_file_usec) {
         /* If we gained new header fields we gained new features,
          * hence suggest a rotation */
         if (le64toh(f->header->header_size) < sizeof(Header)) {
-                log_debug("%s uses an outdated header, suggesting rotation.", f->path);
+                log_info("%s uses an outdated header, suggesting rotation.", f->path);
                 return true;
         }
 
@@ -3855,7 +3855,7 @@ bool journal_file_rotate_suggested(JournalFile *f, usec_t max_file_usec) {
 
         if (JOURNAL_HEADER_CONTAINS(f->header, n_data))
                 if (le64toh(f->header->n_data) * 4ULL > (le64toh(f->header->data_hash_table_size) / sizeof(HashItem)) * 3ULL) {
-                        log_debug("Data hash table of %s has a fill level at %.1f (%"PRIu64" of %"PRIu64" items, %llu file size, %"PRIu64" bytes per hash table item), suggesting rotation.",
+                        log_info("Data hash table of %s has a fill level at %.1f (%"PRIu64" of %"PRIu64" items, %llu file size, %"PRIu64" bytes per hash table item), suggesting rotation.",
                                   f->path,
                                   100.0 * (double) le64toh(f->header->n_data) / ((double) (le64toh(f->header->data_hash_table_size) / sizeof(HashItem))),
                                   le64toh(f->header->n_data),
@@ -3867,7 +3867,7 @@ bool journal_file_rotate_suggested(JournalFile *f, usec_t max_file_usec) {
 
         if (JOURNAL_HEADER_CONTAINS(f->header, n_fields))
                 if (le64toh(f->header->n_fields) * 4ULL > (le64toh(f->header->field_hash_table_size) / sizeof(HashItem)) * 3ULL) {
-                        log_debug("Field hash table of %s has a fill level at %.1f (%"PRIu64" of %"PRIu64" items), suggesting rotation.",
+                        log_info("Field hash table of %s has a fill level at %.1f (%"PRIu64" of %"PRIu64" items), suggesting rotation.",
                                   f->path,
                                   100.0 * (double) le64toh(f->header->n_fields) / ((double) (le64toh(f->header->field_hash_table_size) / sizeof(HashItem))),
                                   le64toh(f->header->n_fields),
diff --git a/src/journal/journal-vacuum.c b/src/journal/journal-vacuum.c
index c21e87858..4b2d33479 100644
--- a/src/journal/journal-vacuum.c
+++ b/src/journal/journal-vacuum.c
@@ -189,7 +189,7 @@ int journal_directory_vacuum(
                 size_t q;
 
                 if (fstatat(dirfd(d), de->d_name, &st, AT_SYMLINK_NOFOLLOW) < 0) {
-                        log_debug_errno(errno, "Failed to stat file %s while vacuuming, ignoring: %m", de->d_name);
+                        log_info_errno(errno, "Failed to stat file %s while vacuuming, ignoring: %m", de->d_name);
                         continue;
                 }
 
@@ -264,7 +264,7 @@ int journal_directory_vacuum(
                         have_seqnum = false;
                 } else {
                         /* We do not vacuum unknown files! */
-                        log_debug("Not vacuuming unknown file %s.", de->d_name);
+                        log_info("Not vacuuming unknown file %s.", de->d_name);
                         continue;
                 }
 
@@ -272,7 +272,7 @@ int journal_directory_vacuum(
 
                 r = journal_file_empty(dirfd(d), p);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed check if %s is empty, ignoring: %m", p);
+                        log_info_errno(r, "Failed check if %s is empty, ignoring: %m", p);
                         continue;
                 }
                 if (r > 0) {
diff --git a/src/journal/journal-verify.c b/src/journal/journal-verify.c
index dc6b21b1e..e6be65df8 100644
--- a/src/journal/journal-verify.c
+++ b/src/journal/journal-verify.c
@@ -106,7 +106,7 @@ static void flush_progress(void) {
 
 #define debug(_offset, _fmt, ...) do {                                  \
                 flush_progress();                                       \
-                log_debug(OFSfmt": " _fmt, _offset, ##__VA_ARGS__);     \
+                log_info(OFSfmt": " _fmt, _offset, ##__VA_ARGS__);     \
         } while (0)
 
 #define warning(_offset, _fmt, ...) do {                                \
diff --git a/src/journal/journalctl.c b/src/journal/journalctl.c
index 17782688d..4d14190ff 100644
--- a/src/journal/journalctl.c
+++ b/src/journal/journalctl.c
@@ -1008,7 +1008,7 @@ static int parse_argv(int argc, char *argv[]) {
                         flags = !has_case * PCRE2_CASELESS;
                 }
 
-                log_debug("Doing case %s matching based on %s",
+                log_info("Doing case %s matching based on %s",
                           flags & PCRE2_CASELESS ? "insensitive" : "sensitive",
                           arg_case_sensitive >= 0 ? "request" : "pattern casing");
 
@@ -1220,7 +1220,7 @@ static int discover_next_boot(sd_journal *j,
         if (r < 0)
                 return r;
         else if (r == 0) {
-                log_debug("Whoopsie! We found a boot ID but can't read its last entry.");
+                log_info("Whoopsie! We found a boot ID but can't read its last entry.");
                 return -ENODATA; /* This shouldn't happen. We just came from this very boot ID. */
         }
 
@@ -1495,7 +1495,7 @@ static int get_possible_units(
 
                         STRV_FOREACH(pattern, patterns)
                                 if (fnmatch(*pattern, u, FNM_NOESCAPE) == 0) {
-                                        log_debug("Matched %s with pattern %s=%s", u, field, *pattern);
+                                        log_info("Matched %s with pattern %s=%s", u, field, *pattern);
 
                                         r = set_consume(found, u);
                                         u = NULL;
@@ -2365,7 +2365,7 @@ int main(int argc, char *argv[]) {
                 if (!filter)
                         return log_oom();
 
-                log_debug("Journal filter: %s", filter);
+                log_info("Journal filter: %s", filter);
         }
 
         if (arg_action == ACTION_LIST_FIELDS) {
diff --git a/src/journal/journald-audit.c b/src/journal/journald-audit.c
index 19f53751c..15bbfc689 100644
--- a/src/journal/journald-audit.c
+++ b/src/journal/journald-audit.c
@@ -310,7 +310,7 @@ static int map_all_fields(
 
                         r = m->map(m->journal_field, &v, iov, n_iov_allocated, n_iov);
                         if (r < 0)
-                                return log_debug_errno(r, "Failed to parse audit array: %m");
+                                return log_info_errno(r, "Failed to parse audit array: %m");
 
                         if (r > 0) {
                                 mapped = true;
@@ -322,7 +322,7 @@ static int map_all_fields(
                 if (!mapped) {
                         r = map_generic_field(prefix, &p, iov, n_iov_allocated, n_iov);
                         if (r < 0)
-                                return log_debug_errno(r, "Failed to parse audit array: %m");
+                                return log_info_errno(r, "Failed to parse audit array: %m");
 
                         if (r == 0)
                                 /* Couldn't process as generic field, let's just skip over it */
@@ -441,12 +441,12 @@ void server_process_audit_message(
             salen != sizeof(struct sockaddr_nl) ||
             sa->nl.nl_family != AF_NETLINK ||
             sa->nl.nl_pid != 0) {
-                log_debug("Audit netlink message from invalid sender.");
+                log_info("Audit netlink message from invalid sender.");
                 return;
         }
 
         if (!ucred || ucred->pid != 0) {
-                log_debug("Audit netlink message with invalid credentials.");
+                log_info("Audit netlink message with invalid credentials.");
                 return;
         }
 
@@ -525,7 +525,7 @@ int server_open_audit(Server *s) {
                 s->audit_fd = socket(AF_NETLINK, SOCK_RAW|SOCK_CLOEXEC|SOCK_NONBLOCK, NETLINK_AUDIT);
                 if (s->audit_fd < 0) {
                         if (IN_SET(errno, EAFNOSUPPORT, EPROTONOSUPPORT))
-                                log_debug("Audit not supported in the kernel.");
+                                log_info("Audit not supported in the kernel.");
                         else
                                 log_warning_errno(errno, "Failed to create audit socket, ignoring: %m");
 
diff --git a/src/journal/journald-console.c b/src/journal/journald-console.c
index 98fbb83a0..412ff028e 100644
--- a/src/journal/journald-console.c
+++ b/src/journal/journald-console.c
@@ -112,10 +112,10 @@ void server_forward_console(
 
         fd = open_terminal(tty, O_WRONLY|O_NOCTTY|O_CLOEXEC);
         if (fd < 0) {
-                log_debug_errno(fd, "Failed to open %s for logging: %m", tty);
+                log_info_errno(fd, "Failed to open %s for logging: %m", tty);
                 return;
         }
 
         if (writev(fd, iovec, n) < 0)
-                log_debug_errno(errno, "Failed to write to %s for logging: %m", tty);
+                log_info_errno(errno, "Failed to write to %s for logging: %m", tty);
 }
diff --git a/src/journal/journald-kmsg.c b/src/journal/journald-kmsg.c
index 0fadc16fb..9ff3831e6 100644
--- a/src/journal/journald-kmsg.c
+++ b/src/journal/journald-kmsg.c
@@ -95,7 +95,7 @@ void server_forward_kmsg(
         iovec[n++] = IOVEC_MAKE_STRING("\n");
 
         if (writev(s->dev_kmsg_fd, iovec, n) < 0)
-                log_debug_errno(errno, "Failed to write to /dev/kmsg for logging: %m");
+                log_info_errno(errno, "Failed to write to /dev/kmsg for logging: %m");
 }
 
 static bool is_us(const char *pid) {
@@ -358,7 +358,7 @@ int server_flush_dev_kmsg(Server *s) {
         if (!s->dev_kmsg_readable)
                 return 0;
 
-        log_debug("Flushing /dev/kmsg...");
+        log_info("Flushing /dev/kmsg...");
 
         for (;;) {
                 r = server_read_dev_kmsg(s);
diff --git a/src/journal/journald-native.c b/src/journal/journald-native.c
index cee873215..b160b249e 100644
--- a/src/journal/journald-native.c
+++ b/src/journal/journald-native.c
@@ -138,7 +138,7 @@ static int server_process_entry(
 
                 if (!e) {
                         /* Trailing noise, let's ignore it, and flush what we collected */
-                        log_debug("Received message with trailing noise, ignoring.");
+                        log_info("Received message with trailing noise, ignoring.");
                         r = 1; /* finish processing of the message */
                         break;
                 }
@@ -195,20 +195,20 @@ static int server_process_entry(
                         char *k;
 
                         if (*remaining < e - p + 1 + sizeof(uint64_t) + 1) {
-                                log_debug("Failed to parse message, ignoring.");
+                                log_info("Failed to parse message, ignoring.");
                                 break;
                         }
 
                         l = unaligned_read_le64(e + 1);
 
                         if (l > DATA_SIZE_MAX) {
-                                log_debug("Received binary data block of %"PRIu64" bytes is too large, ignoring.", l);
+                                log_info("Received binary data block of %"PRIu64" bytes is too large, ignoring.", l);
                                 break;
                         }
 
                         if ((uint64_t) *remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {
-                                log_debug("Failed to parse message, ignoring.");
+                                log_info("Failed to parse message, ignoring.");
                                 break;
                         }
 
@@ -256,7 +256,7 @@ static int server_process_entry(
         entry_size += STRLEN("_TRANSPORT=journal");
 
         if (entry_size + n + 1 > ENTRY_SIZE_MAX) { /* data + separators + trailer */
-                log_debug("Entry is too big with %zu properties and %zu bytes, ignoring.", n, entry_size);
+                log_info("Entry is too big with %zu properties and %zu bytes, ignoring.", n, entry_size);
                 goto finish;
         }
 
diff --git a/src/journal/journald-server.c b/src/journal/journald-server.c
index 5cd58e8a7..29528b95c 100644
--- a/src/journal/journald-server.c
+++ b/src/journal/journald-server.c
@@ -119,7 +119,7 @@ static int determine_path_usage(Server *s, const char *path, uint64_t *ret_used,
                         continue;
 
                 if (fstatat(dirfd(d), de->d_name, &st, AT_SYMLINK_NOFOLLOW) < 0) {
-                        log_debug_errno(errno, "Failed to stat %s/%s, ignoring: %m", path, de->d_name);
+                        log_info_errno(errno, "Failed to stat %s/%s, ignoring: %m", path, de->d_name);
                         continue;
                 }
 
@@ -482,7 +482,7 @@ void server_rotate(Server *s) {
         Iterator i;
         int r;
 
-        log_debug("Rotating...");
+        log_info("Rotating...");
 
         (void) do_rotate(s, &s->runtime_journal, "runtime", false, 0);
         (void) do_rotate(s, &s->system_journal, "system", s->seal, 0);
@@ -554,7 +554,7 @@ static void do_vacuum(Server *s, JournalStorage *storage, bool verbose) {
 int server_vacuum(Server *s, bool verbose) {
         assert(s);
 
-        log_debug("Vacuuming...");
+        log_info("Vacuuming...");
 
         s->oldest_file_usec = 0;
 
@@ -617,7 +617,7 @@ static bool shall_try_append_again(JournalFile *f, int r) {
         case -EFBIG:           /* Hit fs limit                  */
         case -EDQUOT:          /* Quota limit hit               */
         case -ENOSPC:          /* Disk full                     */
-                log_debug("%s: Allocation limit reached, rotating.", f->path);
+                log_info("%s: Allocation limit reached, rotating.", f->path);
                 return true;
 
         case -EIO:             /* I/O error of some kind (mmap) */
@@ -677,7 +677,7 @@ static void write_to_journal(Server *s, uid_t uid, struct iovec *iovec, unsigned
                  * to ensure that the entries in the journal files are strictly ordered by time, in order to ensure
                  * bisection works correctly. */
 
-                log_debug("Time jumped backwards, rotating.");
+                log_info("Time jumped backwards, rotating.");
                 rotate = true;
         } else {
 
@@ -686,7 +686,7 @@ static void write_to_journal(Server *s, uid_t uid, struct iovec *iovec, unsigned
                         return;
 
                 if (journal_file_rotate_suggested(f, s->max_file_usec)) {
-                        log_debug("%s: Journal header limits reached or header out-of-date, rotating.", f->path);
+                        log_info("%s: Journal header limits reached or header out-of-date, rotating.", f->path);
                         rotate = true;
                 }
         }
@@ -721,7 +721,7 @@ static void write_to_journal(Server *s, uid_t uid, struct iovec *iovec, unsigned
         if (!f)
                 return;
 
-        log_debug("Retrying write.");
+        log_info("Retrying write.");
         r = journal_file_append_entry(f, &ts, iovec, n, &s->seqnum, NULL, NULL);
         if (r < 0)
                 log_error_errno(r, "Failed to write entry (%d items, %zu bytes) despite vacuuming, ignoring: %m", n, IOVEC_TOTAL_SIZE(iovec, n));
@@ -994,7 +994,7 @@ int server_flush_to_var(Server *s, bool require_flag_file) {
         if (!s->system_journal)
                 return 0;
 
-        log_debug("Flushing to /var...");
+        log_info("Flushing to /var...");
 
         start = now(CLOCK_MONOTONIC);
 
@@ -1041,7 +1041,7 @@ int server_flush_to_var(Server *s, bool require_flag_file) {
                         goto finish;
                 }
 
-                log_debug("Retrying write.");
+                log_info("Retrying write.");
                 r = journal_file_copy_entry(f, s->system_journal, o, f->current_offset, NULL, NULL, NULL);
                 if (r < 0) {
                         log_error_errno(r, "Can't write entry: %m");
@@ -1251,7 +1251,7 @@ static int dispatch_sigrtmin1(sd_event_source *es, const struct signalfd_siginfo
 
         assert(s);
 
-        log_debug("Received request to sync from PID " PID_FMT, si->ssi_pid);
+        log_info("Received request to sync from PID " PID_FMT, si->ssi_pid);
 
         server_sync(s);
 
@@ -1551,7 +1551,7 @@ static int dispatch_notify_event(sd_event_source *es, int fd, uint32_t revents,
                 }
 
                 s->sent_notify_ready = true;
-                log_debug("Sent READY=1 notification.");
+                log_info("Sent READY=1 notification.");
 
         } else if (s->send_watchdog) {
 
@@ -1569,7 +1569,7 @@ static int dispatch_notify_event(sd_event_source *es, int fd, uint32_t revents,
                 }
 
                 s->send_watchdog = false;
-                log_debug("Sent WATCHDOG=1 notification.");
+                log_info("Sent WATCHDOG=1 notification.");
 
         } else if (s->stdout_streams_notify_queue)
                 /* Dispatch one stream notification event */
@@ -1729,7 +1729,7 @@ int server_init(Server *s) {
                 log_warning_errno(r, "Failed to parse kernel command line, ignoring: %m");
 
         if (!!s->rate_limit_interval ^ !!s->rate_limit_burst) {
-                log_debug("Setting both rate limit interval and burst from "USEC_FMT",%u to 0,0",
+                log_info("Setting both rate limit interval and burst from "USEC_FMT",%u to 0,0",
                           s->rate_limit_interval, s->rate_limit_burst);
                 s->rate_limit_interval = s->rate_limit_burst = 0;
         }
diff --git a/src/journal/journald-stream.c b/src/journal/journald-stream.c
index 671ada718..1ce8a7889 100644
--- a/src/journal/journald-stream.c
+++ b/src/journal/journald-stream.c
@@ -777,7 +777,7 @@ int server_restore_streams(Server *s, FDSet *fds) {
 
                 if (!found) {
                         /* No file descriptor? Then let's delete the state file */
-                        log_debug("Cannot restore stream file %s", de->d_name);
+                        log_info("Cannot restore stream file %s", de->d_name);
                         unlinkat(dirfd(d), de->d_name, 0);
                         continue;
                 }
@@ -871,7 +871,7 @@ void stdout_stream_send_notify(StdoutStream *s) {
 
                 log_error_errno(errno, "Failed to send stream file descriptor to service manager: %m");
         } else {
-                log_debug("Successfully sent stream file descriptor to service manager.");
+                log_info("Successfully sent stream file descriptor to service manager.");
                 s->fdstore = 1;
         }
 
diff --git a/src/journal/journald-syslog.c b/src/journal/journald-syslog.c
index 4018288b0..5b47d8004 100644
--- a/src/journal/journald-syslog.c
+++ b/src/journal/journald-syslog.c
@@ -113,7 +113,7 @@ static void forward_syslog_iovec(Server *s, const struct iovec *iovec, unsigned
         }
 
         if (errno != ENOENT)
-                log_debug_errno(errno, "Failed to forward syslog message: %m");
+                log_info_errno(errno, "Failed to forward syslog message: %m");
 }
 
 static void forward_syslog_raw(Server *s, int priority, const char *buffer, const struct ucred *ucred, const struct timeval *tv) {
diff --git a/src/journal/journald-wall.c b/src/journal/journald-wall.c
index 431abfeb3..c405f9853 100644
--- a/src/journal/journald-wall.c
+++ b/src/journal/journald-wall.c
@@ -68,5 +68,5 @@ void server_forward_wall(
 
         r = utmp_wall(l, "systemd-journald", NULL, NULL, NULL);
         if (r < 0)
-                log_debug_errno(r, "Failed to send wall message: %m");
+                log_info_errno(r, "Failed to send wall message: %m");
 }
diff --git a/src/journal/journald.c b/src/journal/journald.c
index 10a695576..ce2684151 100644
--- a/src/journal/journald.c
+++ b/src/journal/journald.c
@@ -58,7 +58,7 @@ int main(int argc, char *argv[]) {
         server_flush_to_var(&server, true);
         server_flush_dev_kmsg(&server);
 
-        log_debug("systemd-journald running as pid "PID_FMT, getpid_cached());
+        log_info("systemd-journald running as pid "PID_FMT, getpid_cached());
         server_driver_message(&server, 0,
                               "MESSAGE_ID=" SD_MESSAGE_JOURNAL_START_STR,
                               LOG_MESSAGE("Journal started"),
@@ -117,7 +117,7 @@ int main(int argc, char *argv[]) {
                 server_maybe_warn_forward_syslog_missed(&server);
         }
 
-        log_debug("systemd-journald stopped as pid "PID_FMT, getpid_cached());
+        log_info("systemd-journald stopped as pid "PID_FMT, getpid_cached());
         server_driver_message(&server, 0,
                               "MESSAGE_ID=" SD_MESSAGE_JOURNAL_STOP_STR,
                               LOG_MESSAGE("Journal stopped"),
diff --git a/src/journal/sd-journal.c b/src/journal/sd-journal.c
index 6da7bf8e8..2cef97389 100644
--- a/src/journal/sd-journal.c
+++ b/src/journal/sd-journal.c
@@ -833,7 +833,7 @@ static int real_journal_next(sd_journal *j, direction_t direction) {
 
                 r = next_beyond_location(j, f, direction);
                 if (r < 0) {
-                        log_debug_errno(r, "Can't iterate through %s, ignoring: %m", f->path);
+                        log_info_errno(r, "Can't iterate through %s, ignoring: %m", f->path);
                         remove_file_real(j, f);
                         continue;
                 } else if (r == 0) {
@@ -1269,7 +1269,7 @@ static int add_any_file(sd_journal *j, int fd, const char *path) {
                 return 0;
 
         if (ordered_hashmap_size(j->files) >= JOURNAL_FILES_MAX) {
-                log_debug("Too many open journal files, not adding %s.", path);
+                log_info("Too many open journal files, not adding %s.", path);
                 r = -ETOOMANYREFS;
                 goto fail;
         }
@@ -1281,7 +1281,7 @@ static int add_any_file(sd_journal *j, int fd, const char *path) {
 
                 fd = openat(j->toplevel_fd, skip_slash(path), O_RDONLY|O_CLOEXEC);
                 if (fd < 0) {
-                        r = log_debug_errno(errno, "Failed to open journal file %s: %m", path);
+                        r = log_info_errno(errno, "Failed to open journal file %s: %m", path);
                         goto fail;
                 }
 
@@ -1292,7 +1292,7 @@ static int add_any_file(sd_journal *j, int fd, const char *path) {
         if (r < 0) {
                 if (close_fd)
                         safe_close(fd);
-                log_debug_errno(r, "Failed to open journal file %s: %m", path);
+                log_info_errno(r, "Failed to open journal file %s: %m", path);
                 goto fail;
         }
 
@@ -1310,7 +1310,7 @@ static int add_any_file(sd_journal *j, int fd, const char *path) {
         else if (!j->has_persistent_files && path_has_prefix(j, f->path, "/var"))
                 j->has_persistent_files = true;
 
-        log_debug("File %s added.", f->path);
+        log_info("File %s added.", f->path);
 
         check_network(j, f->fd);
 
@@ -1365,7 +1365,7 @@ static void remove_file_real(sd_journal *j, JournalFile *f) {
 
         ordered_hashmap_remove(j->files, f->path);
 
-        log_debug("File %s removed.", f->path);
+        log_info("File %s removed.", f->path);
 
         if (j->current_file == f) {
                 j->current_file = NULL;
@@ -1429,7 +1429,7 @@ static int add_directory(sd_journal *j, const char *prefix, const char *dirname)
                 goto fail;
         }
 
-        log_debug("Considering directory %s.", path);
+        log_info("Considering directory %s.", path);
 
         /* We consider everything local that is in a directory for the local machine ID, or that is stored in /run */
         if ((j->flags & SD_JOURNAL_LOCAL_ONLY) &&
@@ -1444,7 +1444,7 @@ static int add_directory(sd_journal *j, const char *prefix, const char *dirname)
                  * relative, by dropping the initial slash */
                 d = xopendirat(j->toplevel_fd, skip_slash(path), 0);
         if (!d) {
-                r = log_debug_errno(errno, "Failed to open directory %s: %m", path);
+                r = log_info_errno(errno, "Failed to open directory %s: %m", path);
                 goto fail;
         }
 
@@ -1468,7 +1468,7 @@ static int add_directory(sd_journal *j, const char *prefix, const char *dirname)
                 path = NULL; /* avoid freeing in cleanup */
                 j->current_invalidate_counter++;
 
-                log_debug("Directory %s added.", m->path);
+                log_info("Directory %s added.", m->path);
 
         } else if (m->is_root)
                 return 0;
@@ -1485,7 +1485,7 @@ static int add_directory(sd_journal *j, const char *prefix, const char *dirname)
                         inotify_rm_watch(j->inotify_fd, m->wd);
         }
 
-        FOREACH_DIRENT_ALL(de, d, r = log_debug_errno(errno, "Failed to read directory %s: %m", m->path); goto fail) {
+        FOREACH_DIRENT_ALL(de, d, r = log_info_errno(errno, "Failed to read directory %s: %m", m->path); goto fail) {
 
                 if (dirent_is_file_with_suffix(de, ".journal") ||
                     dirent_is_file_with_suffix(de, ".journal~"))
@@ -1536,7 +1536,7 @@ static int add_root_directory(sd_journal *j, const char *p, bool missing_ok) {
                         if (errno == ENOENT && missing_ok)
                                 return 0;
 
-                        r = log_debug_errno(errno, "Failed to open root directory %s: %m", p);
+                        r = log_info_errno(errno, "Failed to open root directory %s: %m", p);
                         goto fail;
                 }
         } else {
@@ -1589,7 +1589,7 @@ static int add_root_directory(sd_journal *j, const char *p, bool missing_ok) {
 
                 j->current_invalidate_counter++;
 
-                log_debug("Root directory %s added.", m->path);
+                log_info("Root directory %s added.", m->path);
 
         } else if (!m->is_root)
                 return 0;
@@ -1607,7 +1607,7 @@ static int add_root_directory(sd_journal *j, const char *p, bool missing_ok) {
         if (j->no_new_files)
                 return 0;
 
-        FOREACH_DIRENT_ALL(de, d, r = log_debug_errno(errno, "Failed to read directory %s: %m", m->path); goto fail) {
+        FOREACH_DIRENT_ALL(de, d, r = log_info_errno(errno, "Failed to read directory %s: %m", m->path); goto fail) {
                 sd_id128_t id;
 
                 if (dirent_is_file_with_suffix(de, ".journal") ||
@@ -1643,9 +1643,9 @@ static void remove_directory(sd_journal *j, Directory *d) {
         hashmap_remove(j->directories_by_path, d->path);
 
         if (d->is_root)
-                log_debug("Root directory %s removed.", d->path);
+                log_info("Root directory %s removed.", d->path);
         else
-                log_debug("Directory %s removed.", d->path);
+                log_info("Directory %s removed.", d->path);
 
         free(d->path);
         free(d);
@@ -1998,7 +1998,7 @@ _public_ void sd_journal_close(sd_journal *j) {
         safe_close(j->inotify_fd);
 
         if (j->mmap) {
-                log_debug("mmap cache statistics: %u hit, %u miss", mmap_cache_get_hit(j->mmap), mmap_cache_get_missed(j->mmap));
+                log_info("mmap cache statistics: %u hit, %u miss", mmap_cache_get_hit(j->mmap), mmap_cache_get_missed(j->mmap));
                 mmap_cache_unref(j->mmap);
         }
 
@@ -2153,7 +2153,7 @@ _public_ int sd_journal_get_data(sd_journal *j, const char *field, const void **
                                                   &f->compress_buffer, &f->compress_buffer_size,
                                                   field, field_length, '=');
                         if (r < 0)
-                                log_debug_errno(r, "Cannot decompress %s object of length %"PRIu64" at offset "OFSfmt": %m",
+                                log_info_errno(r, "Cannot decompress %s object of length %"PRIu64" at offset "OFSfmt": %m",
                                                 object_compressed_to_string(compression), l, p);
                         else if (r > 0) {
 
@@ -2302,7 +2302,7 @@ _public_ int sd_journal_get_fd(sd_journal *j) {
         if (r < 0)
                 return r;
 
-        log_debug("Reiterating files to get inotify watches established");
+        log_info("Reiterating files to get inotify watches established");
 
         /* Iterate through all dirs again, to add them to the
          * inotify */
@@ -2401,7 +2401,7 @@ static void process_inotify_event(sd_journal *j, struct inotify_event *e) {
         if (e->mask & IN_IGNORED)
                 return;
 
-        log_debug("Unknown inotify event.");
+        log_info("Unknown inotify event.");
 }
 
 static int determine_change(sd_journal *j) {
@@ -2694,7 +2694,7 @@ _public_ int sd_journal_enumerate_unique(sd_journal *j, const void **data, size_
 
                 /* Let's do the type check by hand, since we used 0 context above. */
                 if (o->object.type != OBJECT_DATA) {
-                        log_debug("%s:offset " OFSfmt ": object has type %d, expected %d",
+                        log_info("%s:offset " OFSfmt ": object has type %d, expected %d",
                                   j->unique_file->path, j->unique_offset,
                                   o->object.type, OBJECT_DATA);
                         return -EBADMSG;
@@ -2706,14 +2706,14 @@ _public_ int sd_journal_enumerate_unique(sd_journal *j, const void **data, size_
 
                 /* Check if we have at least the field name and "=". */
                 if (ol <= k) {
-                        log_debug("%s:offset " OFSfmt ": object has size %zu, expected at least %zu",
+                        log_info("%s:offset " OFSfmt ": object has size %zu, expected at least %zu",
                                   j->unique_file->path, j->unique_offset,
                                   ol, k + 1);
                         return -EBADMSG;
                 }
 
                 if (memcmp(odata, j->unique_field, k) || ((const char*) odata)[k] != '=') {
-                        log_debug("%s:offset " OFSfmt ": object does not start with \"%s=\"",
+                        log_info("%s:offset " OFSfmt ": object does not start with \"%s=\"",
                                   j->unique_file->path, j->unique_offset,
                                   j->unique_field);
                         return -EBADMSG;
@@ -2849,7 +2849,7 @@ _public_ int sd_journal_enumerate_fields(sd_journal *j, const char **field) {
 
                 /* Because we used OBJECT_UNUSED above, we need to do our type check manually */
                 if (o->object.type != OBJECT_FIELD) {
-                        log_debug("%s:offset " OFSfmt ": object has type %i, expected %i", f->path, j->fields_offset, o->object.type, OBJECT_FIELD);
+                        log_info("%s:offset " OFSfmt ": object has type %i, expected %i", f->path, j->fields_offset, o->object.type, OBJECT_FIELD);
                         return -EBADMSG;
                 }
 
diff --git a/src/journal/test-compress-benchmark.c b/src/journal/test-compress-benchmark.c
index 1f7719754..2e4ee8f25 100644
--- a/src/journal/test-compress-benchmark.c
+++ b/src/journal/test-compress-benchmark.c
@@ -113,7 +113,7 @@ static void test_compress_decompress(const char* label, const char* type,
                 if (size == 0)
                         continue;
 
-                log_debug("%s %zu %zu", type, i, size);
+                log_info("%s %zu %zu", type, i, size);
 
                 memzero(buf, MIN(size + 1000, MAX_SIZE));
 
diff --git a/src/journal/test-compress.c b/src/journal/test-compress.c
index ea1ffcc4a..426fa7a23 100644
--- a/src/journal/test-compress.c
+++ b/src/journal/test-compress.c
@@ -167,14 +167,14 @@ static void test_compress_stream(int compression,
                 return;
         }
 
-        log_debug("/* testing %s compression */",
+        log_info("/* testing %s compression */",
                   object_compressed_to_string(compression));
 
-        log_debug("/* create source from %s */", srcfile);
+        log_info("/* create source from %s */", srcfile);
 
         assert_se((src = open(srcfile, O_RDONLY|O_CLOEXEC)) >= 0);
 
-        log_debug("/* test compression */");
+        log_info("/* test compression */");
 
         assert_se((dst = mkostemp_safe(pattern)) >= 0);
 
@@ -185,7 +185,7 @@ static void test_compress_stream(int compression,
                 assert_se(system(cmd) == 0);
         }
 
-        log_debug("/* test decompression */");
+        log_info("/* test decompression */");
 
         assert_se((dst2 = mkostemp_safe(pattern2)) >= 0);
 
@@ -198,7 +198,7 @@ static void test_compress_stream(int compression,
         assert_se(asprintf(&cmd2, "diff %s %s", srcfile, pattern2) > 0);
         assert_se(system(cmd2) == 0);
 
-        log_debug("/* test faulty decompression */");
+        log_info("/* test faulty decompression */");
 
         assert_se(lseek(dst, 1, SEEK_SET) == 1);
         r = decompress(dst, dst2, st.st_size);
diff --git a/src/libsystemd-network/dhcp-packet.c b/src/libsystemd-network/dhcp-packet.c
index 1c4ab5d52..2adcdac2e 100644
--- a/src/libsystemd-network/dhcp-packet.c
+++ b/src/libsystemd-network/dhcp-packet.c
@@ -123,25 +123,25 @@ int dhcp_packet_verify_headers(DHCPPacket *packet, size_t len, bool checksum, ui
         /* IP */
 
         if (packet->ip.version != IPVERSION) {
-                log_debug("ignoring packet: not IPv4");
+                log_info("ignoring packet: not IPv4");
                 return -EINVAL;
         }
 
         if (packet->ip.ihl < 5) {
-                log_debug("ignoring packet: IPv4 IHL (%u words) invalid",
+                log_info("ignoring packet: IPv4 IHL (%u words) invalid",
                           packet->ip.ihl);
                 return -EINVAL;
         }
 
         hdrlen = packet->ip.ihl * 4;
         if (hdrlen < 20) {
-                log_debug("ignoring packet: IPv4 IHL (%zu bytes) "
+                log_info("ignoring packet: IPv4 IHL (%zu bytes) "
                           "smaller than minimum (20 bytes)", hdrlen);
                 return -EINVAL;
         }
 
         if (len < hdrlen) {
-                log_debug("ignoring packet: packet (%zu bytes) "
+                log_info("ignoring packet: packet (%zu bytes) "
                           "smaller than expected (%zu) by IP header", len,
                           hdrlen);
                 return -EINVAL;
@@ -150,19 +150,19 @@ int dhcp_packet_verify_headers(DHCPPacket *packet, size_t len, bool checksum, ui
         /* UDP */
 
         if (packet->ip.protocol != IPPROTO_UDP) {
-                log_debug("ignoring packet: not UDP");
+                log_info("ignoring packet: not UDP");
                 return -EINVAL;
         }
 
         if (len < hdrlen + be16toh(packet->udp.len)) {
-                log_debug("ignoring packet: packet (%zu bytes) "
+                log_info("ignoring packet: packet (%zu bytes) "
                           "smaller than expected (%zu) by UDP header", len,
                           hdrlen + be16toh(packet->udp.len));
                 return -EINVAL;
         }
 
         if (be16toh(packet->udp.dest) != port) {
-                log_debug("ignoring packet: to port %u, which "
+                log_info("ignoring packet: to port %u, which "
                           "is not the DHCP client port (%u)",
                           be16toh(packet->udp.dest), port);
                 return -EINVAL;
@@ -173,7 +173,7 @@ int dhcp_packet_verify_headers(DHCPPacket *packet, size_t len, bool checksum, ui
          */
 
         if (dhcp_packet_checksum((uint8_t*)&packet->ip, hdrlen)) {
-                log_debug("ignoring packet: invalid IP checksum");
+                log_info("ignoring packet: invalid IP checksum");
                 return -EINVAL;
         }
 
@@ -183,7 +183,7 @@ int dhcp_packet_verify_headers(DHCPPacket *packet, size_t len, bool checksum, ui
 
                 if (dhcp_packet_checksum((uint8_t*)&packet->ip.ttl,
                                   be16toh(packet->udp.len) + 12)) {
-                        log_debug("ignoring packet: invalid UDP checksum");
+                        log_info("ignoring packet: invalid UDP checksum");
                         return -EINVAL;
                 }
         }
diff --git a/src/libsystemd-network/sd-dhcp-lease.c b/src/libsystemd-network/sd-dhcp-lease.c
index 2e88e3987..409215c66 100644
--- a/src/libsystemd-network/sd-dhcp-lease.c
+++ b/src/libsystemd-network/sd-dhcp-lease.c
@@ -474,7 +474,7 @@ static int lease_parse_routes(
                 route->option = SD_DHCP_OPTION_STATIC_ROUTE;
                 r = in4_addr_default_prefixlen((struct in_addr*) option, &route->dst_prefixlen);
                 if (r < 0) {
-                        log_debug("Failed to determine destination prefix length from class based IP, ignoring");
+                        log_info("Failed to determine destination prefix length from class based IP, ignoring");
                         continue;
                 }
 
@@ -555,21 +555,21 @@ int dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void
         case SD_DHCP_OPTION_IP_ADDRESS_LEASE_TIME:
                 r = lease_parse_u32(option, len, &lease->lifetime, 1);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse lease time, ignoring: %m");
+                        log_info_errno(r, "Failed to parse lease time, ignoring: %m");
 
                 break;
 
         case SD_DHCP_OPTION_SERVER_IDENTIFIER:
                 r = lease_parse_be32(option, len, &lease->server_address);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse server identifier, ignoring: %m");
+                        log_info_errno(r, "Failed to parse server identifier, ignoring: %m");
 
                 break;
 
         case SD_DHCP_OPTION_SUBNET_MASK:
                 r = lease_parse_be32(option, len, &lease->subnet_mask);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse subnet mask, ignoring: %m");
+                        log_info_errno(r, "Failed to parse subnet mask, ignoring: %m");
                 else
                         lease->have_subnet_mask = true;
                 break;
@@ -577,7 +577,7 @@ int dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void
         case SD_DHCP_OPTION_BROADCAST:
                 r = lease_parse_be32(option, len, &lease->broadcast);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse broadcast address, ignoring: %m");
+                        log_info_errno(r, "Failed to parse broadcast address, ignoring: %m");
                 else
                         lease->have_broadcast = true;
                 break;
@@ -586,34 +586,34 @@ int dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void
                 if (len >= 4) {
                         r = lease_parse_be32(option, 4, &lease->router);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to parse router address, ignoring: %m");
+                                log_info_errno(r, "Failed to parse router address, ignoring: %m");
                 }
                 break;
 
         case SD_DHCP_OPTION_DOMAIN_NAME_SERVER:
                 r = lease_parse_in_addrs(option, len, &lease->dns, &lease->dns_size);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse DNS server, ignoring: %m");
+                        log_info_errno(r, "Failed to parse DNS server, ignoring: %m");
                 break;
 
         case SD_DHCP_OPTION_NTP_SERVER:
                 r = lease_parse_in_addrs(option, len, &lease->ntp, &lease->ntp_size);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse NTP server, ignoring: %m");
+                        log_info_errno(r, "Failed to parse NTP server, ignoring: %m");
                 break;
 
         case SD_DHCP_OPTION_STATIC_ROUTE:
                 r = lease_parse_routes(option, len, &lease->static_route, &lease->static_route_size, &lease->static_route_allocated);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse static routes, ignoring: %m");
+                        log_info_errno(r, "Failed to parse static routes, ignoring: %m");
                 break;
 
         case SD_DHCP_OPTION_INTERFACE_MTU:
                 r = lease_parse_u16(option, len, &lease->mtu, 68);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse MTU, ignoring: %m");
+                        log_info_errno(r, "Failed to parse MTU, ignoring: %m");
                 if (lease->mtu < DHCP_DEFAULT_MIN_SIZE) {
-                        log_debug("MTU value of %" PRIu16 " too small. Using default MTU value of %d instead.", lease->mtu, DHCP_DEFAULT_MIN_SIZE);
+                        log_info("MTU value of %" PRIu16 " too small. Using default MTU value of %d instead.", lease->mtu, DHCP_DEFAULT_MIN_SIZE);
                         lease->mtu = DHCP_DEFAULT_MIN_SIZE;
                 }
 
@@ -622,7 +622,7 @@ int dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void
         case SD_DHCP_OPTION_DOMAIN_NAME:
                 r = lease_parse_domain(option, len, &lease->domainname);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to parse domain name, ignoring: %m");
+                        log_info_errno(r, "Failed to parse domain name, ignoring: %m");
                         return 0;
                 }
 
@@ -631,13 +631,13 @@ int dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void
         case SD_DHCP_OPTION_DOMAIN_SEARCH_LIST:
                 r = dhcp_lease_parse_search_domains(option, len, &lease->search_domains);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse Domain Search List, ignoring: %m");
+                        log_info_errno(r, "Failed to parse Domain Search List, ignoring: %m");
                 break;
 
         case SD_DHCP_OPTION_HOST_NAME:
                 r = lease_parse_domain(option, len, &lease->hostname);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to parse host name, ignoring: %m");
+                        log_info_errno(r, "Failed to parse host name, ignoring: %m");
                         return 0;
                 }
 
@@ -646,19 +646,19 @@ int dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void
         case SD_DHCP_OPTION_ROOT_PATH:
                 r = lease_parse_string(option, len, &lease->root_path);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse root path, ignoring: %m");
+                        log_info_errno(r, "Failed to parse root path, ignoring: %m");
                 break;
 
         case SD_DHCP_OPTION_RENEWAL_T1_TIME:
                 r = lease_parse_u32(option, len, &lease->t1, 1);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse T1 time, ignoring: %m");
+                        log_info_errno(r, "Failed to parse T1 time, ignoring: %m");
                 break;
 
         case SD_DHCP_OPTION_REBINDING_T2_TIME:
                 r = lease_parse_u32(option, len, &lease->t2, 1);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse T2 time, ignoring: %m");
+                        log_info_errno(r, "Failed to parse T2 time, ignoring: %m");
                 break;
 
         case SD_DHCP_OPTION_CLASSLESS_STATIC_ROUTE:
@@ -668,7 +668,7 @@ int dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void
                                 &lease->static_route_size,
                                 &lease->static_route_allocated);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse classless routes, ignoring: %m");
+                        log_info_errno(r, "Failed to parse classless routes, ignoring: %m");
                 break;
 
         case SD_DHCP_OPTION_NEW_TZDB_TIMEZONE: {
@@ -676,12 +676,12 @@ int dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void
 
                 r = lease_parse_string(option, len, &tz);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to parse timezone option, ignoring: %m");
+                        log_info_errno(r, "Failed to parse timezone option, ignoring: %m");
                         return 0;
                 }
 
                 if (!timezone_is_valid(tz)) {
-                        log_debug_errno(r, "Timezone is not valid, ignoring: %m");
+                        log_info_errno(r, "Timezone is not valid, ignoring: %m");
                         return 0;
                 }
 
@@ -716,7 +716,7 @@ int dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void
                 break;
 
         default:
-                log_debug("Ignoring option DHCP option %"PRIu8" while parsing.", code);
+                log_info("Ignoring option DHCP option %"PRIu8" while parsing.", code);
                 break;
         }
 
@@ -822,7 +822,7 @@ int dhcp_lease_insert_private_option(sd_dhcp_lease *lease, uint8_t tag, const vo
                 if (tag < cur->tag)
                         break;
                 if (tag == cur->tag) {
-                        log_debug("Ignoring duplicate option, tagged %i.", tag);
+                        log_info("Ignoring duplicate option, tagged %i.", tag);
                         return 0;
                 }
         }
@@ -1107,19 +1107,19 @@ int dhcp_lease_load(sd_dhcp_lease **ret, const char *lease_file) {
         if (address) {
                 r = inet_pton(AF_INET, address, &lease->address);
                 if (r <= 0)
-                        log_debug("Failed to parse address %s, ignoring.", address);
+                        log_info("Failed to parse address %s, ignoring.", address);
         }
 
         if (router) {
                 r = inet_pton(AF_INET, router, &lease->router);
                 if (r <= 0)
-                        log_debug("Failed to parse router %s, ignoring.", router);
+                        log_info("Failed to parse router %s, ignoring.", router);
         }
 
         if (netmask) {
                 r = inet_pton(AF_INET, netmask, &lease->subnet_mask);
                 if (r <= 0)
-                        log_debug("Failed to parse netmask %s, ignoring.", netmask);
+                        log_info("Failed to parse netmask %s, ignoring.", netmask);
                 else
                         lease->have_subnet_mask = true;
         }
@@ -1127,19 +1127,19 @@ int dhcp_lease_load(sd_dhcp_lease **ret, const char *lease_file) {
         if (server_address) {
                 r = inet_pton(AF_INET, server_address, &lease->server_address);
                 if (r <= 0)
-                        log_debug("Failed to parse server address %s, ignoring.", server_address);
+                        log_info("Failed to parse server address %s, ignoring.", server_address);
         }
 
         if (next_server) {
                 r = inet_pton(AF_INET, next_server, &lease->next_server);
                 if (r <= 0)
-                        log_debug("Failed to parse next server %s, ignoring.", next_server);
+                        log_info("Failed to parse next server %s, ignoring.", next_server);
         }
 
         if (broadcast) {
                 r = inet_pton(AF_INET, broadcast, &lease->broadcast);
                 if (r <= 0)
-                        log_debug("Failed to parse broadcast address %s, ignoring.", broadcast);
+                        log_info("Failed to parse broadcast address %s, ignoring.", broadcast);
                 else
                         lease->have_broadcast = true;
         }
@@ -1147,7 +1147,7 @@ int dhcp_lease_load(sd_dhcp_lease **ret, const char *lease_file) {
         if (dns) {
                 r = deserialize_in_addrs(&lease->dns, dns);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to deserialize DNS servers %s, ignoring: %m", dns);
+                        log_info_errno(r, "Failed to deserialize DNS servers %s, ignoring: %m", dns);
                 else
                         lease->dns_size = r;
         }
@@ -1155,7 +1155,7 @@ int dhcp_lease_load(sd_dhcp_lease **ret, const char *lease_file) {
         if (ntp) {
                 r = deserialize_in_addrs(&lease->ntp, ntp);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to deserialize NTP servers %s, ignoring: %m", ntp);
+                        log_info_errno(r, "Failed to deserialize NTP servers %s, ignoring: %m", ntp);
                 else
                         lease->ntp_size = r;
         }
@@ -1163,7 +1163,7 @@ int dhcp_lease_load(sd_dhcp_lease **ret, const char *lease_file) {
         if (mtu) {
                 r = safe_atou16(mtu, &lease->mtu);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse MTU %s, ignoring: %m", mtu);
+                        log_info_errno(r, "Failed to parse MTU %s, ignoring: %m", mtu);
         }
 
         if (domains) {
@@ -1185,37 +1185,37 @@ int dhcp_lease_load(sd_dhcp_lease **ret, const char *lease_file) {
                                 &lease->static_route_allocated,
                                 routes);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse DHCP routes %s, ignoring: %m", routes);
+                        log_info_errno(r, "Failed to parse DHCP routes %s, ignoring: %m", routes);
         }
 
         if (lifetime) {
                 r = safe_atou32(lifetime, &lease->lifetime);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse lifetime %s, ignoring: %m", lifetime);
+                        log_info_errno(r, "Failed to parse lifetime %s, ignoring: %m", lifetime);
         }
 
         if (t1) {
                 r = safe_atou32(t1, &lease->t1);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse T1 %s, ignoring: %m", t1);
+                        log_info_errno(r, "Failed to parse T1 %s, ignoring: %m", t1);
         }
 
         if (t2) {
                 r = safe_atou32(t2, &lease->t2);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse T2 %s, ignoring: %m", t2);
+                        log_info_errno(r, "Failed to parse T2 %s, ignoring: %m", t2);
         }
 
         if (client_id_hex) {
                 r = deserialize_dhcp_option(&lease->client_id, &lease->client_id_len, client_id_hex);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse client ID %s, ignoring: %m", client_id_hex);
+                        log_info_errno(r, "Failed to parse client ID %s, ignoring: %m", client_id_hex);
         }
 
         if (vendor_specific_hex) {
                 r = deserialize_dhcp_option(&lease->vendor_specific, &lease->vendor_specific_len, vendor_specific_hex);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse vendor specific data %s, ignoring: %m", vendor_specific_hex);
+                        log_info_errno(r, "Failed to parse vendor specific data %s, ignoring: %m", vendor_specific_hex);
         }
 
         for (i = 0; i <= SD_DHCP_OPTION_PRIVATE_LAST - SD_DHCP_OPTION_PRIVATE_BASE; i++) {
@@ -1227,7 +1227,7 @@ int dhcp_lease_load(sd_dhcp_lease **ret, const char *lease_file) {
 
                 r = deserialize_dhcp_option(&data, &len, options[i]);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to parse private DHCP option %s, ignoring: %m", options[i]);
+                        log_info_errno(r, "Failed to parse private DHCP option %s, ignoring: %m", options[i]);
                         continue;
                 }
 
diff --git a/src/libsystemd/sd-bus/bus-control.c b/src/libsystemd/sd-bus/bus-control.c
index 9dd5274bf..657780d25 100644
--- a/src/libsystemd/sd-bus/bus-control.c
+++ b/src/libsystemd/sd-bus/bus-control.c
@@ -161,7 +161,7 @@ static int default_request_name_handler(
         assert(m);
 
         if (sd_bus_message_is_method_error(m, NULL)) {
-                log_debug_errno(sd_bus_message_get_errno(m),
+                log_info_errno(sd_bus_message_get_errno(m),
                                 "Unable to request name, failing connection: %s",
                                 sd_bus_message_get_error(m)->message);
 
@@ -176,24 +176,24 @@ static int default_request_name_handler(
         switch (ret) {
 
         case BUS_NAME_ALREADY_OWNER:
-                log_debug("Already owner of requested service name, ignoring.");
+                log_info("Already owner of requested service name, ignoring.");
                 return 1;
 
         case BUS_NAME_IN_QUEUE:
-                log_debug("In queue for requested service name.");
+                log_info("In queue for requested service name.");
                 return 1;
 
         case BUS_NAME_PRIMARY_OWNER:
-                log_debug("Successfully acquired requested service name.");
+                log_info("Successfully acquired requested service name.");
                 return 1;
 
         case BUS_NAME_EXISTS:
-                log_debug("Requested service name already owned, failing connection.");
+                log_info("Requested service name already owned, failing connection.");
                 bus_enter_closing(sd_bus_message_get_bus(m));
                 return 1;
         }
 
-        log_debug("Unexpected response from RequestName(), failing connection.");
+        log_info("Unexpected response from RequestName(), failing connection.");
         bus_enter_closing(sd_bus_message_get_bus(m));
         return 1;
 }
@@ -315,7 +315,7 @@ static int default_release_name_handler(
         assert(m);
 
         if (sd_bus_message_is_method_error(m, NULL)) {
-                log_debug_errno(sd_bus_message_get_errno(m),
+                log_info_errno(sd_bus_message_get_errno(m),
                                 "Unable to release name, failing connection: %s",
                                 sd_bus_message_get_error(m)->message);
 
@@ -330,19 +330,19 @@ static int default_release_name_handler(
         switch (ret) {
 
         case BUS_NAME_NON_EXISTENT:
-                log_debug("Name asked to release is not taken currently, ignoring.");
+                log_info("Name asked to release is not taken currently, ignoring.");
                 return 1;
 
         case BUS_NAME_NOT_OWNER:
-                log_debug("Name asked to release is owned by somebody else, ignoring.");
+                log_info("Name asked to release is owned by somebody else, ignoring.");
                 return 1;
 
         case BUS_NAME_RELEASED:
-                log_debug("Name successfully released.");
+                log_info("Name successfully released.");
                 return 1;
         }
 
-        log_debug("Unexpected response from ReleaseName(), failing connection.");
+        log_info("Unexpected response from ReleaseName(), failing connection.");
         bus_enter_closing(sd_bus_message_get_bus(m));
         return 1;
 }
diff --git a/src/libsystemd/sd-bus/bus-internal.c b/src/libsystemd/sd-bus/bus-internal.c
index 05a022fbf..23f5ed703 100644
--- a/src/libsystemd/sd-bus/bus-internal.c
+++ b/src/libsystemd/sd-bus/bus-internal.c
@@ -362,7 +362,7 @@ int bus_maybe_reply_error(sd_bus_message *m, int r, sd_bus_error *error) {
         } else
                 return r;
 
-        log_debug("Failed to process message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%" PRIu64 " reply_cookie=%" PRIu64 " signature=%s error-name=%s error-message=%s: %s",
+        log_info("Failed to process message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%" PRIu64 " reply_cookie=%" PRIu64 " signature=%s error-name=%s error-message=%s: %s",
                   bus_message_type_to_string(m->header->type),
                   strna(sd_bus_message_get_sender(m)),
                   strna(sd_bus_message_get_destination(m)),
diff --git a/src/libsystemd/sd-bus/bus-socket.c b/src/libsystemd/sd-bus/bus-socket.c
index 2fe86b61c..ce7487a5f 100644
--- a/src/libsystemd/sd-bus/bus-socket.c
+++ b/src/libsystemd/sd-bus/bus-socket.c
@@ -581,7 +581,7 @@ static int bus_socket_read_auth(sd_bus *b) {
                                 close_many((int*) CMSG_DATA(cmsg), j);
                                 return -EIO;
                         } else
-                                log_debug("Got unexpected auxiliary data with level=%d and type=%d",
+                                log_info("Got unexpected auxiliary data with level=%d and type=%d",
                                           cmsg->cmsg_level, cmsg->cmsg_type);
         }
 
@@ -617,14 +617,14 @@ static void bus_get_peercred(sd_bus *b) {
         /* Get the SELinux context of the peer */
         r = getpeersec(b->input_fd, &b->label);
         if (r < 0 && !IN_SET(r, -EOPNOTSUPP, -ENOPROTOOPT))
-                log_debug_errno(r, "Failed to determine peer security context: %m");
+                log_info_errno(r, "Failed to determine peer security context: %m");
 
         /* Get the list of auxiliary groups of the peer */
         r = getpeergroups(b->input_fd, &b->groups);
         if (r >= 0)
                 b->n_groups = (size_t) r;
         else if (!IN_SET(r, -EOPNOTSUPP, -ENOPROTOOPT))
-                log_debug_errno(r, "Failed to determine peer's group list: %m");
+                log_info_errno(r, "Failed to determine peer's group list: %m");
 }
 
 static int bus_socket_start_auth_client(sd_bus *b) {
@@ -736,7 +736,7 @@ static int bus_socket_inotify_setup(sd_bus *b) {
          * always exists */
         wd = inotify_add_watch(b->inotify_fd, "/", IN_CREATE|IN_MOVED_TO);
         if (wd < 0) {
-                r = log_debug_errno(errno, "Failed to add inotify watch on /: %m");
+                r = log_info_errno(errno, "Failed to add inotify watch on /: %m");
                 goto fail;
         } else
                 new_watches[n++] = wd;
@@ -782,13 +782,13 @@ static int bus_socket_inotify_setup(sd_bus *b) {
                 }
 
                 wd = inotify_add_watch(b->inotify_fd, prefix, IN_DELETE_SELF|IN_MOVE_SELF|IN_ATTRIB|IN_CREATE|IN_MOVED_TO|IN_DONT_FOLLOW);
-                log_debug("Added inotify watch for %s on bus %s: %i", prefix, strna(b->description), wd);
+                log_info("Added inotify watch for %s on bus %s: %i", prefix, strna(b->description), wd);
 
                 if (wd < 0) {
                         if (IN_SET(errno, ENOENT, ELOOP))
                                 break; /* This component doesn't exist yet, or the path contains a cyclic symlink right now */
 
-                        r = log_debug_errno(errno, "Failed to add inotify watch on %s: %m", isempty(prefix) ? "/" : prefix);
+                        r = log_info_errno(errno, "Failed to add inotify watch on %s: %m", isempty(prefix) ? "/" : prefix);
                         goto fail;
                 } else
                         new_watches[n++] = wd;
@@ -1229,7 +1229,7 @@ int bus_socket_read_message(sd_bus *bus) {
                                 bus->fds = f;
                                 bus->n_fds += n;
                         } else
-                                log_debug("Got unexpected auxiliary data with level=%d and type=%d",
+                                log_info("Got unexpected auxiliary data with level=%d and type=%d",
                                           cmsg->cmsg_level, cmsg->cmsg_type);
         }
 
@@ -1301,7 +1301,7 @@ int bus_socket_process_watch_bind(sd_bus *b) {
         if (r <= 0)
                 return r;
 
-        log_debug("Got inotify event on bus %s.", strna(b->description));
+        log_info("Got inotify event on bus %s.", strna(b->description));
 
         /* We flushed events out of the inotify fd. In that case, maybe the socket is valid now? Let's try to connect
          * to it again */
diff --git a/src/libsystemd/sd-bus/bus-track.c b/src/libsystemd/sd-bus/bus-track.c
index 5482d39a0..d854024fb 100644
--- a/src/libsystemd/sd-bus/bus-track.c
+++ b/src/libsystemd/sd-bus/bus-track.c
@@ -403,7 +403,7 @@ void bus_track_dispatch(sd_bus_track *track) {
 
         r = track->handler(track, track->userdata);
         if (r < 0)
-                log_debug_errno(r, "Failed to process track handler: %m");
+                log_info_errno(r, "Failed to process track handler: %m");
         else if (r == 0)
                 bus_track_add_to_queue(track);
 
diff --git a/src/libsystemd/sd-bus/sd-bus.c b/src/libsystemd/sd-bus/sd-bus.c
index 7e7ebb27a..786868c40 100644
--- a/src/libsystemd/sd-bus/sd-bus.c
+++ b/src/libsystemd/sd-bus/sd-bus.c
@@ -55,10 +55,10 @@
 #include "strv.h"
 #include "util.h"
 
-#define log_debug_bus_message(m)                                         \
+#define log_info_bus_message(m)                                         \
         do {                                                             \
                 sd_bus_message *_mm = (m);                               \
-                log_debug("Got message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%" PRIu64 " reply_cookie=%" PRIu64 " signature=%s error-name=%s error-message=%s", \
+                log_info("Got message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%" PRIu64 " reply_cookie=%" PRIu64 " signature=%s error-name=%s error-message=%s", \
                           bus_message_type_to_string(_mm->header->type), \
                           strna(sd_bus_message_get_sender(_mm)),         \
                           strna(sd_bus_message_get_destination(_mm)),    \
@@ -550,7 +550,7 @@ void bus_set_state(sd_bus *bus, enum bus_state state) {
         if (state == bus->state)
                 return;
 
-        log_debug("Bus %s: changing state %s → %s", strna(bus->description), table[bus->state], table[state]);
+        log_info("Bus %s: changing state %s → %s", strna(bus->description), table[bus->state], table[state]);
         bus->state = state;
 }
 
@@ -1697,7 +1697,7 @@ static int bus_write_message(sd_bus *bus, sd_bus_message *m, size_t *idx) {
                 return r;
 
         if (*idx >= BUS_MESSAGE_SIZE(m))
-                log_debug("Sent message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%" PRIu64 " reply_cookie=%" PRIu64 " signature=%s error-name=%s error-message=%s",
+                log_info("Sent message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%" PRIu64 " reply_cookie=%" PRIu64 " signature=%s error-name=%s error-message=%s",
                           bus_message_type_to_string(m->header->type),
                           strna(sd_bus_message_get_sender(m)),
                           strna(sd_bus_message_get_destination(m)),
@@ -2110,7 +2110,7 @@ _public_ int sd_bus_call(
 
                                 memmove(bus->rqueue + i, bus->rqueue + i + 1, sizeof(sd_bus_message*) * (bus->rqueue_size - i - 1));
                                 bus->rqueue_size--;
-                                log_debug_bus_message(incoming);
+                                log_info_bus_message(incoming);
 
                                 if (incoming->header->type == SD_BUS_MESSAGE_METHOD_RETURN) {
 
@@ -2657,7 +2657,7 @@ static int process_message(sd_bus *bus, sd_bus_message *m) {
         bus->current_message = m;
         bus->iteration_counter++;
 
-        log_debug_bus_message(m);
+        log_info_bus_message(m);
 
         r = process_hello(bus, m);
         if (r != 0)
@@ -2741,7 +2741,7 @@ static int process_running(sd_bus *bus, bool hint_priority, int64_t priority, sd
 
         if (m->header->type == SD_BUS_MESSAGE_METHOD_CALL) {
 
-                log_debug("Unprocessed message call sender=%s object=%s interface=%s member=%s",
+                log_info("Unprocessed message call sender=%s object=%s interface=%s member=%s",
                           strna(sd_bus_message_get_sender(m)),
                           strna(sd_bus_message_get_path(m)),
                           strna(sd_bus_message_get_interface(m)),
@@ -2779,7 +2779,7 @@ static int bus_exit_now(sd_bus *bus) {
 
         bus->exited = true; /* never exit more than once */
 
-        log_debug("Bus connection disconnected, exiting.");
+        log_info("Bus connection disconnected, exiting.");
 
         if (bus->event)
                 return sd_event_exit(bus->event, EXIT_FAILURE);
@@ -3151,14 +3151,14 @@ static int add_match_callback(
         sd_bus_slot_ref(match_slot);
 
         if (sd_bus_message_is_method_error(m, NULL)) {
-                log_debug_errno(sd_bus_message_get_errno(m),
+                log_info_errno(sd_bus_message_get_errno(m),
                                 "Unable to add match %s, failing connection: %s",
                                 match_slot->match_callback.match_string,
                                 sd_bus_message_get_error(m)->message);
 
                 failed = true;
         } else
-                log_debug("Match %s successfully installed.", match_slot->match_callback.match_string);
+                log_info("Match %s successfully installed.", match_slot->match_callback.match_string);
 
         if (match_slot->match_callback.install_callback) {
                 sd_bus *bus;
@@ -3320,7 +3320,7 @@ static int io_callback(sd_event_source *s, int fd, uint32_t revents, void *userd
 
         r = sd_bus_process(bus, NULL);
         if (r < 0) {
-                log_debug_errno(r, "Processing of bus failed, closing down: %m");
+                log_info_errno(r, "Processing of bus failed, closing down: %m");
                 bus_enter_closing(bus);
         }
 
@@ -3335,7 +3335,7 @@ static int time_callback(sd_event_source *s, uint64_t usec, void *userdata) {
 
         r = sd_bus_process(bus, NULL);
         if (r < 0) {
-                log_debug_errno(r, "Processing of bus failed, closing down: %m");
+                log_info_errno(r, "Processing of bus failed, closing down: %m");
                 bus_enter_closing(bus);
         }
 
@@ -3388,7 +3388,7 @@ static int prepare_callback(sd_event_source *s, void *userdata) {
         return 1;
 
 fail:
-        log_debug_errno(r, "Preparing of bus events failed, closing down: %m");
+        log_info_errno(r, "Preparing of bus events failed, closing down: %m");
         bus_enter_closing(bus);
 
         return 1;
diff --git a/src/libsystemd/sd-bus/test-bus-watch-bind.c b/src/libsystemd/sd-bus/test-bus-watch-bind.c
index aef5ba948..0319ecb40 100644
--- a/src/libsystemd/sd-bus/test-bus-watch-bind.c
+++ b/src/libsystemd/sd-bus/test-bus-watch-bind.c
@@ -63,7 +63,7 @@ static void* thread_server(void *p) {
         };
         const char *path = p;
 
-        log_debug("Initializing server");
+        log_info("Initializing server");
 
         /* Let's play some games, by slowly creating the socket directory, and renaming it in the middle */
         (void) usleep(100 * USEC_PER_MSEC);
@@ -98,7 +98,7 @@ static void* thread_server(void *p) {
         assert_se(touch(path) >= 0);
         usleep(100 * USEC_PER_MSEC);
 
-        log_debug("Initialized server");
+        log_info("Initialized server");
 
         for (;;) {
                 _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;
@@ -113,7 +113,7 @@ static void* thread_server(void *p) {
                 bus_fd = accept4(fd, NULL, NULL, SOCK_NONBLOCK|SOCK_CLOEXEC);
                 assert_se(bus_fd >= 0);
 
-                log_debug("Accepted server connection");
+                log_info("Accepted server connection");
 
                 assert_se(sd_bus_new(&bus) >= 0);
                 assert_se(sd_bus_set_description(bus, "server") >= 0);
@@ -135,7 +135,7 @@ static void* thread_server(void *p) {
                         break;
         }
 
-        log_debug("Server done");
+        log_info("Server done");
 
         return NULL;
 }
@@ -146,7 +146,7 @@ static void* thread_client1(void *p) {
         const char *path = p, *t;
         int r;
 
-        log_debug("Initializing client1");
+        log_info("Initializing client1");
 
         assert_se(sd_bus_new(&bus) >= 0);
         assert_se(sd_bus_set_description(bus, "client1") >= 0);
@@ -159,7 +159,7 @@ static void* thread_client1(void *p) {
         r = sd_bus_call_method(bus, "foo.bar", "/foo", "foo.TestInterface", "Foobar", &error, NULL, NULL);
         assert_se(r >= 0);
 
-        log_debug("Client1 done");
+        log_info("Client1 done");
 
         return NULL;
 }
@@ -175,7 +175,7 @@ static void* thread_client2(void *p) {
         _cleanup_(sd_event_unrefp) sd_event *event = NULL;
         const char *path = p, *t;
 
-        log_debug("Initializing client2");
+        log_info("Initializing client2");
 
         assert_se(sd_event_new(&event) >= 0);
         assert_se(sd_bus_new(&bus) >= 0);
@@ -191,7 +191,7 @@ static void* thread_client2(void *p) {
 
         assert_se(sd_event_loop(event) >= 0);
 
-        log_debug("Client2 done");
+        log_info("Client2 done");
 
         return NULL;
 }
diff --git a/src/libsystemd/sd-device/device-enumerator.c b/src/libsystemd/sd-device/device-enumerator.c
index cd9ec042b..5d73e550c 100644
--- a/src/libsystemd/sd-device/device-enumerator.c
+++ b/src/libsystemd/sd-device/device-enumerator.c
@@ -598,7 +598,7 @@ static int enumerator_scan_dir(sd_device_enumerator *enumerator, const char *bas
         if (!dir)
                 return -errno;
 
-        log_debug("  device-enumerator: scanning %s", path);
+        log_info("  device-enumerator: scanning %s", path);
 
         FOREACH_DIRENT_ALL(dent, dir, return -errno) {
                 int k;
@@ -758,7 +758,7 @@ static int parent_crawl_children(sd_device_enumerator *enumerator, const char *p
 
         dir = opendir(path);
         if (!dir)
-                return log_debug_errno(errno, "sd-device-enumerate: could not open parent directory %s: %m", path);
+                return log_info_errno(errno, "sd-device-enumerate: could not open parent directory %s: %m", path);
 
         FOREACH_DIRENT_ALL(dent, dir, return -errno) {
                 _cleanup_free_ char *child = NULL;
@@ -781,7 +781,7 @@ static int parent_crawl_children(sd_device_enumerator *enumerator, const char *p
                 if (maxdepth > 0)
                         parent_crawl_children(enumerator, child, maxdepth - 1);
                 else
-                        log_debug("device-enumerate: max depth reached, %s: ignoring devices", child);
+                        log_info("device-enumerate: max depth reached, %s: ignoring devices", child);
         }
 
         return r;
@@ -809,25 +809,25 @@ static int enumerator_scan_devices_children(sd_device_enumerator *enumerator) {
 static int enumerator_scan_devices_all(sd_device_enumerator *enumerator) {
         int r = 0;
 
-        log_debug("device-enumerator: scan all dirs");
+        log_info("device-enumerator: scan all dirs");
 
         if (access("/sys/subsystem", F_OK) >= 0) {
                 /* we have /subsystem/, forget all the old stuff */
                 r = enumerator_scan_dir(enumerator, "subsystem", "devices", NULL);
                 if (r < 0)
-                        return log_debug_errno(r, "device-enumerator: failed to scan /sys/subsystem: %m");
+                        return log_info_errno(r, "device-enumerator: failed to scan /sys/subsystem: %m");
         } else {
                 int k;
 
                 k = enumerator_scan_dir(enumerator, "bus", "devices", NULL);
                 if (k < 0) {
-                        log_debug_errno(k, "device-enumerator: failed to scan /sys/bus: %m");
+                        log_info_errno(k, "device-enumerator: failed to scan /sys/bus: %m");
                         r = k;
                 }
 
                 k = enumerator_scan_dir(enumerator, "class", NULL, NULL);
                 if (k < 0) {
-                        log_debug_errno(k, "device-enumerator: failed to scan /sys/class: %m");
+                        log_info_errno(k, "device-enumerator: failed to scan /sys/class: %m");
                         r = k;
                 }
         }
@@ -911,7 +911,7 @@ int device_enumerator_scan_subsystems(sd_device_enumerator *enumerator) {
         if (match_subsystem(enumerator, "module")) {
                 k = enumerator_scan_dir_and_add_devices(enumerator, "module", NULL, NULL);
                 if (k < 0) {
-                        log_debug_errno(k, "device-enumerator: failed to scan modules: %m");
+                        log_info_errno(k, "device-enumerator: failed to scan modules: %m");
                         r = k;
                 }
         }
@@ -925,7 +925,7 @@ int device_enumerator_scan_subsystems(sd_device_enumerator *enumerator) {
         if (match_subsystem(enumerator, "subsystem")) {
                 k = enumerator_scan_dir_and_add_devices(enumerator, subsysdir, NULL, NULL);
                 if (k < 0) {
-                        log_debug_errno(k, "device-enumerator: failed to scan subsystems: %m");
+                        log_info_errno(k, "device-enumerator: failed to scan subsystems: %m");
                         r = k;
                 }
         }
@@ -934,7 +934,7 @@ int device_enumerator_scan_subsystems(sd_device_enumerator *enumerator) {
         if (match_subsystem(enumerator, "drivers")) {
                 k = enumerator_scan_dir(enumerator, subsysdir, "drivers", "drivers");
                 if (k < 0) {
-                        log_debug_errno(k, "device-enumerator: failed to scan drivers: %m");
+                        log_info_errno(k, "device-enumerator: failed to scan drivers: %m");
                         r = k;
                 }
         }
diff --git a/src/libsystemd/sd-device/device-private.c b/src/libsystemd/sd-device/device-private.c
index 77f0f4b2e..9dbf87bbb 100644
--- a/src/libsystemd/sd-device/device-private.c
+++ b/src/libsystemd/sd-device/device-private.c
@@ -134,7 +134,7 @@ static int handle_db_line(sd_device *device, char key, const char *value) {
 
                 break;
         default:
-                log_debug("device db: unknown key '%c'", key);
+                log_info("device db: unknown key '%c'", key);
         }
 
         return 0;
@@ -208,7 +208,7 @@ static int device_read_db(sd_device *device) {
                 if (r == -ENOENT)
                         return 0;
                 else
-                        return log_debug_errno(r, "sd-device: failed to read db '%s': %m", path);
+                        return log_info_errno(r, "sd-device: failed to read db '%s': %m", path);
         }
 
         /* devices with a database entry are initialized */
@@ -226,7 +226,7 @@ static int device_read_db(sd_device *device) {
                         break;
                 case KEY:
                         if (db[i] != ':') {
-                                log_debug("sd-device: ignoring invalid db entry with key '%c'", key);
+                                log_info("sd-device: ignoring invalid db entry with key '%c'", key);
 
                                 state = INVALID_LINE;
                         } else {
@@ -252,7 +252,7 @@ static int device_read_db(sd_device *device) {
                                 db[i] = '\0';
                                 r = handle_db_line(device, key, value);
                                 if (r < 0)
-                                        log_debug_errno(r, "sd-device: failed to handle db entry '%c:%s': %m", key, value);
+                                        log_info_errno(r, "sd-device: failed to handle db entry '%c:%s': %m", key, value);
 
                                 state = PRE_KEY;
                         }
@@ -386,43 +386,43 @@ static int device_amend(sd_device *device, const char *key, const char *value) {
                 /* the caller must verify or trust this data (e.g., if it comes from the kernel) */
                 r = device_set_syspath(device, path, false);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set syspath to '%s': %m", path);
+                        return log_info_errno(r, "sd-device: could not set syspath to '%s': %m", path);
         } else if (streq(key, "SUBSYSTEM")) {
                 r = device_set_subsystem(device, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set subsystem to '%s': %m", value);
+                        return log_info_errno(r, "sd-device: could not set subsystem to '%s': %m", value);
         } else if (streq(key, "DEVTYPE")) {
                 r = device_set_devtype(device, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set devtype to '%s': %m", value);
+                        return log_info_errno(r, "sd-device: could not set devtype to '%s': %m", value);
         } else if (streq(key, "DEVNAME")) {
                 r = device_set_devname(device, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set devname to '%s': %m", value);
+                        return log_info_errno(r, "sd-device: could not set devname to '%s': %m", value);
         } else if (streq(key, "USEC_INITIALIZED")) {
                 r = device_set_usec_initialized(device, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set usec-initialized to '%s': %m", value);
+                        return log_info_errno(r, "sd-device: could not set usec-initialized to '%s': %m", value);
         } else if (streq(key, "DRIVER")) {
                 r = device_set_driver(device, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set driver to '%s': %m", value);
+                        return log_info_errno(r, "sd-device: could not set driver to '%s': %m", value);
         } else if (streq(key, "IFINDEX")) {
                 r = device_set_ifindex(device, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set ifindex to '%s': %m", value);
+                        return log_info_errno(r, "sd-device: could not set ifindex to '%s': %m", value);
         } else if (streq(key, "DEVMODE")) {
                 r = device_set_devmode(device, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set devmode to '%s': %m", value);
+                        return log_info_errno(r, "sd-device: could not set devmode to '%s': %m", value);
         } else if (streq(key, "DEVUID")) {
                 r = device_set_devuid(device, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set devuid to '%s': %m", value);
+                        return log_info_errno(r, "sd-device: could not set devuid to '%s': %m", value);
         } else if (streq(key, "DEVGID")) {
                 r = device_set_devgid(device, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set devgid to '%s': %m", value);
+                        return log_info_errno(r, "sd-device: could not set devgid to '%s': %m", value);
         } else if (streq(key, "DEVLINKS")) {
                 const char *word, *state;
                 size_t l;
@@ -435,7 +435,7 @@ static int device_amend(sd_device *device, const char *key, const char *value) {
 
                         r = device_add_devlink(device, devlink);
                         if (r < 0)
-                                return log_debug_errno(r, "sd-device: could not add devlink '%s': %m", devlink);
+                                return log_info_errno(r, "sd-device: could not add devlink '%s': %m", devlink);
                 }
         } else if (streq(key, "TAGS")) {
                 const char *word, *state;
@@ -449,12 +449,12 @@ static int device_amend(sd_device *device, const char *key, const char *value) {
 
                         r = device_add_tag(device, tag);
                         if (r < 0)
-                                return log_debug_errno(r, "sd-device: could not add tag '%s': %m", tag);
+                                return log_info_errno(r, "sd-device: could not add tag '%s': %m", tag);
                 }
         } else {
                 r = device_add_property_internal(device, key, value);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not add property '%s=%s': %m", key, value);
+                        return log_info_errno(r, "sd-device: could not add property '%s=%s': %m", key, value);
         }
 
         return 0;
@@ -490,7 +490,7 @@ static int device_append(sd_device *device, char *key, const char **_major, cons
 
         value = strchr(key, '=');
         if (!value) {
-                log_debug("sd-device: not a key-value pair: '%s'", key);
+                log_info("sd-device: not a key-value pair: '%s'", key);
                 return -EINVAL;
         }
 
@@ -546,7 +546,7 @@ static int device_verify(sd_device *device, DeviceAction action, uint64_t seqnum
         assert(device);
 
         if (!device->devpath || !device->subsystem || action == _DEVICE_ACTION_INVALID || seqnum == 0) {
-                log_debug("sd-device: device created from strv lacks devpath, subsystem, action or seqnum");
+                log_info("sd-device: device created from strv lacks devpath, subsystem, action or seqnum");
                 return -EINVAL;
         }
 
@@ -579,7 +579,7 @@ int device_new_from_strv(sd_device **ret, char **strv) {
         if (major) {
                 r = device_set_devnum(device, major, minor);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set devnum %s:%s: %m", major, minor);
+                        return log_info_errno(r, "sd-device: could not set devnum %s:%s: %m", major, minor);
         }
 
         r = device_verify(device, action, seqnum);
@@ -615,7 +615,7 @@ int device_new_from_nulstr(sd_device **ret, uint8_t *nulstr, size_t len) {
                 key = (char*)&nulstr[i];
                 end = memchr(key, '\0', len - i);
                 if (!end) {
-                        log_debug("sd-device: failed to parse nulstr");
+                        log_info("sd-device: failed to parse nulstr");
                         return -EINVAL;
                 }
                 i += end - key + 1;
@@ -628,7 +628,7 @@ int device_new_from_nulstr(sd_device **ret, uint8_t *nulstr, size_t len) {
         if (major) {
                 r = device_set_devnum(device, major, minor);
                 if (r < 0)
-                        return log_debug_errno(r, "sd-device: could not set devnum %s:%s: %m", major, minor);
+                        return log_info_errno(r, "sd-device: could not set devnum %s:%s: %m", major, minor);
         }
 
         r = device_verify(device, action, seqnum);
@@ -1079,7 +1079,7 @@ int device_update_db(sd_device *device) {
                 goto fail;
         }
 
-        log_debug("created %s file '%s' for '%s'", has_info ? "db" : "empty",
+        log_info("created %s file '%s' for '%s'", has_info ? "db" : "empty",
                   path, device->devpath);
 
         return 0;
diff --git a/src/libsystemd/sd-device/sd-device.c b/src/libsystemd/sd-device/sd-device.c
index 1297dfa91..1310cd69f 100644
--- a/src/libsystemd/sd-device/sd-device.c
+++ b/src/libsystemd/sd-device/sd-device.c
@@ -161,7 +161,7 @@ int device_set_syspath(sd_device *device, const char *_syspath, bool verify) {
 
         /* must be a subdirectory of /sys */
         if (!path_startswith(_syspath, "/sys/")) {
-                log_debug("sd-device: syspath '%s' is not a subdirectory of /sys", _syspath);
+                log_info("sd-device: syspath '%s' is not a subdirectory of /sys", _syspath);
                 return -EINVAL;
         }
 
@@ -171,7 +171,7 @@ int device_set_syspath(sd_device *device, const char *_syspath, bool verify) {
                         /* the device does not exist (any more?) */
                         return -ENODEV;
                 else if (r < 0) {
-                        log_debug_errno(r, "sd-device: could not get target of '%s': %m", _syspath);
+                        log_info_errno(r, "sd-device: could not get target of '%s': %m", _syspath);
                         return r;
                 }
 
@@ -182,11 +182,11 @@ int device_set_syspath(sd_device *device, const char *_syspath, bool verify) {
                         /* /sys is a symlink to somewhere sysfs is mounted on? In that case, we convert the path to real sysfs to "/sys". */
                         r = chase_symlinks("/sys", NULL, 0, &real_sys);
                         if (r < 0)
-                                return log_debug_errno(r, "sd-device: could not chase symlink /sys: %m");
+                                return log_info_errno(r, "sd-device: could not chase symlink /sys: %m");
 
                         p = path_startswith(syspath, real_sys);
                         if (!p) {
-                                log_debug("sd-device: canonicalized path '%s' does not starts with sysfs mount point '%s'", syspath, real_sys);
+                                log_info("sd-device: canonicalized path '%s' does not starts with sysfs mount point '%s'", syspath, real_sys);
                                 return -ENODEV;
                         }
 
@@ -209,7 +209,7 @@ int device_set_syspath(sd_device *device, const char *_syspath, bool verify) {
                                         /* this is not a valid device */
                                         return -ENODEV;
 
-                                return log_debug_errno(errno, "sd-device: %s does not have an uevent file: %m", syspath);
+                                return log_info_errno(errno, "sd-device: %s does not have an uevent file: %m", syspath);
                         }
                 } else {
                         /* everything else just needs to be a directory */
@@ -540,7 +540,7 @@ int device_read_uevent_file(sd_device *device) {
                 /* some devices may not have uevent files, see set_syspath() */
                 return 0;
         else if (r < 0) {
-                log_debug_errno(r, "sd-device: failed to read uevent file '%s': %m", path);
+                log_info_errno(r, "sd-device: failed to read uevent file '%s': %m", path);
                 return r;
         }
 
@@ -561,7 +561,7 @@ int device_read_uevent_file(sd_device *device) {
                                 state = PRE_VALUE;
                         } else if (strchr(NEWLINE, uevent[i])) {
                                 uevent[i] = '\0';
-                                log_debug("sd-device: ignoring invalid uevent line '%s'", key);
+                                log_info("sd-device: ignoring invalid uevent line '%s'", key);
 
                                 state = PRE_KEY;
                         }
@@ -578,7 +578,7 @@ int device_read_uevent_file(sd_device *device) {
 
                                 r = handle_uevent_line(device, key, value, &major, &minor);
                                 if (r < 0)
-                                        log_debug_errno(r, "sd-device: failed to handle uevent entry '%s=%s': %m", key, value);
+                                        log_info_errno(r, "sd-device: failed to handle uevent entry '%s=%s': %m", key, value);
 
                                 state = PRE_KEY;
                         }
@@ -591,7 +591,7 @@ int device_read_uevent_file(sd_device *device) {
         if (major) {
                 r = device_set_devnum(device, major, minor);
                 if (r < 0)
-                        log_debug_errno(r, "sd-device: could not set 'MAJOR=%s' or 'MINOR=%s' from '%s': %m", major, minor, path);
+                        log_info_errno(r, "sd-device: could not set 'MAJOR=%s' or 'MINOR=%s' from '%s': %m", major, minor, path);
         }
 
         return 0;
@@ -825,7 +825,7 @@ _public_ int sd_device_get_subsystem(sd_device *device, const char **ret) {
                           path_startswith(device->devpath, "/bus/")))
                         r = device_set_subsystem(device, "subsystem");
                 if (r < 0 && r != -ENOENT)
-                        return log_debug_errno(r, "sd-device: could not set subsystem for %s: %m", device->devpath);
+                        return log_info_errno(r, "sd-device: could not set subsystem for %s: %m", device->devpath);
 
                 device->subsystem_set = true;
         } else if (!device->driver_subsystem_set)
@@ -848,7 +848,7 @@ _public_ int sd_device_get_subsystem(sd_device *device, const char **ret) {
                                         r = device_set_drivers_subsystem(device, subsys + 1);
                         }
                         if (r < 0 && r != -ENOENT)
-                                return log_debug_errno(r, "sd-device: could not set subsystem for driver %s: %m", device->devpath);
+                                return log_info_errno(r, "sd-device: could not set subsystem for driver %s: %m", device->devpath);
                 }
 
                 device->driver_subsystem_set = true;
@@ -965,11 +965,11 @@ _public_ int sd_device_get_driver(sd_device *device, const char **ret) {
                 if (r >= 0) {
                         r = device_set_driver(device, driver);
                         if (r < 0)
-                                return log_debug_errno(r, "sd-device: could not set driver for %s: %m", device->devpath);
+                                return log_info_errno(r, "sd-device: could not set driver for %s: %m", device->devpath);
                 } else if (r == -ENOENT)
                         device->driver_set = true;
                 else
-                        return log_debug_errno(r, "sd-device: could not set driver for %s: %m", device->devpath);
+                        return log_info_errno(r, "sd-device: could not set driver for %s: %m", device->devpath);
         }
 
         if (!device->driver)
@@ -1229,7 +1229,7 @@ static int handle_db_line(sd_device *device, char key, const char *value) {
 
                 break;
         default:
-                log_debug("device db: unknown key '%c'", key);
+                log_info("device db: unknown key '%c'", key);
         }
 
         return 0;
@@ -1339,7 +1339,7 @@ int device_read_db_aux(sd_device *device, bool force) {
                 if (r == -ENOENT)
                         return 0;
                 else
-                        return log_debug_errno(r, "sd-device: failed to read db '%s': %m", path);
+                        return log_info_errno(r, "sd-device: failed to read db '%s': %m", path);
         }
 
         /* devices with a database entry are initialized */
@@ -1357,7 +1357,7 @@ int device_read_db_aux(sd_device *device, bool force) {
                         break;
                 case KEY:
                         if (db[i] != ':') {
-                                log_debug("sd-device: ignoring invalid db entry with key '%c'", key);
+                                log_info("sd-device: ignoring invalid db entry with key '%c'", key);
 
                                 state = INVALID_LINE;
                         } else {
@@ -1383,7 +1383,7 @@ int device_read_db_aux(sd_device *device, bool force) {
                                 db[i] = '\0';
                                 r = handle_db_line(device, key, value);
                                 if (r < 0)
-                                        log_debug_errno(r, "sd-device: failed to handle db entry '%c:%s': %m", key, value);
+                                        log_info_errno(r, "sd-device: failed to handle db entry '%c:%s': %m", key, value);
 
                                 state = PRE_KEY;
                         }
diff --git a/src/libsystemd/sd-event/sd-event.c b/src/libsystemd/sd-event/sd-event.c
index cb9b3a454..6128c6262 100644
--- a/src/libsystemd/sd-event/sd-event.c
+++ b/src/libsystemd/sd-event/sd-event.c
@@ -458,7 +458,7 @@ _public_ int sd_event_new(sd_event** ret) {
         }
 
         if (secure_getenv("SD_EVENT_PROFILE_DELAYS")) {
-                log_debug("Event loop profiling enabled. Logarithmic histogram of event loop iterations in the range 2^0 ... 2^63 us will be logged every 5s.");
+                log_info("Event loop profiling enabled. Logarithmic histogram of event loop iterations in the range 2^0 ... 2^63 us will be logged every 5s.");
                 e->profile_delays = true;
         }
 
@@ -518,7 +518,7 @@ static void source_io_unregister(sd_event_source *s) {
 
         r = epoll_ctl(s->event->epoll_fd, EPOLL_CTL_DEL, s->io.fd, NULL);
         if (r < 0)
-                log_debug_errno(errno, "Failed to remove source %s (type %s) from epoll: %m",
+                log_info_errno(errno, "Failed to remove source %s (type %s) from epoll: %m",
                                 strna(s->description), event_source_type_to_string(s->type));
 
         s->io.registered = false;
@@ -746,7 +746,7 @@ static void event_unmask_signal_data(sd_event *e, struct signal_data *d, int sig
         assert(d->fd >= 0);
 
         if (signalfd(d->fd, &d->sigset, SFD_NONBLOCK|SFD_CLOEXEC) < 0)
-                log_debug_errno(errno, "Failed to unset signal bit, ignoring: %m");
+                log_info_errno(errno, "Failed to unset signal bit, ignoring: %m");
 }
 
 static void event_gc_signal_data(sd_event *e, const int64_t *priority, int sig) {
@@ -2350,7 +2350,7 @@ static int source_dispatch(sd_event_source *s) {
         s->dispatching = false;
 
         if (r < 0)
-                log_debug_errno(r, "Event source %s (type %s) returned error, disabling: %m",
+                log_info_errno(r, "Event source %s (type %s) returned error, disabling: %m",
                                 strna(s->description), event_source_type_to_string(saved_type));
 
         if (s->n_ref == 0)
@@ -2385,7 +2385,7 @@ static int event_prepare(sd_event *e) {
                 s->dispatching = false;
 
                 if (r < 0)
-                        log_debug_errno(r, "Prepare callback of event source %s (type %s) returned error, disabling: %m",
+                        log_info_errno(r, "Prepare callback of event source %s (type %s) returned error, disabling: %m",
                                         strna(s->description), event_source_type_to_string(s->type));
 
                 if (s->n_ref == 0)
@@ -2682,7 +2682,7 @@ static void event_log_delays(sd_event *e) {
                 o += snprintf(&b[o], sizeof(b) - o, "%u ", e->delays[i]);
                 e->delays[i] = 0;
         }
-        log_debug("Event loop iterations: %.*s", o, b);
+        log_info("Event loop iterations: %.*s", o, b);
 }
 
 _public_ int sd_event_run(sd_event *e, uint64_t timeout) {
diff --git a/src/libsystemd/sd-hwdb/sd-hwdb.c b/src/libsystemd/sd-hwdb/sd-hwdb.c
index 9418e8cf3..4f8d1aa9f 100644
--- a/src/libsystemd/sd-hwdb/sd-hwdb.c
+++ b/src/libsystemd/sd-hwdb/sd-hwdb.c
@@ -344,34 +344,34 @@ _public_ int sd_hwdb_new(sd_hwdb **ret) {
                 else if (errno == ENOENT)
                         continue;
                 else
-                        return log_debug_errno(errno, "error reading %s: %m", hwdb_bin_path);
+                        return log_info_errno(errno, "error reading %s: %m", hwdb_bin_path);
         }
 
         if (!hwdb->f) {
-                log_debug("hwdb.bin does not exist, please run systemd-hwdb update");
+                log_info("hwdb.bin does not exist, please run systemd-hwdb update");
                 return -ENOENT;
         }
 
         if (fstat(fileno(hwdb->f), &hwdb->st) < 0 ||
             (size_t)hwdb->st.st_size < offsetof(struct trie_header_f, strings_len) + 8)
-                return log_debug_errno(errno, "error reading %s: %m", hwdb_bin_path);
+                return log_info_errno(errno, "error reading %s: %m", hwdb_bin_path);
 
         hwdb->map = mmap(0, hwdb->st.st_size, PROT_READ, MAP_SHARED, fileno(hwdb->f), 0);
         if (hwdb->map == MAP_FAILED)
-                return log_debug_errno(errno, "error mapping %s: %m", hwdb_bin_path);
+                return log_info_errno(errno, "error mapping %s: %m", hwdb_bin_path);
 
         if (memcmp(hwdb->map, sig, sizeof(hwdb->head->signature)) != 0 ||
             (size_t)hwdb->st.st_size != le64toh(hwdb->head->file_size)) {
-                log_debug("error recognizing the format of %s", hwdb_bin_path);
+                log_info("error recognizing the format of %s", hwdb_bin_path);
                 return -EINVAL;
         }
 
-        log_debug("=== trie on-disk ===");
-        log_debug("tool version:          %"PRIu64, le64toh(hwdb->head->tool_version));
-        log_debug("file size:        %8"PRIi64" bytes", hwdb->st.st_size);
-        log_debug("header size       %8"PRIu64" bytes", le64toh(hwdb->head->header_size));
-        log_debug("strings           %8"PRIu64" bytes", le64toh(hwdb->head->strings_len));
-        log_debug("nodes             %8"PRIu64" bytes", le64toh(hwdb->head->nodes_len));
+        log_info("=== trie on-disk ===");
+        log_info("tool version:          %"PRIu64, le64toh(hwdb->head->tool_version));
+        log_info("file size:        %8"PRIi64" bytes", hwdb->st.st_size);
+        log_info("header size       %8"PRIu64" bytes", le64toh(hwdb->head->header_size));
+        log_info("strings           %8"PRIu64" bytes", le64toh(hwdb->head->strings_len));
+        log_info("nodes             %8"PRIu64" bytes", le64toh(hwdb->head->nodes_len));
 
         *ret = hwdb;
         hwdb = NULL;
diff --git a/src/libsystemd/sd-netlink/netlink-message.c b/src/libsystemd/sd-netlink/netlink-message.c
index af3d13edc..8428ce49f 100644
--- a/src/libsystemd/sd-netlink/netlink-message.c
+++ b/src/libsystemd/sd-netlink/netlink-message.c
@@ -796,7 +796,7 @@ static int netlink_container_parse(sd_netlink_message *m,
                         continue;
 
                 if (attributes[type].offset != 0)
-                        log_debug("rtnl: message parse - overwriting repeated attribute");
+                        log_info("rtnl: message parse - overwriting repeated attribute");
 
                 attributes[type].offset = (uint8_t *) rta - (uint8_t *) m->hdr;
                 attributes[type].nested = RTA_FLAGS(rta) & NLA_F_NESTED;
diff --git a/src/libsystemd/sd-netlink/netlink-socket.c b/src/libsystemd/sd-netlink/netlink-socket.c
index e08248c9f..afdebb355 100644
--- a/src/libsystemd/sd-netlink/netlink-socket.c
+++ b/src/libsystemd/sd-netlink/netlink-socket.c
@@ -278,16 +278,16 @@ static int socket_recv_message(int fd, struct iovec *iov, uint32_t *_group, bool
         if (n < 0) {
                 /* no data */
                 if (errno == ENOBUFS)
-                        log_debug("rtnl: kernel receive buffer overrun");
+                        log_info("rtnl: kernel receive buffer overrun");
                 else if (errno == EAGAIN)
-                        log_debug("rtnl: no data in socket");
+                        log_info("rtnl: no data in socket");
 
                 return IN_SET(errno, EAGAIN, EINTR) ? 0 : -errno;
         }
 
         if (sender.nl.nl_pid != 0) {
                 /* not from the kernel, ignore */
-                log_debug("rtnl: ignoring message from portid %"PRIu32, sender.nl.nl_pid);
+                log_info("rtnl: ignoring message from portid %"PRIu32, sender.nl.nl_pid);
 
                 if (peek) {
                         /* drop the message */
@@ -402,7 +402,7 @@ int socket_read_message(sd_netlink *rtnl) {
                 r = type_system_get_type(type_system_root, &nl_type, new_msg->nlmsg_type);
                 if (r < 0) {
                         if (r == -EOPNOTSUPP)
-                                log_debug("sd-netlink: ignored message with unknown type: %i",
+                                log_info("sd-netlink: ignored message with unknown type: %i",
                                           new_msg->nlmsg_type);
 
                         continue;
@@ -410,7 +410,7 @@ int socket_read_message(sd_netlink *rtnl) {
 
                 /* check that the size matches the message type */
                 if (new_msg->nlmsg_len < NLMSG_LENGTH(type_get_size(nl_type))) {
-                        log_debug("sd-netlink: message larger than expected, dropping");
+                        log_info("sd-netlink: message larger than expected, dropping");
                         continue;
                 }
 
@@ -437,7 +437,7 @@ int socket_read_message(sd_netlink *rtnl) {
         }
 
         if (len > 0)
-                log_debug("sd-netlink: discarding %zu bytes of incoming message", len);
+                log_info("sd-netlink: discarding %zu bytes of incoming message", len);
 
         if (!first)
                 return 0;
diff --git a/src/libsystemd/sd-netlink/sd-netlink.c b/src/libsystemd/sd-netlink/sd-netlink.c
index 116e287bb..7352dd1fa 100644
--- a/src/libsystemd/sd-netlink/sd-netlink.c
+++ b/src/libsystemd/sd-netlink/sd-netlink.c
@@ -258,7 +258,7 @@ int rtnl_rqueue_make_room(sd_netlink *rtnl) {
         assert(rtnl);
 
         if (rtnl->rqueue_size >= RTNL_RQUEUE_MAX) {
-                log_debug("rtnl: exhausted the read queue size (%d)", RTNL_RQUEUE_MAX);
+                log_info("rtnl: exhausted the read queue size (%d)", RTNL_RQUEUE_MAX);
                 return -ENOBUFS;
         }
 
@@ -272,7 +272,7 @@ int rtnl_rqueue_partial_make_room(sd_netlink *rtnl) {
         assert(rtnl);
 
         if (rtnl->rqueue_partial_size >= RTNL_RQUEUE_MAX) {
-                log_debug("rtnl: exhausted the partial read queue size (%d)", RTNL_RQUEUE_MAX);
+                log_info("rtnl: exhausted the partial read queue size (%d)", RTNL_RQUEUE_MAX);
                 return -ENOBUFS;
         }
 
@@ -293,7 +293,7 @@ static int dispatch_rqueue(sd_netlink *rtnl, sd_netlink_message **message) {
                 /* Try to read a new message */
                 r = socket_read_message(rtnl);
                 if (r == -ENOBUFS) { /* FIXME: ignore buffer overruns for now */
-                        log_debug_errno(r, "Got ENOBUFS from netlink socket, ignoring.");
+                        log_info_errno(r, "Got ENOBUFS from netlink socket, ignoring.");
                         return 1;
                 }
                 if (r <= 0)
@@ -333,7 +333,7 @@ static int process_timeout(sd_netlink *rtnl) {
 
         r = c->callback(rtnl, m, c->userdata);
         if (r < 0)
-                log_debug_errno(r, "sd-netlink: timedout callback failed: %m");
+                log_info_errno(r, "sd-netlink: timedout callback failed: %m");
 
         free(c);
 
@@ -366,7 +366,7 @@ static int process_reply(sd_netlink *rtnl, sd_netlink_message *m) {
 
         r = c->callback(rtnl, m, c->userdata);
         if (r < 0)
-                log_debug_errno(r, "sd-netlink: callback failed: %m");
+                log_info_errno(r, "sd-netlink: callback failed: %m");
 
         return 1;
 }
@@ -388,7 +388,7 @@ static int process_match(sd_netlink *rtnl, sd_netlink_message *m) {
                         r = c->callback(rtnl, m, c->userdata);
                         if (r != 0) {
                                 if (r < 0)
-                                        log_debug_errno(r, "sd-netlink: match callback failed: %m");
+                                        log_info_errno(r, "sd-netlink: match callback failed: %m");
 
                                 break;
                         }
diff --git a/src/libudev/libudev-monitor.c b/src/libudev/libudev-monitor.c
index ca14373e1..b24a43bf0 100644
--- a/src/libudev/libudev-monitor.c
+++ b/src/libudev/libudev-monitor.c
@@ -121,7 +121,7 @@ static bool udev_has_devtmpfs(struct udev *udev) {
         r = path_get_mnt_id("/dev", &mount_id);
         if (r < 0) {
                 if (r != -EOPNOTSUPP)
-                        log_debug_errno(r, "name_to_handle_at on /dev: %m");
+                        log_info_errno(r, "name_to_handle_at on /dev: %m");
 
                 return false;
         }
@@ -192,7 +192,7 @@ struct udev_monitor *udev_monitor_new_from_netlink_fd(struct udev *udev, const c
                  * will not receive any messages.
                  */
                 if (access("/run/udev/control", F_OK) < 0 && !udev_has_devtmpfs(udev)) {
-                        log_debug("the udev service seems not to be active, disable the monitor");
+                        log_info("the udev service seems not to be active, disable the monitor");
                         group = UDEV_MONITOR_NONE;
                 } else
                         group = UDEV_MONITOR_UDEV;
@@ -210,7 +210,7 @@ struct udev_monitor *udev_monitor_new_from_netlink_fd(struct udev *udev, const c
         if (fd < 0) {
                 udev_monitor->sock = socket(PF_NETLINK, SOCK_RAW|SOCK_CLOEXEC|SOCK_NONBLOCK, NETLINK_KOBJECT_UEVENT);
                 if (udev_monitor->sock < 0) {
-                        log_debug_errno(errno, "error getting socket: %m");
+                        log_info_errno(errno, "error getting socket: %m");
                         return mfree(udev_monitor);
                 }
         } else {
@@ -417,12 +417,12 @@ _public_ int udev_monitor_enable_receiving(struct udev_monitor *udev_monitor)
         if (err >= 0)
                 monitor_set_nl_address(udev_monitor);
         else
-                return log_debug_errno(errno, "bind failed: %m");
+                return log_info_errno(errno, "bind failed: %m");
 
         /* enable receiving of sender credentials */
         err = setsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));
         if (err < 0)
-                log_debug_errno(errno, "setting SO_PASSCRED failed: %m");
+                log_info_errno(errno, "setting SO_PASSCRED failed: %m");
 
         return 0;
 }
@@ -618,12 +618,12 @@ retry:
         buflen = recvmsg(udev_monitor->sock, &smsg, 0);
         if (buflen < 0) {
                 if (errno != EINTR)
-                        log_debug("unable to receive message");
+                        log_info("unable to receive message");
                 return NULL;
         }
 
         if (buflen < 32 || (smsg.msg_flags & MSG_TRUNC)) {
-                log_debug("invalid message length");
+                log_info("invalid message length");
                 errno = EINVAL;
                 return NULL;
         }
@@ -632,13 +632,13 @@ retry:
                 /* unicast message, check if we trust the sender */
                 if (udev_monitor->snl_trusted_sender.nl.nl_pid == 0 ||
                     snl.nl.nl_pid != udev_monitor->snl_trusted_sender.nl.nl_pid) {
-                        log_debug("unicast netlink message ignored");
+                        log_info("unicast netlink message ignored");
                         errno = EAGAIN;
                         return NULL;
                 }
         } else if (snl.nl.nl_groups == UDEV_MONITOR_KERNEL) {
                 if (snl.nl.nl_pid > 0) {
-                        log_debug("multicast kernel netlink message from PID %"PRIu32" ignored",
+                        log_info("multicast kernel netlink message from PID %"PRIu32" ignored",
                                   snl.nl.nl_pid);
                         errno = EAGAIN;
                         return NULL;
@@ -647,14 +647,14 @@ retry:
 
         cmsg = CMSG_FIRSTHDR(&smsg);
         if (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {
-                log_debug("no sender credentials received, message ignored");
+                log_info("no sender credentials received, message ignored");
                 errno = EAGAIN;
                 return NULL;
         }
 
         cred = (struct ucred *)CMSG_DATA(cmsg);
         if (cred->uid != 0) {
-                log_debug("sender uid="UID_FMT", message ignored", cred->uid);
+                log_info("sender uid="UID_FMT", message ignored", cred->uid);
                 errno = EAGAIN;
                 return NULL;
         }
@@ -662,13 +662,13 @@ retry:
         if (memcmp(buf.raw, "libudev", 8) == 0) {
                 /* udev message needs proper version magic */
                 if (buf.nlh.magic != htobe32(UDEV_MONITOR_MAGIC)) {
-                        log_debug("unrecognized message signature (%x != %x)",
+                        log_info("unrecognized message signature (%x != %x)",
                                  buf.nlh.magic, htobe32(UDEV_MONITOR_MAGIC));
                         errno = EAGAIN;
                         return NULL;
                 }
                 if (buf.nlh.properties_off+32 > (size_t)buflen) {
-                        log_debug("message smaller than expected (%u > %zd)",
+                        log_info("message smaller than expected (%u > %zd)",
                                   buf.nlh.properties_off+32, buflen);
                         errno = EAGAIN;
                         return NULL;
@@ -682,14 +682,14 @@ retry:
                 /* kernel message with header */
                 bufpos = strlen(buf.raw) + 1;
                 if ((size_t)bufpos < sizeof("a@/d") || bufpos >= buflen) {
-                        log_debug("invalid message length");
+                        log_info("invalid message length");
                         errno = EAGAIN;
                         return NULL;
                 }
 
                 /* check message header */
                 if (strstr(buf.raw, "@/") == NULL) {
-                        log_debug("unrecognized message header");
+                        log_info("unrecognized message header");
                         errno = EAGAIN;
                         return NULL;
                 }
@@ -697,7 +697,7 @@ retry:
 
         udev_device = udev_device_new_from_nulstr(udev_monitor->udev, &buf.raw[bufpos], buflen - bufpos);
         if (!udev_device) {
-                log_debug_errno(errno, "could not create device: %m");
+                log_info_errno(errno, "could not create device: %m");
                 return NULL;
         }
 
@@ -747,7 +747,7 @@ int udev_monitor_send_device(struct udev_monitor *udev_monitor,
 
         blen = udev_device_get_properties_monitor_buf(udev_device, &buf);
         if (blen < 32) {
-                log_debug("device buffer is too small to contain a valid device");
+                log_info("device buffer is too small to contain a valid device");
                 return -EINVAL;
         }
 
@@ -788,13 +788,13 @@ int udev_monitor_send_device(struct udev_monitor *udev_monitor,
         count = sendmsg(udev_monitor->sock, &smsg, 0);
         if (count < 0) {
                 if (!destination && errno == ECONNREFUSED) {
-                        log_debug("passed device to netlink monitor %p", udev_monitor);
+                        log_info("passed device to netlink monitor %p", udev_monitor);
                         return 0;
                 } else
                         return -errno;
         }
 
-        log_debug("passed %zi byte device to netlink monitor %p", count, udev_monitor);
+        log_info("passed %zi byte device to netlink monitor %p", count, udev_monitor);
         return count;
 }
 
diff --git a/src/libudev/libudev-util.c b/src/libudev/libudev-util.c
index 977caad86..dceb4bcdd 100644
--- a/src/libudev/libudev-util.c
+++ b/src/libudev/libudev-util.c
@@ -88,7 +88,7 @@ int util_resolve_subsys_kernel(struct udev *udev, const char *string,
                         strscpy(result, maxsize, val);
                 else
                         result[0] = '\0';
-                log_debug("value '[%s/%s]%s' is '%s'", subsys, sysname, attr, result);
+                log_info("value '[%s/%s]%s' is '%s'", subsys, sysname, attr, result);
         } else {
                 size_t l;
                 char *s;
@@ -97,7 +97,7 @@ int util_resolve_subsys_kernel(struct udev *udev, const char *string,
                 l = strpcpyl(&s, maxsize, udev_device_get_syspath(dev), NULL);
                 if (attr != NULL)
                         strpcpyl(&s, l, "/", attr, NULL);
-                log_debug("path '[%s/%s]%s' is '%s'", subsys, sysname, attr, result);
+                log_info("path '[%s/%s]%s' is '%s'", subsys, sysname, attr, result);
         }
         udev_device_unref(dev);
         return 0;
diff --git a/src/locale/keymap-util.c b/src/locale/keymap-util.c
index 2d788106b..9e957aecb 100644
--- a/src/locale/keymap-util.c
+++ b/src/locale/keymap-util.c
@@ -509,7 +509,7 @@ int vconsole_convert_to_x11(Context *c) {
                 log_notice("X11 keyboard layout was not modified: no conversion found for \"%s\".",
                            c->vc_keymap);
         else
-                log_debug("X11 keyboard layout did not need to be modified.");
+                log_info("X11 keyboard layout did not need to be modified.");
 
         return modified > 0;
 }
@@ -536,7 +536,7 @@ int find_converted_keymap(const char *x11_layout, const char *x11_variant, char
 
                 uncompressed = access(p, F_OK) == 0;
                 if (uncompressed || access(pz, F_OK) == 0) {
-                        log_debug("Found converted keymap %s at %s",
+                        log_info("Found converted keymap %s at %s",
                                   n, uncompressed ? p : pz);
 
                         *new_keymap = n;
@@ -609,7 +609,7 @@ int find_legacy_keymap(Context *c, char **new_keymap) {
 
                 /* The best matching entry so far, then let's save that */
                 if (matching >= MAX(best_matching, 1u)) {
-                        log_debug("Found legacy keymap %s with score %u",
+                        log_info("Found legacy keymap %s with score %u",
                                   a[0], matching);
 
                         if (matching > best_matching) {
@@ -718,7 +718,7 @@ int x11_convert_to_vconsole(Context *c) {
                 log_info("Changing virtual console keymap to '%s' toggle '%s'",
                          strempty(c->vc_keymap), strempty(c->vc_keymap_toggle));
         else
-                log_debug("Virtual console keymap was not modified.");
+                log_info("Virtual console keymap was not modified.");
 
         return modified;
 }
diff --git a/src/locale/localed.c b/src/locale/localed.c
index 02f5e8c65..346053c19 100644
--- a/src/locale/localed.c
+++ b/src/locale/localed.c
@@ -269,7 +269,7 @@ static int method_set_locale(sd_bus_message *m, void *userdata, sd_bus_error *er
 
                 (void) find_language_fallback(lang, &language);
                 if (language) {
-                        log_debug("Converted LANG=%s to LANGUAGE=%s", lang, language);
+                        log_info("Converted LANG=%s to LANGUAGE=%s", lang, language);
                         if (!streq_ptr(language, c->locale[VARIABLE_LANGUAGE])) {
                                 r = strv_extendf(&l, "LANGUAGE=%s", language);
                                 if (r < 0)
@@ -354,7 +354,7 @@ static int method_set_locale(sd_bus_message *m, void *userdata, sd_bus_error *er
                                 "org.freedesktop.locale1",
                                 "Locale", NULL);
         } else
-                log_debug("Locale settings were not modified.");
+                log_info("Locale settings were not modified.");
 
 
         return sd_bus_reply_method_return(m, NULL);
diff --git a/src/login/logind-acl.c b/src/login/logind-acl.c
index d785f67ca..53c4bb1e8 100644
--- a/src/login/logind-acl.c
+++ b/src/login/logind-acl.c
@@ -245,7 +245,7 @@ int devnode_acl_all(struct udev *udev,
                 if (!n)
                         return -ENOMEM;
 
-                log_debug("Found udev node %s for seat %s", n, seat);
+                log_info("Found udev node %s for seat %s", n, seat);
                 r = set_consume(nodes, n);
                 if (r < 0)
                         return r;
@@ -265,7 +265,7 @@ int devnode_acl_all(struct udev *udev,
                         if (!n)
                                 return -ENOMEM;
 
-                        log_debug("Found static node %s for seat %s", n, seat);
+                        log_info("Found static node %s for seat %s", n, seat);
                         r = set_consume(nodes, n);
                         if (r == -EEXIST)
                                 continue;
@@ -278,13 +278,13 @@ int devnode_acl_all(struct udev *udev,
         SET_FOREACH(n, nodes, i) {
                 int k;
 
-                log_debug("Changing ACLs at %s for seat %s (uid "UID_FMT"→"UID_FMT"%s%s)",
+                log_info("Changing ACLs at %s for seat %s (uid "UID_FMT"→"UID_FMT"%s%s)",
                           n, seat, old_uid, new_uid,
                           del ? " del" : "", add ? " add" : "");
 
                 k = devnode_acl(n, flush, del, old_uid, add, new_uid);
                 if (k == -ENOENT)
-                        log_debug("Device %s disappeared while setting ACLs", n);
+                        log_info("Device %s disappeared while setting ACLs", n);
                 else if (k < 0 && r == 0)
                         r = k;
         }
diff --git a/src/login/logind-action.c b/src/login/logind-action.c
index 852ea9f94..d894fdaac 100644
--- a/src/login/logind-action.c
+++ b/src/login/logind-action.c
@@ -70,7 +70,7 @@ int manager_handle_action(
 
         /* If the key handling is turned off, don't do anything */
         if (handle == HANDLE_IGNORE) {
-                log_debug("Refusing operation, as it is turned off.");
+                log_info("Refusing operation, as it is turned off.");
                 return 0;
         }
 
@@ -80,7 +80,7 @@ int manager_handle_action(
                  * stations some time to settle so that we can
                  * properly watch its displays. */
                 if (m->lid_switch_ignore_event_source) {
-                        log_debug("Ignoring lid switch request, system startup or resume too close.");
+                        log_info("Ignoring lid switch request, system startup or resume too close.");
                         return 0;
                 }
         }
@@ -88,7 +88,7 @@ int manager_handle_action(
         /* If the key handling is inhibited, don't do anything */
         if (inhibit_key > 0) {
                 if (manager_is_inhibited(m, inhibit_key, INHIBIT_BLOCK, NULL, true, false, 0, NULL)) {
-                        log_debug("Refusing operation, %s is inhibited.", inhibit_what_to_string(inhibit_key));
+                        log_info("Refusing operation, %s is inhibited.", inhibit_what_to_string(inhibit_key));
                         return 0;
                 }
         }
@@ -121,7 +121,7 @@ int manager_handle_action(
         }
 
         if (m->action_what) {
-                log_debug("Action already in progress, ignoring.");
+                log_info("Action already in progress, ignoring.");
                 return -EALREADY;
         }
 
@@ -137,7 +137,7 @@ int manager_handle_action(
 
                 /* If this is just a recheck of the lid switch then don't warn about anything */
                 if (!is_edge) {
-                        log_debug("Refusing operation, %s is inhibited by UID "UID_FMT"/%s, PID "PID_FMT"/%s.",
+                        log_info("Refusing operation, %s is inhibited by UID "UID_FMT"/%s, PID "PID_FMT"/%s.",
                                   inhibit_what_to_string(inhibit_operation),
                                   offending->uid, strna(u),
                                   offending->pid, strna(comm));
diff --git a/src/login/logind-button.c b/src/login/logind-button.c
index 94945f0bc..2c4bc8420 100644
--- a/src/login/logind-button.c
+++ b/src/login/logind-button.c
@@ -351,7 +351,7 @@ int button_open(Button *b) {
         if (r < 0)
                 return log_warning_errno(r, "Failed to determine whether input device is relevant to us: %m");
         if (r == 0) {
-                log_debug("Device %s does not expose keys or switches relevant to us, ignoring.", p);
+                log_info("Device %s does not expose keys or switches relevant to us, ignoring.", p);
                 return -EADDRNOTAVAIL;
         }
 
diff --git a/src/login/logind-core.c b/src/login/logind-core.c
index e338682f4..b510ba570 100644
--- a/src/login/logind-core.c
+++ b/src/login/logind-core.c
@@ -586,7 +586,7 @@ bool manager_is_docked_or_external_displays(Manager *m) {
 
         /* If we are docked don't react to lid closing */
         if (manager_is_docked(m)) {
-                log_debug("System is docked.");
+                log_info("System is docked.");
                 return true;
         }
 
@@ -596,7 +596,7 @@ bool manager_is_docked_or_external_displays(Manager *m) {
         if (n < 0)
                 log_warning_errno(n, "Display counting failed: %m");
         else if (n >= 1) {
-                log_debug("External (%i) displays connected.", n);
+                log_info("External (%i) displays connected.", n);
                 return true;
         }
 
diff --git a/src/login/logind-dbus.c b/src/login/logind-dbus.c
index ae36ececb..7752bee6d 100644
--- a/src/login/logind-dbus.c
+++ b/src/login/logind-dbus.c
@@ -2886,7 +2886,7 @@ int match_reloading(sd_bus_message *message, void *userdata, sd_bus_error *error
                 return 0;
 
         /* systemd finished reloading, let's recheck all our sessions */
-        log_debug("System manager has been reloaded, rechecking sessions...");
+        log_info("System manager has been reloaded, rechecking sessions...");
 
         HASHMAP_FOREACH(session, m->sessions, i)
                 session_add_to_gc_queue(session);
diff --git a/src/login/logind-inhibit.c b/src/login/logind-inhibit.c
index e14835292..e2ce051c8 100644
--- a/src/login/logind-inhibit.c
+++ b/src/login/logind-inhibit.c
@@ -163,7 +163,7 @@ int inhibitor_start(Inhibitor *i) {
 
         dual_timestamp_get(&i->since);
 
-        log_debug("Inhibitor %s (%s) pid="PID_FMT" uid="UID_FMT" mode=%s started.",
+        log_info("Inhibitor %s (%s) pid="PID_FMT" uid="UID_FMT" mode=%s started.",
                   strna(i->who), strna(i->why),
                   i->pid, i->uid,
                   inhibit_mode_to_string(i->mode));
@@ -181,7 +181,7 @@ int inhibitor_stop(Inhibitor *i) {
         assert(i);
 
         if (i->started)
-                log_debug("Inhibitor %s (%s) pid="PID_FMT" uid="UID_FMT" mode=%s stopped.",
+                log_info("Inhibitor %s (%s) pid="PID_FMT" uid="UID_FMT" mode=%s stopped.",
                           strna(i->who), strna(i->why),
                           i->pid, i->uid,
                           inhibit_mode_to_string(i->mode));
diff --git a/src/login/logind-seat.c b/src/login/logind-seat.c
index b99e7abf9..6f2c1e73d 100644
--- a/src/login/logind-seat.c
+++ b/src/login/logind-seat.c
@@ -195,7 +195,7 @@ int seat_preallocate_vts(Seat *s) {
         assert(s);
         assert(s->manager);
 
-        log_debug("Preallocating VTs...");
+        log_info("Preallocating VTs...");
 
         if (s->manager->n_autovts <= 0)
                 return 0;
@@ -345,7 +345,7 @@ int seat_active_vt_changed(Seat *s, unsigned int vtnr) {
         if (!seat_has_vts(s))
                 return -EINVAL;
 
-        log_debug("VT changed to %u", vtnr);
+        log_info("VT changed to %u", vtnr);
 
         /* we might have earlier closing sessions on the same VT, so try to
          * find a running one first */
diff --git a/src/login/logind-session-dbus.c b/src/login/logind-session-dbus.c
index 8264a42fd..b8b7928c6 100644
--- a/src/login/logind-session-dbus.c
+++ b/src/login/logind-session-dbus.c
@@ -777,7 +777,7 @@ int session_send_create_reply(Session *s, sd_bus_error *error) {
         if (!p)
                 return -ENOMEM;
 
-        log_debug("Sending reply about created session: "
+        log_info("Sending reply about created session: "
                   "id=%s object_path=%s uid=%u runtime_path=%s "
                   "session_fd=%d seat=%s vtnr=%u",
                   s->id,
diff --git a/src/login/logind-session.c b/src/login/logind-session.c
index 92eb2943f..488de44c7 100644
--- a/src/login/logind-session.c
+++ b/src/login/logind-session.c
@@ -1186,7 +1186,7 @@ void session_leave_vt(Session *s) {
         session_device_pause_all(s);
         r = ioctl(s->vtfd, VT_RELDISP, 1);
         if (r < 0)
-                log_debug_errno(errno, "Cannot release VT of session %s: %m", s->id);
+                log_info_errno(errno, "Cannot release VT of session %s: %m", s->id);
 }
 
 bool session_is_controller(Session *s, const char *sender) {
diff --git a/src/login/logind-user.c b/src/login/logind-user.c
index 32b204569..8c337dcad 100644
--- a/src/login/logind-user.c
+++ b/src/login/logind-user.c
@@ -359,7 +359,7 @@ static int user_mkdir_runtime_path(User *u) {
                                 goto fail;
                         }
 
-                        log_debug_errno(errno, "Failed to mount per-user tmpfs directory %s, assuming containerized execution, ignoring: %m", u->runtime_path);
+                        log_info_errno(errno, "Failed to mount per-user tmpfs directory %s, assuming containerized execution, ignoring: %m", u->runtime_path);
 
                         r = chmod_and_chown(u->runtime_path, 0700, u->uid, u->gid);
                         if (r < 0) {
@@ -458,7 +458,7 @@ int user_start(User *u) {
         u->stopping = false;
 
         if (!u->started) {
-                log_debug("Starting services for new user %s.", u->name);
+                log_info("Starting services for new user %s.", u->name);
 
                 /* Make XDG_RUNTIME_DIR */
                 r = user_mkdir_runtime_path(u);
@@ -595,7 +595,7 @@ int user_finalize(User *u) {
         assert(u);
 
         if (u->started)
-                log_debug("User %s logged out.", u->name);
+                log_info("User %s logged out.", u->name);
 
         LIST_FOREACH(sessions_by_user, s, u->sessions) {
                 k = session_finalize(s);
@@ -804,16 +804,16 @@ void user_elect_display(User *u) {
         /* This elects a primary session for each user, which we call
          * the "display". We try to keep the assignment stable, but we
          * "upgrade" to better choices. */
-        log_debug("Electing new display for user %s", u->name);
+        log_info("Electing new display for user %s", u->name);
 
         LIST_FOREACH(sessions_by_user, s, u->sessions) {
                 if (!elect_display_filter(s)) {
-                        log_debug("Ignoring session %s", s->id);
+                        log_info("Ignoring session %s", s->id);
                         continue;
                 }
 
                 if (elect_display_compare(s, u->display) < 0) {
-                        log_debug("Choosing session %s in preference to %s", s->id, u->display ? u->display->id : "-");
+                        log_info("Choosing session %s in preference to %s", s->id, u->display ? u->display->id : "-");
                         u->display = s;
                 }
         }
diff --git a/src/login/logind.c b/src/login/logind.c
index d15d4cec5..0f5817de8 100644
--- a/src/login/logind.c
+++ b/src/login/logind.c
@@ -440,7 +440,7 @@ static int manager_attach_fds(Manager *m) {
                         /* If the session doesn't exist anymore, the associated session
                          * device attached to this fd doesn't either. Let's simply close
                          * this fd. */
-                        log_debug("Failed to attach fd for unknown session: %s", id);
+                        log_info("Failed to attach fd for unknown session: %s", id);
                         close_nointr(fd);
                         continue;
                 }
@@ -448,7 +448,7 @@ static int manager_attach_fds(Manager *m) {
                 if (fstat(fd, &st) < 0) {
                         /* The device is allowed to go away at a random point, in which
                          * case fstat failing is expected. */
-                        log_debug_errno(errno, "Failed to stat device fd for session %s: %m", id);
+                        log_info_errno(errno, "Failed to stat device fd for session %s: %m", id);
                         close_nointr(fd);
                         continue;
                 }
@@ -463,7 +463,7 @@ static int manager_attach_fds(Manager *m) {
                         continue;
                 }
 
-                log_debug("Attaching fd to session device [%u:%u] for session %s",
+                log_info("Attaching fd to session device [%u:%u] for session %s",
                           major(st.st_rdev), minor(st.st_rdev), s->id);
 
                 session_device_attach_fd(sd, fd, s->was_active);
@@ -1255,7 +1255,7 @@ int main(int argc, char *argv[]) {
                 goto finish;
         }
 
-        log_debug("systemd-logind running as pid "PID_FMT, getpid_cached());
+        log_info("systemd-logind running as pid "PID_FMT, getpid_cached());
 
         sd_notify(false,
                   "READY=1\n"
@@ -1263,7 +1263,7 @@ int main(int argc, char *argv[]) {
 
         r = manager_run(m);
 
-        log_debug("systemd-logind stopped as pid "PID_FMT, getpid_cached());
+        log_info("systemd-logind stopped as pid "PID_FMT, getpid_cached());
 
 finish:
         sd_notify(false,
diff --git a/src/machine/machinectl.c b/src/machine/machinectl.c
index 75743ce6a..0631365dd 100644
--- a/src/machine/machinectl.c
+++ b/src/machine/machinectl.c
@@ -625,7 +625,7 @@ static int print_uid_shift(sd_bus *bus, const char *name) {
                                &reply,
                                "s", name);
         if (r < 0)
-                return log_debug_errno(r, "Failed to query UID/GID shift: %s", bus_error_message(&error, r));
+                return log_info_errno(r, "Failed to query UID/GID shift: %s", bus_error_message(&error, r));
 
         r = sd_bus_message_read(reply, "u", &shift);
         if (r < 0)
diff --git a/src/machine/machined-dbus.c b/src/machine/machined-dbus.c
index c5e59c471..9603e1659 100644
--- a/src/machine/machined-dbus.c
+++ b/src/machine/machined-dbus.c
@@ -1642,7 +1642,7 @@ int match_reloading(sd_bus_message *message, void *userdata, sd_bus_error *error
                 return 0;
 
         /* systemd finished reloading, let's recheck all our machines */
-        log_debug("System manager has been reloaded, rechecking machines...");
+        log_info("System manager has been reloaded, rechecking machines...");
 
         HASHMAP_FOREACH(machine, m->machines, i)
                 machine_add_to_gc_queue(machine);
diff --git a/src/machine/machined.c b/src/machine/machined.c
index 34b202404..2ec96c4a2 100644
--- a/src/machine/machined.c
+++ b/src/machine/machined.c
@@ -391,7 +391,7 @@ int main(int argc, char *argv[]) {
                 goto finish;
         }
 
-        log_debug("systemd-machined running as pid "PID_FMT, getpid_cached());
+        log_info("systemd-machined running as pid "PID_FMT, getpid_cached());
 
         sd_notify(false,
                   "READY=1\n"
@@ -399,7 +399,7 @@ int main(int argc, char *argv[]) {
 
         r = manager_run(m);
 
-        log_debug("systemd-machined stopped as pid "PID_FMT, getpid_cached());
+        log_info("systemd-machined stopped as pid "PID_FMT, getpid_cached());
 
 finish:
         manager_free(m);
diff --git a/src/machine/operation.c b/src/machine/operation.c
index 6aba1a2af..cfe8aa62e 100644
--- a/src/machine/operation.c
+++ b/src/machine/operation.c
@@ -33,7 +33,7 @@ static int operation_done(sd_event_source *s, const siginfo_t *si, void *userdat
         assert(o);
         assert(si);
 
-        log_debug("Operating " PID_FMT " is now complete with code=%s status=%i",
+        log_info("Operating " PID_FMT " is now complete with code=%s status=%i",
                   o->pid,
                   sigchld_code_to_string(si->si_code), si->si_status);
 
@@ -120,7 +120,7 @@ int operation_new(Manager *manager, Machine *machine, pid_t child, sd_bus_messag
                 o->machine = machine;
         }
 
-        log_debug("Started new operation " PID_FMT ".", child);
+        log_info("Started new operation " PID_FMT ".", child);
 
         /* At this point we took ownership of both the child and the errno file descriptor! */
 
diff --git a/src/modules-load/modules-load.c b/src/modules-load/modules-load.c
index c5f57685a..5497b6d04 100644
--- a/src/modules-load/modules-load.c
+++ b/src/modules-load/modules-load.c
@@ -83,7 +83,7 @@ static int load_module(struct kmod_ctx *ctx, const char *m) {
         _cleanup_(kmod_module_unref_listp) struct kmod_list *modlist = NULL;
         int r = 0;
 
-        log_debug("load: %s", m);
+        log_info("load: %s", m);
 
         r = kmod_module_new_from_lookup(ctx, m, &modlist);
         if (r < 0)
@@ -107,7 +107,7 @@ static int load_module(struct kmod_ctx *ctx, const char *m) {
                         break;
 
                 case KMOD_MODULE_LIVE:
-                        log_debug("Module '%s' is already loaded", kmod_module_get_name(mod));
+                        log_info("Module '%s' is already loaded", kmod_module_get_name(mod));
                         break;
 
                 default:
@@ -151,7 +151,7 @@ static int apply_file(struct kmod_ctx *ctx, const char *path, bool ignore_enoent
                 return log_error_errno(r, "Failed to open %s, ignoring: %m", path);
         }
 
-        log_debug("apply: %s", path);
+        log_info("apply: %s", path);
         for (;;) {
                 char line[LINE_MAX], *l;
                 int k;
diff --git a/src/mount/mount-tool.c b/src/mount/mount-tool.c
index 0cd9f0709..1ce0e12b2 100644
--- a/src/mount/mount-tool.c
+++ b/src/mount/mount-tool.c
@@ -473,13 +473,13 @@ static int transient_mount_set_properties(sd_bus_message *m) {
         }
 
         if (options || arg_mount_options) {
-                log_debug("Using mount options: %s", options ?: arg_mount_options);
+                log_info("Using mount options: %s", options ?: arg_mount_options);
 
                 r = sd_bus_message_append(m, "(sv)", "Options", "s", options ?: arg_mount_options);
                 if (r < 0)
                         return r;
         } else
-                log_debug("Not using any mount options");
+                log_info("Not using any mount options");
 
         if (arg_fsck) {
                 _cleanup_free_ char *fsck = NULL;
@@ -810,7 +810,7 @@ static int find_loop_device(const char *backing_file, char **loop_dev) {
 
                 r = read_one_line_file(sys, &fname);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to read %s, ignoring: %m", sys);
+                        log_info_errno(r, "Failed to read %s, ignoring: %m", sys);
                         continue;
                 }
 
@@ -1068,7 +1068,7 @@ static int acquire_mount_type(struct udev_device *d) {
         if (!arg_mount_type)
                 return log_oom();
 
-        log_debug("Discovered type=%s", arg_mount_type);
+        log_info("Discovered type=%s", arg_mount_type);
         return 1;
 }
 
@@ -1086,7 +1086,7 @@ static int acquire_mount_options(struct udev_device *d) {
         if (!arg_mount_options)
                 return log_oom();
 
-        log_debug("Discovered options=%s", arg_mount_options);
+        log_info("Discovered options=%s", arg_mount_options);
         return 1;
 }
 
@@ -1151,7 +1151,7 @@ static int acquire_mount_where(struct udev_device *d) {
         if (!arg_mount_where)
                 return log_oom();
 
-        log_debug("Discovered where=%s", arg_mount_where);
+        log_info("Discovered where=%s", arg_mount_where);
         return 1;
 }
 
@@ -1177,7 +1177,7 @@ static int acquire_mount_where_for_loop_dev(const char *loop_dev) {
         if (!arg_mount_where)
                 return log_oom();
 
-        log_debug("Discovered where=%s", arg_mount_where);
+        log_info("Discovered where=%s", arg_mount_where);
         return 1;
 }
 
@@ -1205,7 +1205,7 @@ static int acquire_description(struct udev_device *d) {
         if (!arg_description)
                 return log_oom();
 
-        log_debug("Discovered description=%s", arg_description);
+        log_info("Discovered description=%s", arg_description);
         return 1;
 }
 
@@ -1232,20 +1232,20 @@ static int acquire_removable(struct udev_device *d) {
         if (parse_boolean(v) <= 0)
                 return 0;
 
-        log_debug("Discovered removable device.");
+        log_info("Discovered removable device.");
 
         if (arg_action == ACTION_DEFAULT) {
-                log_debug("Automatically turning on automount.");
+                log_info("Automatically turning on automount.");
                 arg_action = ACTION_AUTOMOUNT;
         }
 
         if (!arg_timeout_idle_set) {
-                log_debug("Setting idle timeout to 1s.");
+                log_info("Setting idle timeout to 1s.");
                 arg_timeout_idle = USEC_PER_SEC;
         }
 
         if (arg_bind_device < 0) {
-                log_debug("Binding automount unit to device.");
+                log_info("Binding automount unit to device.");
                 arg_bind_device = true;
         }
 
@@ -1282,7 +1282,7 @@ static int discover_loop_backing_file(void) {
                 if (!arg_mount_where)
                         return log_oom();
 
-                log_debug("Discovered where=%s", arg_mount_where);
+                log_info("Discovered where=%s", arg_mount_where);
                 return 0;
         }
 
@@ -1632,7 +1632,7 @@ int main(int argc, char* argv[]) {
                 if (r < 0)
                         log_warning_errno(r, "Couldn't determine whether fsck for %s exists, proceeding anyway.", arg_mount_type);
                 else if (r == 0) {
-                        log_debug("Disabling file system check as fsck for %s doesn't exist.", arg_mount_type);
+                        log_info("Disabling file system check as fsck for %s doesn't exist.", arg_mount_type);
                         arg_fsck = false; /* fsck doesn't exist, let's not attempt it */
                 }
         }
diff --git a/src/network/netdev/netdev.c b/src/network/netdev/netdev.c
index 93648e1be..fc0a6bc3d 100644
--- a/src/network/netdev/netdev.c
+++ b/src/network/netdev/netdev.c
@@ -631,7 +631,7 @@ static int netdev_load_one(Manager *manager, const char *filename) {
         }
 
         if (null_or_empty_fd(fileno(file))) {
-                log_debug("Skipping empty file: %s", filename);
+                log_info("Skipping empty file: %s", filename);
                 return 0;
         }
 
diff --git a/src/network/networkctl.c b/src/network/networkctl.c
index 59ce098cd..fe7d682d1 100644
--- a/src/network/networkctl.c
+++ b/src/network/networkctl.c
@@ -501,7 +501,7 @@ static int dump_gateways(
 
                 r = get_gateway_description(rtnl, hwdb, local[i].ifindex, local[i].family, &local[i].address, &description);
                 if (r < 0)
-                        log_debug_errno(r, "Could not get description of gateway: %m");
+                        log_info_errno(r, "Could not get description of gateway: %m");
 
                 printf("%*s%s",
                        (int) strlen(prefix),
@@ -926,7 +926,7 @@ static int link_status(int argc, char *argv[], void *userdata) {
 
         r = sd_hwdb_new(&hwdb);
         if (r < 0)
-                log_debug_errno(r, "Failed to open hardware database: %m");
+                log_info_errno(r, "Failed to open hardware database: %m");
 
         if (arg_all)
                 c = acquire_link_info_all(rtnl, &links);
diff --git a/src/network/networkd-address-pool.c b/src/network/networkd-address-pool.c
index 22582ab9f..a0a695168 100644
--- a/src/network/networkd-address-pool.c
+++ b/src/network/networkd-address-pool.c
@@ -155,7 +155,7 @@ int address_pool_acquire(AddressPool *p, unsigned prefixlen, union in_addr_union
                         if (r < 0)
                                 return r;
 
-                        log_debug("Found range %s/%u", strna(s), prefixlen);
+                        log_info("Found range %s/%u", strna(s), prefixlen);
 
                         *found = u;
                         return 1;
diff --git a/src/network/networkd-dhcp4.c b/src/network/networkd-dhcp4.c
index ecb96cdb5..72068369f 100644
--- a/src/network/networkd-dhcp4.c
+++ b/src/network/networkd-dhcp4.c
@@ -623,7 +623,7 @@ static bool promote_secondaries_enabled(const char *ifname) {
         promote_secondaries_path = strjoina("net/ipv4/conf/", ifname, "/promote_secondaries");
         r = sysctl_read(promote_secondaries_path, &promote_secondaries_sysctl);
         if (r < 0) {
-                log_debug_errno(r, "Cannot read sysctl %s", promote_secondaries_path);
+                log_info_errno(r, "Cannot read sysctl %s", promote_secondaries_path);
                 return false;
         }
 
diff --git a/src/network/networkd-link.c b/src/network/networkd-link.c
index 64c45080d..705e3ca4f 100644
--- a/src/network/networkd-link.c
+++ b/src/network/networkd-link.c
@@ -960,7 +960,7 @@ static int link_push_uplink_dns_to_dhcp_server(Link *link, sd_dhcp_server *s) {
         size_t n_addresses = 0, n_allocated = 0;
         unsigned i;
 
-        log_debug("Copying DNS server information from %s", link->ifname);
+        log_info("Copying DNS server information from %s", link->ifname);
 
         if (!link->network)
                 return 0;
@@ -1013,7 +1013,7 @@ static int link_push_uplink_ntp_to_dhcp_server(Link *link, sd_dhcp_server *s) {
         if (!link->network)
                 return 0;
 
-        log_debug("Copying NTP server information from %s", link->ifname);
+        log_info("Copying NTP server information from %s", link->ifname);
 
         STRV_FOREACH(a, link->network->ntp) {
                 struct in_addr ia;
@@ -3453,7 +3453,7 @@ int link_save(Link *link) {
                         r = in_addr_to_string(link->network->dns[j].family,
                                               &link->network->dns[j].address,  &b);
                         if (r < 0) {
-                                log_debug_errno(r, "Failed to format address, ignoring: %m");
+                                log_info_errno(r, "Failed to format address, ignoring: %m");
                                 continue;
                         }
 
diff --git a/src/network/networkd-manager.c b/src/network/networkd-manager.c
index 749b87f33..cceaea62a 100644
--- a/src/network/networkd-manager.c
+++ b/src/network/networkd-manager.c
@@ -107,14 +107,14 @@ static int match_prepare_for_sleep(sd_bus_message *message, void *userdata, sd_b
 
         r = sd_bus_message_read(message, "b", &b);
         if (r < 0) {
-                log_debug_errno(r, "Failed to parse PrepareForSleep signal: %m");
+                log_info_errno(r, "Failed to parse PrepareForSleep signal: %m");
                 return 0;
         }
 
         if (b)
                 return 0;
 
-        log_debug("Coming back from suspend, resetting all connections...");
+        log_info("Coming back from suspend, resetting all connections...");
 
         (void) manager_reset_all(m);
 
@@ -213,7 +213,7 @@ static int manager_udev_process_link(Manager *m, struct udev_device *device) {
 
         ifindex = udev_device_get_ifindex(device);
         if (ifindex <= 0) {
-                log_debug("Ignoring udev ADD event for device with invalid ifindex");
+                log_info("Ignoring udev ADD event for device with invalid ifindex");
                 return 0;
         }
 
@@ -321,7 +321,7 @@ int manager_rtnl_process_route(sd_netlink *rtnl, sd_netlink_message *message, vo
 
         r = sd_netlink_message_read_u32(message, RTA_OIF, &ifindex);
         if (r == -ENODATA) {
-                log_debug("rtnl: received route without ifindex, ignoring");
+                log_info("rtnl: received route without ifindex, ignoring");
                 return 0;
         } else if (r < 0) {
                 log_warning_errno(r, "rtnl: could not get ifindex from route, ignoring: %m");
@@ -768,7 +768,7 @@ int manager_rtnl_process_rule(sd_netlink *rtnl, sd_netlink_message *message, voi
                 log_warning_errno(r, "rtnl: could not get rule family, ignoring: %m");
                 return 0;
         } else if (!IN_SET(family, AF_INET, AF_INET6)) {
-                log_debug("rtnl: received address with invalid family %u, ignoring", family);
+                log_info("rtnl: received address with invalid family %u, ignoring", family);
                 return 0;
         }
 
@@ -1668,7 +1668,7 @@ int manager_rtnl_enumerate_rules(Manager *m) {
         r = sd_netlink_call(m->rtnl, req, 0, &reply);
         if (r < 0) {
                 if (r == -EOPNOTSUPP) {
-                        log_debug("FIB Rules are not supported by the kernel. Ignoring.");
+                        log_info("FIB Rules are not supported by the kernel. Ignoring.");
                         return 0;
                 }
 
@@ -1731,7 +1731,7 @@ Link* manager_find_uplink(Manager *m, Link *exclude) {
 
                 link = hashmap_get(m->links, INT_TO_PTR(gateways[i].ifindex));
                 if (!link) {
-                        log_debug("Weird, found a gateway for a link we don't know. Ignoring.");
+                        log_info("Weird, found a gateway for a link we don't know. Ignoring.");
                         continue;
                 }
 
@@ -1771,7 +1771,7 @@ static int set_hostname_handler(sd_bus_message *m, void *userdata, sd_bus_error
 int manager_set_hostname(Manager *m, const char *hostname) {
         int r;
 
-        log_debug("Setting transient hostname: '%s'", strna(hostname));
+        log_info("Setting transient hostname: '%s'", strna(hostname));
 
         if (free_and_strdup(&m->dynamic_hostname, hostname) < 0)
                 return log_oom();
@@ -1820,7 +1820,7 @@ int manager_set_timezone(Manager *m, const char *tz) {
         assert(m);
         assert(tz);
 
-        log_debug("Setting system timezone: '%s'", tz);
+        log_info("Setting system timezone: '%s'", tz);
         if (free_and_strdup(&m->dynamic_timezone, tz) < 0)
                 return log_oom();
 
diff --git a/src/network/networkd-network.c b/src/network/networkd-network.c
index 2dc3de3f6..614ffb2e3 100644
--- a/src/network/networkd-network.c
+++ b/src/network/networkd-network.c
@@ -143,7 +143,7 @@ static int network_load_one(Manager *manager, const char *filename) {
         }
 
         if (null_or_empty_fd(fileno(file))) {
-                log_debug("Skipping empty file: %s", filename);
+                log_info("Skipping empty file: %s", filename);
                 return 0;
         }
 
@@ -503,9 +503,9 @@ int network_get(Manager *manager, struct udev_device *device,
                                         log_warning("%s: found matching network '%s', based on potentially unpredictable ifname",
                                                     ifname, network->filename);
                                 else
-                                        log_debug("%s: found matching network '%s'", ifname, network->filename);
+                                        log_info("%s: found matching network '%s'", ifname, network->filename);
                         } else
-                                log_debug("%s: found matching network '%s'", ifname, network->filename);
+                                log_info("%s: found matching network '%s'", ifname, network->filename);
 
                         *ret = network;
                         return 0;
diff --git a/src/network/wait-online/manager.c b/src/network/wait-online/manager.c
index 05f030dbe..ae136a51f 100644
--- a/src/network/wait-online/manager.c
+++ b/src/network/wait-online/manager.c
@@ -59,7 +59,7 @@ bool manager_all_configured(Manager *m) {
         STRV_FOREACH(ifname, m->interfaces) {
                 l = hashmap_get(m->links_by_name, *ifname);
                 if (!l) {
-                        log_debug("still waiting for %s", *ifname);
+                        log_info("still waiting for %s", *ifname);
                         return false;
                 }
         }
@@ -73,13 +73,13 @@ bool manager_all_configured(Manager *m) {
                 }
 
                 if (!l->state) {
-                        log_debug("link %s has not yet been processed by udev",
+                        log_info("link %s has not yet been processed by udev",
                                   l->ifname);
                         return false;
                 }
 
                 if (STR_IN_SET(l->state, "configuring", "pending")) {
-                        log_debug("link %s is being processed by networkd",
+                        log_info("link %s is being processed by networkd",
                                   l->ifname);
                         return false;
                 }
@@ -123,7 +123,7 @@ static int manager_process_link(sd_netlink *rtnl, sd_netlink_message *mm, void *
 
         case RTM_NEWLINK:
                 if (!l) {
-                        log_debug("Found link %i", ifindex);
+                        log_info("Found link %i", ifindex);
 
                         r = link_new(m, &l, ifindex, ifname);
                         if (r < 0)
@@ -142,7 +142,7 @@ static int manager_process_link(sd_netlink *rtnl, sd_netlink_message *mm, void *
 
         case RTM_DELLINK:
                 if (l) {
-                        log_debug("Removing link %i", l->ifindex);
+                        log_info("Removing link %i", l->ifindex);
                         link_free(l);
                 }
 
diff --git a/src/nspawn/nspawn-expose-ports.c b/src/nspawn/nspawn-expose-ports.c
index 98eb85081..9cf79db11 100644
--- a/src/nspawn/nspawn-expose-ports.c
+++ b/src/nspawn/nspawn-expose-ports.c
@@ -110,7 +110,7 @@ int expose_port_flush(ExposePort* l, union in_addr_union *exposed) {
         if (in_addr_is_null(af, exposed))
                 return 0;
 
-        log_debug("Lost IP address.");
+        log_info("Lost IP address.");
 
         LIST_FOREACH(ports, p, l) {
                 r = fw_add_local_dnat(false,
@@ -163,7 +163,7 @@ int expose_port_execute(sd_netlink *rtnl, ExposePort *l, union in_addr_union *ex
                 return 0;
 
         in_addr_to_string(af, &new_exposed, &pretty);
-        log_debug("New container IP is %s.", strna(pretty));
+        log_info("New container IP is %s.", strna(pretty));
 
         LIST_FOREACH(ports, p, l) {
 
diff --git a/src/nspawn/nspawn-mount.c b/src/nspawn/nspawn-mount.c
index c9236ea3d..58c2ca5ce 100644
--- a/src/nspawn/nspawn-mount.c
+++ b/src/nspawn/nspawn-mount.c
@@ -601,7 +601,7 @@ int mount_all(const char *dest,
                         if (fatal && r != -EROFS)
                                 return log_error_errno(r, "Failed to create directory %s: %m", where);
 
-                        log_debug_errno(r, "Failed to create directory %s: %m", where);
+                        log_info_errno(r, "Failed to create directory %s: %m", where);
                         /* If we failed mkdir() or chown() due to the root
                          * directory being read only, attempt to mount this fs
                          * anyway and let mount_verbose log any errors */
diff --git a/src/nspawn/nspawn-patch-uid.c b/src/nspawn/nspawn-patch-uid.c
index 7081ed0db..4cc992d46 100644
--- a/src/nspawn/nspawn-patch-uid.c
+++ b/src/nspawn/nspawn-patch-uid.c
@@ -421,7 +421,7 @@ read_only:
 
                 /* When we hit a ready-only subtree we simply skip it, but log about it. */
                 (void) fd_get_path(fd, &name);
-                log_debug("Skippping read-only file or directory %s.", strna(name));
+                log_info("Skippping read-only file or directory %s.", strna(name));
                 r = changed;
         }
 
diff --git a/src/nspawn/nspawn-register.c b/src/nspawn/nspawn-register.c
index 07d68242c..b885607f5 100644
--- a/src/nspawn/nspawn-register.c
+++ b/src/nspawn/nspawn-register.c
@@ -72,7 +72,7 @@ static int append_machine_properties(
                 r = is_device_node(cm->source);
                 if (r == -ENOENT) {
                         /* The bind source might only appear as the image is put together, hence don't complain */
-                        log_debug_errno(r, "Bind mount source %s not found, ignoring: %m", cm->source);
+                        log_info_errno(r, "Bind mount source %s not found, ignoring: %m", cm->source);
                         continue;
                 }
                 if (r < 0)
@@ -244,7 +244,7 @@ int terminate_machine(sd_bus *bus, pid_t pid) {
                 /* Note that the machine might already have been
                  * cleaned up automatically, hence don't consider it a
                  * failure if we cannot get the machine object. */
-                log_debug("Failed to get machine: %s", bus_error_message(&error, r));
+                log_info("Failed to get machine: %s", bus_error_message(&error, r));
                 return 0;
         }
 
@@ -262,7 +262,7 @@ int terminate_machine(sd_bus *bus, pid_t pid) {
                         NULL,
                         NULL);
         if (r < 0) {
-                log_debug("Failed to terminate machine: %s", bus_error_message(&error, r));
+                log_info("Failed to terminate machine: %s", bus_error_message(&error, r));
                 return 0;
         }
 
diff --git a/src/nspawn/nspawn-seccomp.c b/src/nspawn/nspawn-seccomp.c
index 92e5ff9c3..409e0b366 100644
--- a/src/nspawn/nspawn-seccomp.c
+++ b/src/nspawn/nspawn-seccomp.c
@@ -169,7 +169,7 @@ static int seccomp_add_default_syscall_filter(
                 r = seccomp_add_syscall_filter_item(ctx, whitelist[i].name, SCMP_ACT_ALLOW, syscall_blacklist);
                 if (r < 0)
                         /* If the system call is not known on this architecture, then that's fine, let's ignore it */
-                        log_debug_errno(r, "Failed to add rule for system call %s on %s, ignoring: %m", whitelist[i].name, seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to add rule for system call %s on %s, ignoring: %m", whitelist[i].name, seccomp_arch_to_string(arch));
                 else
                         c++;
         }
@@ -177,7 +177,7 @@ static int seccomp_add_default_syscall_filter(
         STRV_FOREACH(p, syscall_whitelist) {
                 r = seccomp_add_syscall_filter_item(ctx, *p, SCMP_ACT_ALLOW, syscall_blacklist);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to add rule for system call %s on %s, ignoring: %m", *p, seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to add rule for system call %s on %s, ignoring: %m", *p, seccomp_arch_to_string(arch));
                 else
                         c++;
         }
@@ -190,14 +190,14 @@ int setup_seccomp(uint64_t cap_list_retain, char **syscall_whitelist, char **sys
         int r;
 
         if (!is_seccomp_available()) {
-                log_debug("SECCOMP features not detected in the kernel, disabling SECCOMP filterering");
+                log_info("SECCOMP features not detected in the kernel, disabling SECCOMP filterering");
                 return 0;
         }
 
         SECCOMP_FOREACH_LOCAL_ARCH(arch) {
                 _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;
 
-                log_debug("Applying whitelist on architecture: %s", seccomp_arch_to_string(arch));
+                log_info("Applying whitelist on architecture: %s", seccomp_arch_to_string(arch));
 
                 r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ERRNO(EPERM));
                 if (r < 0)
@@ -211,13 +211,13 @@ int setup_seccomp(uint64_t cap_list_retain, char **syscall_whitelist, char **sys
                 if (IN_SET(r, -EPERM, -EACCES))
                         return log_error_errno(r, "Failed to install seccomp filter: %m");
                 if (r < 0)
-                        log_debug_errno(r, "Failed to install filter set for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to install filter set for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         SECCOMP_FOREACH_LOCAL_ARCH(arch) {
                 _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;
 
-                log_debug("Applying NETLINK_AUDIT mask on architecture: %s", seccomp_arch_to_string(arch));
+                log_info("Applying NETLINK_AUDIT mask on architecture: %s", seccomp_arch_to_string(arch));
 
                 r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);
                 if (r < 0)
@@ -239,7 +239,7 @@ int setup_seccomp(uint64_t cap_list_retain, char **syscall_whitelist, char **sys
                                 SCMP_A0(SCMP_CMP_EQ, AF_NETLINK),
                                 SCMP_A2(SCMP_CMP_EQ, NETLINK_AUDIT));
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to add audit seccomp rule, ignoring: %m");
+                        log_info_errno(r, "Failed to add audit seccomp rule, ignoring: %m");
                         continue;
                 }
 
@@ -247,7 +247,7 @@ int setup_seccomp(uint64_t cap_list_retain, char **syscall_whitelist, char **sys
                 if (IN_SET(r, -EPERM, -EACCES))
                         return log_error_errno(r, "Failed to install seccomp audit filter: %m");
                 if (r < 0)
-                        log_debug_errno(r, "Failed to install filter set for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to install filter set for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         return 0;
diff --git a/src/nspawn/nspawn.c b/src/nspawn/nspawn.c
index 0f05ecff0..7f8ba4b2b 100644
--- a/src/nspawn/nspawn.c
+++ b/src/nspawn/nspawn.c
@@ -373,7 +373,7 @@ static int detect_unified_cgroup_hierarchy_from_image(const char *directory) {
         } else
                 arg_unified_cgroup_hierarchy = CGROUP_UNIFIED_NONE;
 
-        log_debug("Using %s hierarchy for container.",
+        log_info("Using %s hierarchy for container.",
                   arg_unified_cgroup_hierarchy == CGROUP_UNIFIED_NONE ? "legacy" :
                   arg_unified_cgroup_hierarchy == CGROUP_UNIFIED_SYSTEMD ? "hybrid" : "unified");
 
@@ -1665,9 +1665,9 @@ static int setup_keyring(void) {
         keyring = keyctl(KEYCTL_JOIN_SESSION_KEYRING, 0, 0, 0, 0);
         if (keyring == -1) {
                 if (errno == ENOSYS)
-                        log_debug_errno(errno, "Kernel keyring not supported, ignoring.");
+                        log_info_errno(errno, "Kernel keyring not supported, ignoring.");
                 else if (IN_SET(errno, EACCES, EPERM))
-                        log_debug_errno(errno, "Kernel keyring access prohibited, ignoring.");
+                        log_info_errno(errno, "Kernel keyring access prohibited, ignoring.");
                 else
                         return log_error_errno(errno, "Setting up kernel keyring failed: %m");
         }
@@ -1833,7 +1833,7 @@ static int setup_journal(const char *directory) {
 
                 if (symlink(q, p) < 0) {
                         if (try) {
-                                log_debug_errno(errno, "Failed to symlink %s to %s, skipping journal setup: %m", q, p);
+                                log_info_errno(errno, "Failed to symlink %s to %s, skipping journal setup: %m", q, p);
                                 return 0;
                         } else
                                 return log_error_errno(errno, "Failed to symlink %s to %s: %m", q, p);
@@ -1852,7 +1852,7 @@ static int setup_journal(const char *directory) {
                 r = mkdir_errno_wrapper(p, 0755);
                 if (r < 0 && r != -EEXIST) {
                         if (try) {
-                                log_debug_errno(r, "Failed to create %s, skipping journal setup: %m", p);
+                                log_info_errno(r, "Failed to create %s, skipping journal setup: %m", p);
                                 return 0;
                         } else
                                 return log_error_errno(r, "Failed to create %s: %m", p);
@@ -1999,9 +1999,9 @@ static int recursive_chown(const char *directory, uid_t shift, uid_t range) {
         if (r < 0)
                 return log_error_errno(r, "Failed to adjust UID/GID shift of OS tree: %m");
         if (r == 0)
-                log_debug("Root directory of image is already owned by the right UID/GID range, skipping recursive chown operation.");
+                log_info("Root directory of image is already owned by the right UID/GID range, skipping recursive chown operation.");
         else
-                log_debug("Patched directory tree to match UID/GID range.");
+                log_info("Patched directory tree to match UID/GID range.");
 
         return r;
 }
@@ -3024,7 +3024,7 @@ static int nspawn_dispatch_notify_fd(sd_event_source *source, int fd, uint32_t r
         }
 
         if (!ucred || ucred->pid != inner_child_pid) {
-                log_debug("Received notify message without valid credentials. Ignoring.");
+                log_info("Received notify message without valid credentials. Ignoring.");
                 return 0;
         }
 
@@ -3126,7 +3126,7 @@ static int load_settings(void) {
         if (!f)
                 return 0;
 
-        log_debug("Settings are trusted: %s", yes_no(arg_settings_trusted));
+        log_info("Settings are trusted: %s", yes_no(arg_settings_trusted));
 
         r = settings_load(f, p, &settings);
         if (r < 0)
@@ -3549,7 +3549,7 @@ static int run(int master,
                 return log_error_errno(notify_socket,
                                        "Failed to receive notification socket from the outer child: %m");
 
-        log_debug("Init process invoked as PID "PID_FMT, *pid);
+        log_info("Init process invoked as PID "PID_FMT, *pid);
 
         if (arg_userns_mode != USER_NAMESPACE_NO) {
                 if (!barrier_place_and_sync(&barrier)) { /* #1 */
@@ -4195,7 +4195,7 @@ finish:
 
         if (remove_tmprootdir) {
                 if (rmdir(tmprootdir) < 0)
-                        log_debug_errno(errno, "Can't remove temporary root directory '%s', ignoring: %m", tmprootdir);
+                        log_info_errno(errno, "Can't remove temporary root directory '%s', ignoring: %m", tmprootdir);
         }
 
         if (arg_machine) {
diff --git a/src/partition/growfs.c b/src/partition/growfs.c
index 41b4e872b..2f8831ace 100644
--- a/src/partition/growfs.c
+++ b/src/partition/growfs.c
@@ -101,7 +101,7 @@ static int resize_crypt_luks_device(dev_t devno, const char *fstype, dev_t main_
                 return log_error_errno(errno, "Failed to query size of \"%s\" (before resize): %m",
                                        main_devpath);
 
-        log_debug("%s is %"PRIu64" bytes", main_devpath, size);
+        log_info("%s is %"PRIu64" bytes", main_devpath, size);
 
         xsprintf_dev_num_path(devpath, "block", devno);
         r = crypt_init(&cd, devpath);
@@ -112,7 +112,7 @@ static int resize_crypt_luks_device(dev_t devno, const char *fstype, dev_t main_
 
         r = crypt_load(cd, CRYPT_LUKS, NULL);
         if (r < 0)
-                return log_debug_errno(r, "Failed to load LUKS metadata for %s: %m", devpath);
+                return log_info_errno(r, "Failed to load LUKS metadata for %s: %m", devpath);
 
         if (arg_dry_run)
                 return 0;
@@ -125,7 +125,7 @@ static int resize_crypt_luks_device(dev_t devno, const char *fstype, dev_t main_
                 log_warning_errno(errno, "Failed to query size of \"%s\" (after resize): %m",
                                   devpath);
         else
-                log_debug("%s is now %"PRIu64" bytes", main_devpath, size);
+                log_info("%s is now %"PRIu64" bytes", main_devpath, size);
 
         return 1;
 }
@@ -147,7 +147,7 @@ static int maybe_resize_slave_device(const char *mountpath, dev_t main_devno) {
                 return log_error_errno(r, "Failed to determine underlying block device of \"%s\": %m",
                                        mountpath);
 
-        log_debug("Underlying device %d:%d, main dev %d:%d, %s",
+        log_info("Underlying device %d:%d, main dev %d:%d, %s",
                   major(devno), minor(devno),
                   major(main_devno), minor(main_devno),
                   devno == main_devno ? "same" : "different");
@@ -166,7 +166,7 @@ static int maybe_resize_slave_device(const char *mountpath, dev_t main_devno) {
                 return resize_crypt_luks_device(devno, fstype, main_devno);
 #endif
 
-        log_debug("Don't know how to resize %s of type %s, ignoring", devpath, strnull(fstype));
+        log_info("Don't know how to resize %s of type %s, ignoring", devpath, strnull(fstype));
         return 0;
 }
 
diff --git a/src/random-seed/random-seed.c b/src/random-seed/random-seed.c
index 23a6fda08..a2bb60810 100644
--- a/src/random-seed/random-seed.c
+++ b/src/random-seed/random-seed.c
@@ -119,7 +119,7 @@ int main(int argc, char *argv[]) {
                         r = log_error_errno(k, "Failed to read seed from " RANDOM_SEED ": %m");
                 else if (k == 0) {
                         r = 0;
-                        log_debug("Seed file " RANDOM_SEED " not yet initialized, proceeding.");
+                        log_info("Seed file " RANDOM_SEED " not yet initialized, proceeding.");
                 } else {
                         (void) lseek(seed_fd, 0, SEEK_SET);
 
diff --git a/src/rc-local-generator/rc-local-generator.c b/src/rc-local-generator/rc-local-generator.c
index 2762fa7e8..f80574bb1 100644
--- a/src/rc-local-generator/rc-local-generator.c
+++ b/src/rc-local-generator/rc-local-generator.c
@@ -72,14 +72,14 @@ int main(int argc, char *argv[]) {
         umask(0022);
 
         if (access(RC_LOCAL_SCRIPT_PATH_START, X_OK) >= 0) {
-                log_debug("Automatically adding rc-local.service.");
+                log_info("Automatically adding rc-local.service.");
 
                 if (add_symlink("rc-local.service", "multi-user.target") < 0)
                         ret = EXIT_FAILURE;
         }
 
         if (access(RC_LOCAL_SCRIPT_PATH_STOP, X_OK) >= 0) {
-                log_debug("Automatically adding halt-local.service.");
+                log_info("Automatically adding halt-local.service.");
 
                 if (add_symlink("halt-local.service", "final.target") < 0)
                         ret = EXIT_FAILURE;
diff --git a/src/remount-fs/remount-fs.c b/src/remount-fs/remount-fs.c
index c61777c3f..0679ecfc4 100644
--- a/src/remount-fs/remount-fs.c
+++ b/src/remount-fs/remount-fs.c
@@ -85,7 +85,7 @@ int main(int argc, char *argv[]) {
                     !path_equal(me->mnt_dir, "/usr"))
                         continue;
 
-                log_debug("Remounting %s", me->mnt_dir);
+                log_info("Remounting %s", me->mnt_dir);
 
                 r = safe_fork("(remount)", FORK_RESET_SIGNALS|FORK_DEATHSIG|FORK_LOG, &pid);
                 if (r < 0)
diff --git a/src/resolve/resolve-tool.c b/src/resolve/resolve-tool.c
index 2a6bf9407..aa16fc790 100644
--- a/src/resolve/resolve-tool.c
+++ b/src/resolve/resolve-tool.c
@@ -155,7 +155,7 @@ static int resolve_host(sd_bus *bus, const char *name) {
         if (arg_ifindex > 0 && !if_indextoname(arg_ifindex, ifname))
                 return log_error_errno(errno, "Failed to resolve interface name for index %i: %m", arg_ifindex);
 
-        log_debug("Resolving %s (family %s, interface %s).", name, af_to_name(arg_family) ?: "*", isempty(ifname) ? "*" : ifname);
+        log_info("Resolving %s (family %s, interface %s).", name, af_to_name(arg_family) ?: "*", isempty(ifname) ? "*" : ifname);
 
         r = sd_bus_message_new_method_call(
                         bus,
@@ -204,7 +204,7 @@ static int resolve_host(sd_bus *bus, const char *name) {
                         return bus_log_parse_error(r);
 
                 if (!IN_SET(family, AF_INET, AF_INET6)) {
-                        log_debug("%s: skipping entry with family %d (%s)", name, family, af_to_name(family) ?: "unknown");
+                        log_info("%s: skipping entry with family %d (%s)", name, family, af_to_name(family) ?: "unknown");
                         continue;
                 }
 
@@ -278,7 +278,7 @@ static int resolve_address(sd_bus *bus, int family, const union in_addr_union *a
         if (ifindex > 0 && !if_indextoname(ifindex, ifname))
                 return log_error_errno(errno, "Failed to resolve interface name for index %i: %m", ifindex);
 
-        log_debug("Resolving %s%s%s.", pretty, isempty(ifname) ? "" : "%", ifname);
+        log_info("Resolving %s%s%s.", pretty, isempty(ifname) ? "" : "%", ifname);
 
         r = sd_bus_message_new_method_call(
                         bus,
@@ -422,7 +422,7 @@ static int resolve_record(sd_bus *bus, const char *name, uint16_t class, uint16_
         if (arg_ifindex > 0 && !if_indextoname(arg_ifindex, ifname))
                 return log_error_errno(errno, "Failed to resolve interface name for index %i: %m", arg_ifindex);
 
-        log_debug("Resolving %s %s %s (interface %s).", name, dns_class_to_string(class), dns_type_to_string(type), isempty(ifname) ? "*" : ifname);
+        log_info("Resolving %s %s %s (interface %s).", name, dns_class_to_string(class), dns_type_to_string(type), isempty(ifname) ? "*" : ifname);
 
         r = sd_bus_message_new_method_call(
                         bus,
@@ -661,11 +661,11 @@ static int resolve_service(sd_bus *bus, const char *name, const char *type, cons
                 return log_error_errno(errno, "Failed to resolve interface name for index %i: %m", arg_ifindex);
 
         if (name)
-                log_debug("Resolving service \"%s\" of type %s in %s (family %s, interface %s).", name, type, domain, af_to_name(arg_family) ?: "*", isempty(ifname) ? "*" : ifname);
+                log_info("Resolving service \"%s\" of type %s in %s (family %s, interface %s).", name, type, domain, af_to_name(arg_family) ?: "*", isempty(ifname) ? "*" : ifname);
         else if (type)
-                log_debug("Resolving service type %s of %s (family %s, interface %s).", type, domain, af_to_name(arg_family) ?: "*", isempty(ifname) ? "*" : ifname);
+                log_info("Resolving service type %s of %s (family %s, interface %s).", type, domain, af_to_name(arg_family) ?: "*", isempty(ifname) ? "*" : ifname);
         else
-                log_debug("Resolving service type %s (family %s, interface %s).", domain, af_to_name(arg_family) ?: "*", isempty(ifname) ? "*" : ifname);
+                log_info("Resolving service type %s (family %s, interface %s).", domain, af_to_name(arg_family) ?: "*", isempty(ifname) ? "*" : ifname);
 
         r = sd_bus_message_new_method_call(
                         bus,
@@ -742,7 +742,7 @@ static int resolve_service(sd_bus *bus, const char *name, const char *type, cons
                                 return bus_log_parse_error(r);
 
                         if (!IN_SET(family, AF_INET, AF_INET6)) {
-                                log_debug("%s: skipping entry with family %d (%s)", name, family, af_to_name(family) ?: "unknown");
+                                log_info("%s: skipping entry with family %d (%s)", name, family, af_to_name(family) ?: "unknown");
                                 continue;
                         }
 
@@ -859,7 +859,7 @@ static int resolve_openpgp(sd_bus *bus, const char *address) {
         strshorten(hashed, 56);
 
         full = strjoina(hashed, "._openpgpkey.", domain);
-        log_debug("Looking up \"%s\".", full);
+        log_info("Looking up \"%s\".", full);
 
         r = resolve_record(bus, full,
                            arg_class ?: DNS_CLASS_IN,
@@ -872,7 +872,7 @@ static int resolve_openpgp(sd_bus *bus, const char *address) {
                     return log_error_errno(r, "Hashing failed: %m");
 
               full = strjoina(hashed, "._openpgpkey.", domain);
-              log_debug("Looking up \"%s\".", full);
+              log_info("Looking up \"%s\".", full);
 
               return resolve_record(bus, full,
                                     arg_class ?: DNS_CLASS_IN,
@@ -907,7 +907,7 @@ static int resolve_tlsa(sd_bus *bus, const char *address) {
         if (r < 0)
                 return log_oom();
 
-        log_debug("Looking up \"%s\".", full);
+        log_info("Looking up \"%s\".", full);
 
         return resolve_record(bus, full,
                               arg_class ?: DNS_CLASS_IN,
@@ -1123,12 +1123,12 @@ static int map_link_dns_servers(sd_bus *bus, const char *member, sd_bus_message
                         return r;
 
                 if (!IN_SET(family, AF_INET, AF_INET6)) {
-                        log_debug("Unexpected family, ignoring.");
+                        log_info("Unexpected family, ignoring.");
                         continue;
                 }
 
                 if (sz != FAMILY_ADDRESS_SIZE(family)) {
-                        log_debug("Address size mismatch, ignoring.");
+                        log_info("Address size mismatch, ignoring.");
                         continue;
                 }
 
@@ -1351,12 +1351,12 @@ static int map_global_dns_servers(sd_bus *bus, const char *member, sd_bus_messag
                         continue;
 
                 if (!IN_SET(family, AF_INET, AF_INET6)) {
-                        log_debug("Unexpected family, ignoring.");
+                        log_info("Unexpected family, ignoring.");
                         continue;
                 }
 
                 if (sz != FAMILY_ADDRESS_SIZE(family)) {
-                        log_debug("Address size mismatch, ignoring.");
+                        log_info("Address size mismatch, ignoring.");
                         continue;
                 }
 
diff --git a/src/resolve/resolved-bus.c b/src/resolve/resolved-bus.c
index ffd7c4824..cfbf98bb2 100644
--- a/src/resolve/resolved-bus.c
+++ b/src/resolve/resolved-bus.c
@@ -1591,7 +1591,7 @@ static int on_bus_track(sd_bus_track *t, void *userdata) {
         assert(t);
         assert(s);
 
-        log_debug("Client of active request vanished, destroying DNS-SD service.");
+        log_info("Client of active request vanished, destroying DNS-SD service.");
         dnssd_service_free(s);
 
         return 0;
@@ -1853,14 +1853,14 @@ static int match_prepare_for_sleep(sd_bus_message *message, void *userdata, sd_b
 
         r = sd_bus_message_read(message, "b", &b);
         if (r < 0) {
-                log_debug_errno(r, "Failed to parse PrepareForSleep signal: %m");
+                log_info_errno(r, "Failed to parse PrepareForSleep signal: %m");
                 return 0;
         }
 
         if (b)
                 return 0;
 
-        log_debug("Coming back from suspend, verifying all RRs...");
+        log_info("Coming back from suspend, verifying all RRs...");
 
         manager_verify_all(m);
         return 0;
diff --git a/src/resolve/resolved-conf.c b/src/resolve/resolved-conf.c
index ca69d70e3..ddf0852c9 100644
--- a/src/resolve/resolved-conf.c
+++ b/src/resolve/resolved-conf.c
@@ -260,7 +260,7 @@ int config_parse_dnssd_service_name(const char *unit, const char *filename, unsi
 
         r = specifier_printf(s->name_template, specifier_table, NULL, &name);
         if (r < 0)
-                return log_debug_errno(r, "Failed to replace specifiers: %m");
+                return log_info_errno(r, "Failed to replace specifiers: %m");
 
         if (!dns_service_name_is_valid(name)) {
                 log_syntax(unit, LOG_ERR, filename, line, 0, "Service instance name template renders to invalid name '%s'. Ignoring.", name);
diff --git a/src/resolve/resolved-dns-cache.c b/src/resolve/resolved-dns-cache.c
index e9197f1df..efb49c9f5 100644
--- a/src/resolve/resolved-dns-cache.c
+++ b/src/resolve/resolved-dns-cache.c
@@ -225,7 +225,7 @@ void dns_cache_prune(DnsCache *c) {
 
                 /* Depending whether this is an mDNS shared entry
                  * either remove only this one RR or the whole RRset */
-                log_debug("Removing %scache entry for %s (expired "USEC_FMT"s ago)",
+                log_info("Removing %scache entry for %s (expired "USEC_FMT"s ago)",
                           i->shared_owner ? "shared " : "",
                           dns_resource_key_to_string(i->key, key_str, sizeof key_str),
                           (t - i->until) / USEC_PER_SEC);
@@ -428,7 +428,7 @@ static int dns_cache_put_positive(
         /* New TTL is 0? Delete this specific entry... */
         if (rr->ttl <= 0) {
                 k = dns_cache_remove_by_rr(c, rr);
-                log_debug("%s: %s",
+                log_info("%s: %s",
                           k > 0 ? "Removed zero TTL entry from cache" : "Not caching zero TTL cache entry",
                           dns_resource_key_to_string(rr->key, key_str, sizeof key_str));
                 return 0;
@@ -481,7 +481,7 @@ static int dns_cache_put_positive(
 
                 (void) in_addr_to_string(i->owner_family, &i->owner_address, &t);
 
-                log_debug("Added positive %s%s cache entry for %s "USEC_FMT"s on %s/%s/%s",
+                log_info("Added positive %s%s cache entry for %s "USEC_FMT"s on %s/%s/%s",
                           i->authenticated ? "authenticated" : "unauthenticated",
                           i->shared_owner ? " shared" : "",
                           dns_resource_key_to_string(i->key, key_str, sizeof key_str),
@@ -528,7 +528,7 @@ static int dns_cache_put_negative(
 
                 /* For negative replies, check if we have a TTL of a SOA */
                 if (nsec_ttl <= 0 || soa->soa.minimum <= 0 || soa->ttl <= 0) {
-                        log_debug("Not caching negative entry with zero SOA/NSEC/NSEC3 TTL: %s",
+                        log_info("Not caching negative entry with zero SOA/NSEC/NSEC3 TTL: %s",
                                   dns_resource_key_to_string(key, key_str, sizeof key_str));
                         return 0;
                 }
@@ -578,7 +578,7 @@ static int dns_cache_put_negative(
         if (r < 0)
                 return r;
 
-        log_debug("Added %s cache entry for %s "USEC_FMT"s",
+        log_info("Added %s cache entry for %s "USEC_FMT"s",
                   dns_cache_item_type_to_string(i),
                   dns_resource_key_to_string(i->key, key_str, sizeof key_str),
                   (i->until - timestamp) / USEC_PER_SEC);
@@ -671,7 +671,7 @@ int dns_cache_put(
                 if (dns_answer_size(answer) <= 0) {
                         char key_str[DNS_RESOURCE_KEY_STRING_MAX];
 
-                        log_debug("Not caching negative entry without a SOA record: %s",
+                        log_info("Not caching negative entry without a SOA record: %s",
                                   dns_resource_key_to_string(key, key_str, sizeof key_str));
                         return 0;
                 }
@@ -859,7 +859,7 @@ int dns_cache_lookup(DnsCache *c, DnsResourceKey *key, bool clamp_ttl, int *rcod
                 /* If we have ANY lookups we don't use the cache, so
                  * that the caller refreshes via the network. */
 
-                log_debug("Ignoring cache for ANY lookup: %s",
+                log_info("Ignoring cache for ANY lookup: %s",
                           dns_resource_key_to_string(key, key_str, sizeof key_str));
 
                 c->n_miss++;
@@ -875,7 +875,7 @@ int dns_cache_lookup(DnsCache *c, DnsResourceKey *key, bool clamp_ttl, int *rcod
         if (!first) {
                 /* If one question cannot be answered we need to refresh */
 
-                log_debug("Cache miss for %s",
+                log_info("Cache miss for %s",
                           dns_resource_key_to_string(key, key_str, sizeof key_str));
 
                 c->n_miss++;
@@ -905,7 +905,7 @@ int dns_cache_lookup(DnsCache *c, DnsResourceKey *key, bool clamp_ttl, int *rcod
         }
 
         if (found_rcode >= 0) {
-                log_debug("RCODE %s cache hit for %s",
+                log_info("RCODE %s cache hit for %s",
                           dns_rcode_to_string(found_rcode),
                           dns_resource_key_to_string(key, key_str, sizeof(key_str)));
 
@@ -921,7 +921,7 @@ int dns_cache_lookup(DnsCache *c, DnsResourceKey *key, bool clamp_ttl, int *rcod
                 /* Note that we won't derive information for DS RRs from an NSEC, because we only cache NSEC RRs from
                  * the lower-zone of a zone cut, but the DS RRs are on the upper zone. */
 
-                log_debug("NSEC NODATA cache hit for %s",
+                log_info("NSEC NODATA cache hit for %s",
                           dns_resource_key_to_string(key, key_str, sizeof key_str));
 
                 /* We only found an NSEC record that matches our name.
@@ -943,7 +943,7 @@ int dns_cache_lookup(DnsCache *c, DnsResourceKey *key, bool clamp_ttl, int *rcod
                 return 0;
         }
 
-        log_debug("%s cache hit for %s",
+        log_info("%s cache hit for %s",
                   n > 0    ? "Positive" :
                   nxdomain ? "NXDOMAIN" : "NODATA",
                   dns_resource_key_to_string(key, key_str, sizeof key_str));
diff --git a/src/resolve/resolved-dns-dnssec.c b/src/resolve/resolved-dns-dnssec.c
index e3eca7e62..495ec0926 100644
--- a/src/resolve/resolved-dns-dnssec.c
+++ b/src/resolve/resolved-dns-dnssec.c
@@ -227,7 +227,7 @@ static int dnssec_rsa_verify_raw(
         if (gpg_err_code(ge) == GPG_ERR_BAD_SIGNATURE)
                 r = 0;
         else if (ge != 0) {
-                log_debug("RSA signature check failed: %s", gpg_strerror(ge));
+                log_info("RSA signature check failed: %s", gpg_strerror(ge));
                 r = -EIO;
         } else
                 r = 1;
@@ -374,7 +374,7 @@ static int dnssec_ecdsa_verify_raw(
         if (gpg_err_code(ge) == GPG_ERR_BAD_SIGNATURE)
                 k = 0;
         else if (ge != 0) {
-                log_debug("ECDSA signature check failed: %s", gpg_strerror(ge));
+                log_info("ECDSA signature check failed: %s", gpg_strerror(ge));
                 k = -EIO;
         } else
                 k = 1;
@@ -489,7 +489,7 @@ static int dnssec_eddsa_verify_raw(
         if (gpg_err_code(ge) == GPG_ERR_BAD_SIGNATURE)
                 k = 0;
         else if (ge != 0) {
-                log_debug("EdDSA signature check failed: %s", gpg_strerror(ge));
+                log_info("EdDSA signature check failed: %s", gpg_strerror(ge));
                 k = -EIO;
         } else
                 k = 1;
@@ -1319,7 +1319,7 @@ int dnssec_nsec3_hash(DnsResourceRecord *nsec3, const char *name, void *ret) {
                 return -EINVAL;
 
         if (nsec3->nsec3.iterations > NSEC3_ITERATIONS_MAX) {
-                log_debug("Ignoring NSEC3 RR %s with excessive number of iterations.", dns_resource_record_to_string(nsec3));
+                log_info("Ignoring NSEC3 RR %s with excessive number of iterations.", dns_resource_record_to_string(nsec3));
                 return -EOPNOTSUPP;
         }
 
diff --git a/src/resolve/resolved-dns-packet.c b/src/resolve/resolved-dns-packet.c
index 2067dd518..c2a3fea80 100644
--- a/src/resolve/resolved-dns-packet.c
+++ b/src/resolve/resolved-dns-packet.c
@@ -2210,7 +2210,7 @@ static int dns_packet_extract_answer(DnsPacket *p, DnsAnswer **ret_answer) {
                                 /* Multiple OPT RRs? if so, let's ignore all, because there's
                                  * something wrong with the server, and if one is valid we wouldn't
                                  * know which one. */
-                                log_debug("Multiple OPT RRs detected, ignoring all.");
+                                log_info("Multiple OPT RRs detected, ignoring all.");
                                 bad_opt = true;
                                 continue;
                         }
@@ -2218,7 +2218,7 @@ static int dns_packet_extract_answer(DnsPacket *p, DnsAnswer **ret_answer) {
                         if (!dns_name_is_root(dns_resource_key_name(rr->key))) {
                                 /* If the OPT RR is not owned by the root domain, then it is bad,
                                  * let's ignore it. */
-                                log_debug("OPT RR is not owned by root domain, ignoring.");
+                                log_info("OPT RR is not owned by root domain, ignoring.");
                                 bad_opt = true;
                                 continue;
                         }
@@ -2227,13 +2227,13 @@ static int dns_packet_extract_answer(DnsPacket *p, DnsAnswer **ret_answer) {
                                 /* OPT RR is in the wrong section? Some Belkin routers do this. This
                                  * is a hint the EDNS implementation is borked, like the Belkin one
                                  * is, hence ignore it. */
-                                log_debug("OPT RR in wrong section, ignoring.");
+                                log_info("OPT RR in wrong section, ignoring.");
                                 bad_opt = true;
                                 continue;
                         }
 
                         if (!opt_is_good(rr, &has_rfc6975)) {
-                                log_debug("Malformed OPT RR, ignoring.");
+                                log_info("Malformed OPT RR, ignoring.");
                                 bad_opt = true;
                                 continue;
                         }
@@ -2244,7 +2244,7 @@ static int dns_packet_extract_answer(DnsPacket *p, DnsAnswer **ret_answer) {
                                 if (!DNS_RESOURCE_RECORD_OPT_VERSION_SUPPORTED(rr)) {
                                         /* If this is a reply and we don't know the EDNS version
                                          * then something is weird... */
-                                        log_debug("EDNS version newer that our request, bad server.");
+                                        log_info("EDNS version newer that our request, bad server.");
                                         return -EBADMSG;
                                 }
 
@@ -2257,7 +2257,7 @@ static int dns_packet_extract_answer(DnsPacket *p, DnsAnswer **ret_answer) {
                                          * be contained in questions, never in replies. Crappy
                                          * Belkin routers copy the OPT data for example, hence let's
                                          * detect this so that we downgrade early. */
-                                        log_debug("OPT RR contained RFC6975 data, ignoring.");
+                                        log_info("OPT RR contained RFC6975 data, ignoring.");
                                         bad_opt = true;
                                         continue;
                                 }
diff --git a/src/resolve/resolved-dns-query.c b/src/resolve/resolved-dns-query.c
index 5f5134074..fe4157e2d 100644
--- a/src/resolve/resolved-dns-query.c
+++ b/src/resolve/resolved-dns-query.c
@@ -485,7 +485,7 @@ int dns_query_new(
 
         /* First dump UTF8  question */
         DNS_QUESTION_FOREACH(key, question_utf8)
-                log_debug("Looking up RR for %s.",
+                log_info("Looking up RR for %s.",
                           dns_resource_key_to_string(key, key_str, sizeof key_str));
 
         /* And then dump the IDNA question, but only what hasn't been dumped already through the UTF8 question. */
@@ -496,7 +496,7 @@ int dns_query_new(
                 if (r > 0)
                         continue;
 
-                log_debug("Looking up IDNA RR for %s.",
+                log_info("Looking up IDNA RR for %s.",
                           dns_resource_key_to_string(key, key_str, sizeof key_str));
         }
 
@@ -962,7 +962,7 @@ static int dns_query_cname_redirect(DnsQuery *q, const DnsResourceRecord *cname)
         if (r < 0)
                 return r;
         else if (r > 0)
-                log_debug("Following CNAME/DNAME %s → %s.", dns_question_first_name(q->question_idna), dns_question_first_name(nq_idna));
+                log_info("Following CNAME/DNAME %s → %s.", dns_question_first_name(q->question_idna), dns_question_first_name(nq_idna));
 
         k = dns_question_is_equal(q->question_idna, q->question_utf8);
         if (k < 0)
@@ -976,7 +976,7 @@ static int dns_query_cname_redirect(DnsQuery *q, const DnsResourceRecord *cname)
                 if (k < 0)
                         return k;
                 else if (k > 0)
-                        log_debug("Following UTF8 CNAME/DNAME %s → %s.", dns_question_first_name(q->question_utf8), dns_question_first_name(nq_utf8));
+                        log_info("Following UTF8 CNAME/DNAME %s → %s.", dns_question_first_name(q->question_utf8), dns_question_first_name(nq_utf8));
         }
 
         if (r == 0 && k == 0) /* No actual cname happened? */
@@ -1070,7 +1070,7 @@ static int on_bus_track(sd_bus_track *t, void *userdata) {
         assert(t);
         assert(q);
 
-        log_debug("Client of active query vanished, aborting query.");
+        log_info("Client of active query vanished, aborting query.");
         dns_query_complete(q, DNS_TRANSACTION_ABORTED);
         return 0;
 }
diff --git a/src/resolve/resolved-dns-scope.c b/src/resolve/resolved-dns-scope.c
index bf6aac830..0b70eccc8 100644
--- a/src/resolve/resolved-dns-scope.c
+++ b/src/resolve/resolved-dns-scope.c
@@ -77,7 +77,7 @@ int dns_scope_new(Manager *m, DnsScope **ret, Link *l, DnsProtocol protocol, int
         dns_scope_llmnr_membership(s, true);
         dns_scope_mdns_membership(s, true);
 
-        log_debug("New scope on link %s, protocol %s, family %s", l ? l->name : "*", dns_protocol_to_string(protocol), family == AF_UNSPEC ? "*" : af_to_name(family));
+        log_info("New scope on link %s, protocol %s, family %s", l ? l->name : "*", dns_protocol_to_string(protocol), family == AF_UNSPEC ? "*" : af_to_name(family));
 
         /* Enforce ratelimiting for the multicast protocols */
         RATELIMIT_INIT(s->ratelimit, MULTICAST_RATELIMIT_INTERVAL_USEC, MULTICAST_RATELIMIT_BURST);
@@ -108,7 +108,7 @@ DnsScope* dns_scope_free(DnsScope *s) {
         if (!s)
                 return NULL;
 
-        log_debug("Removing scope on link %s, protocol %s, family %s", s->link ? s->link->name : "*", dns_protocol_to_string(s->protocol), s->family == AF_UNSPEC ? "*" : af_to_name(s->family));
+        log_info("Removing scope on link %s, protocol %s, family %s", s->link ? s->link->name : "*", dns_protocol_to_string(s->protocol), s->family == AF_UNSPEC ? "*" : af_to_name(s->family));
 
         dns_scope_llmnr_membership(s, false);
         dns_scope_mdns_membership(s, false);
@@ -731,7 +731,7 @@ void dns_scope_process_query(DnsScope *s, DnsStream *stream, DnsPacket *p) {
 
         r = dns_packet_extract(p);
         if (r < 0) {
-                log_debug_errno(r, "Failed to extract resource records from incoming packet: %m");
+                log_info_errno(r, "Failed to extract resource records from incoming packet: %m");
                 return;
         }
 
@@ -746,7 +746,7 @@ void dns_scope_process_query(DnsScope *s, DnsStream *stream, DnsPacket *p) {
 
         r = dns_zone_lookup(&s->zone, key, 0, &answer, &soa, &tentative);
         if (r < 0) {
-                log_debug_errno(r, "Failed to lookup key: %m");
+                log_info_errno(r, "Failed to lookup key: %m");
                 return;
         }
         if (r == 0)
@@ -757,14 +757,14 @@ void dns_scope_process_query(DnsScope *s, DnsStream *stream, DnsPacket *p) {
 
         r = dns_scope_make_reply_packet(s, DNS_PACKET_ID(p), DNS_RCODE_SUCCESS, p->question, answer, soa, tentative, &reply);
         if (r < 0) {
-                log_debug_errno(r, "Failed to build reply packet: %m");
+                log_info_errno(r, "Failed to build reply packet: %m");
                 return;
         }
 
         if (stream) {
                 r = dns_stream_write_packet(stream, reply);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to enqueue reply packet: %m");
+                        log_info_errno(r, "Failed to enqueue reply packet: %m");
                         return;
                 }
 
@@ -784,11 +784,11 @@ void dns_scope_process_query(DnsScope *s, DnsStream *stream, DnsPacket *p) {
                 else if (p->family == AF_INET6)
                         fd = manager_llmnr_ipv6_udp_fd(s->manager);
                 else {
-                        log_debug("Unknown protocol");
+                        log_info("Unknown protocol");
                         return;
                 }
                 if (fd < 0) {
-                        log_debug_errno(fd, "Failed to get reply socket: %m");
+                        log_info_errno(fd, "Failed to get reply socket: %m");
                         return;
                 }
 
@@ -799,7 +799,7 @@ void dns_scope_process_query(DnsScope *s, DnsStream *stream, DnsPacket *p) {
 
                 r = manager_send(s->manager, fd, p->ifindex, p->family, &p->sender, p->sender_port, NULL, reply);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to send reply packet: %m");
+                        log_info_errno(r, "Failed to send reply packet: %m");
                         return;
                 }
         }
@@ -904,7 +904,7 @@ static int on_conflict_dispatch(sd_event_source *es, usec_t usec, void *userdata
 
                 r = dns_scope_emit_udp(scope, -1, p);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to send conflict packet: %m");
+                        log_info_errno(r, "Failed to send conflict packet: %m");
         }
 
         return 0;
@@ -932,7 +932,7 @@ int dns_scope_notify_conflict(DnsScope *scope, DnsResourceRecord *rr) {
         if (IN_SET(r, 0, -EEXIST))
                 return 0;
         if (r < 0)
-                return log_debug_errno(r, "Failed to queue conflicting RR: %m");
+                return log_info_errno(r, "Failed to queue conflicting RR: %m");
 
         dns_resource_key_ref(rr->key);
         dns_resource_record_ref(rr);
@@ -950,7 +950,7 @@ int dns_scope_notify_conflict(DnsScope *scope, DnsResourceRecord *rr) {
                               LLMNR_JITTER_INTERVAL_USEC,
                               on_conflict_dispatch, scope);
         if (r < 0)
-                return log_debug_errno(r, "Failed to add conflict dispatch event: %m");
+                return log_info_errno(r, "Failed to add conflict dispatch event: %m");
 
         (void) sd_event_source_set_description(scope->conflict_event_source, "scope-conflict");
 
@@ -983,11 +983,11 @@ void dns_scope_check_conflicts(DnsScope *scope, DnsPacket *p) {
 
         r = dns_packet_extract(p);
         if (r < 0) {
-                log_debug_errno(r, "Failed to extract packet: %m");
+                log_info_errno(r, "Failed to extract packet: %m");
                 return;
         }
 
-        log_debug("Checking for conflicts...");
+        log_info("Checking for conflicts...");
 
         DNS_ANSWER_FOREACH(rr, p->answer) {
                 /* No conflict if it is DNS-SD RR used for service enumeration. */
@@ -1129,7 +1129,7 @@ int dns_scope_announce(DnsScope *scope, bool goodbye) {
                     !dns_zone_contains_name(&scope->zone, z->rr->ptr.name)) {
                         char key_str[DNS_RESOURCE_KEY_STRING_MAX];
 
-                        log_debug("Skip PTR RR <%s> since its counterparts seem to be withdrawn", dns_resource_key_to_string(z->rr->key, key_str, sizeof key_str));
+                        log_info("Skip PTR RR <%s> since its counterparts seem to be withdrawn", dns_resource_key_to_string(z->rr->key, key_str, sizeof key_str));
                         z->state = DNS_ZONE_ITEM_WITHDRAWN;
                         continue;
                 }
@@ -1140,11 +1140,11 @@ int dns_scope_announce(DnsScope *scope, bool goodbye) {
                         if (!set_contains(types, dns_resource_key_name(z->rr->key))) {
                                 r = set_ensure_allocated(&types, &dns_name_hash_ops);
                                 if (r < 0)
-                                        return log_debug_errno(r, "Failed to allocate set: %m");
+                                        return log_info_errno(r, "Failed to allocate set: %m");
 
                                 r = set_put(types, dns_resource_key_name(z->rr->key));
                                 if (r < 0)
-                                        return log_debug_errno(r, "Failed to add item to set: %m");
+                                        return log_info_errno(r, "Failed to add item to set: %m");
                         }
                 }
 
@@ -1171,7 +1171,7 @@ int dns_scope_announce(DnsScope *scope, bool goodbye) {
 
                         r = dns_answer_add(answer, i->rr, 0 , flags);
                         if (r < 0)
-                                return log_debug_errno(r, "Failed to add RR to announce: %m");
+                                return log_info_errno(r, "Failed to add RR to announce: %m");
                 }
 
         /* Since all the active services are in the zone make them discoverable now. */
@@ -1189,7 +1189,7 @@ int dns_scope_announce(DnsScope *scope, bool goodbye) {
 
                 r = dns_answer_add(answer, rr, 0 , 0);
                 if (r < 0)
-                        return log_debug_errno(r, "Failed to add RR to announce: %m");
+                        return log_info_errno(r, "Failed to add RR to announce: %m");
         }
 
         if (dns_answer_isempty(answer))
@@ -1197,11 +1197,11 @@ int dns_scope_announce(DnsScope *scope, bool goodbye) {
 
         r = dns_scope_make_reply_packet(scope, 0, DNS_RCODE_SUCCESS, NULL, answer, NULL, false, &p);
         if (r < 0)
-                return log_debug_errno(r, "Failed to build reply packet: %m");
+                return log_info_errno(r, "Failed to build reply packet: %m");
 
         r = dns_scope_emit_udp(scope, -1, p);
         if (r < 0)
-                return log_debug_errno(r, "Failed to send reply packet: %m");
+                return log_info_errno(r, "Failed to send reply packet: %m");
 
         /* In section 8.3 of RFC6762: "The Multicast DNS responder MUST send at least two unsolicited
          * responses, one second apart." */
@@ -1221,7 +1221,7 @@ int dns_scope_announce(DnsScope *scope, bool goodbye) {
                                 MDNS_JITTER_RANGE_USEC,
                                 on_announcement_timeout, scope);
                 if (r < 0)
-                        return log_debug_errno(r, "Failed to schedule second announcement: %m");
+                        return log_info_errno(r, "Failed to schedule second announcement: %m");
 
                 (void) sd_event_source_set_description(scope->announce_event_source, "mdns-announce");
         }
diff --git a/src/resolve/resolved-dns-server.c b/src/resolve/resolved-dns-server.c
index 68c5d5c1e..656119eb6 100644
--- a/src/resolve/resolved-dns-server.c
+++ b/src/resolve/resolved-dns-server.c
@@ -233,7 +233,7 @@ static void dns_server_verified(DnsServer *s, DnsServerFeatureLevel level) {
                 return;
 
         if (s->verified_feature_level != level) {
-                log_debug("Verified we get a response at feature level %s from DNS server %s.",
+                log_info("Verified we get a response at feature level %s from DNS server %s.",
                           dns_server_feature_level_to_string(level),
                           dns_server_string(s));
                 s->verified_feature_level = level;
@@ -377,7 +377,7 @@ void dns_server_packet_rcode_downgrade(DnsServer *s, DnsServerFeatureLevel level
                 dns_server_reset_counters(s);
         }
 
-        log_debug("Downgrading transaction feature level fixed an RCODE error, downgrading server %s too.", dns_server_string(s));
+        log_info("Downgrading transaction feature level fixed an RCODE error, downgrading server %s too.", dns_server_string(s));
 }
 
 static bool dns_server_grace_period_expired(DnsServer *s) {
@@ -440,7 +440,7 @@ DnsServerFeatureLevel dns_server_possible_feature_level(DnsServer *s) {
 
                         /* We are at the TCP (lowest) level, and we tried a couple of TCP connections, and it didn't
                          * work. Upgrade back to UDP again. */
-                        log_debug("Reached maximum number of failed TCP connection attempts, trying UDP again...");
+                        log_info("Reached maximum number of failed TCP connection attempts, trying UDP again...");
                         s->possible_feature_level = DNS_SERVER_FEATURE_LEVEL_UDP;
 
                 } else if (s->packet_bad_opt &&
@@ -451,7 +451,7 @@ DnsServerFeatureLevel dns_server_possible_feature_level(DnsServer *s) {
                          * in the request. Example:
                          * https://open.nlnetlabs.nl/pipermail/dnssec-trigger/2014-November/000376.html */
 
-                        log_debug("Server doesn't support EDNS(0) properly, downgrading feature level...");
+                        log_info("Server doesn't support EDNS(0) properly, downgrading feature level...");
                         s->possible_feature_level = DNS_SERVER_FEATURE_LEVEL_UDP;
 
                 } else if (s->packet_rrsig_missing &&
@@ -462,7 +462,7 @@ DnsServerFeatureLevel dns_server_possible_feature_level(DnsServer *s) {
                          * after all some servers generate different replies depending if an OPT RR is in the query or
                          * not. */
 
-                        log_debug("Detected server responses lack RRSIG records, downgrading feature level...");
+                        log_info("Detected server responses lack RRSIG records, downgrading feature level...");
                         s->possible_feature_level = DNS_SERVER_FEATURE_LEVEL_EDNS0;
 
                 } else if (s->n_failed_udp >= DNS_SERVER_FEATURE_RETRY_ATTEMPTS &&
@@ -476,7 +476,7 @@ DnsServerFeatureLevel dns_server_possible_feature_level(DnsServer *s) {
                          * might have many reasons, a broken DNSSEC implementation being only one reason. And if the
                          * user is strict on DNSSEC, then let's assume that DNSSEC is not the fault here. */
 
-                        log_debug("Lost too many UDP packets, downgrading feature level...");
+                        log_info("Lost too many UDP packets, downgrading feature level...");
                         s->possible_feature_level--;
 
                 } else if (s->n_failed_tcp >= DNS_SERVER_FEATURE_RETRY_ATTEMPTS &&
@@ -489,7 +489,7 @@ DnsServerFeatureLevel dns_server_possible_feature_level(DnsServer *s) {
                           * appears not to be a fallback. Note that if we are already at the lowest UDP level, we don't
                           * go further down, since that's TCP, and TCP failed too often after all. */
 
-                        log_debug("Got too many failed TCP connection failures and truncated UDP packets, downgrading feature level...");
+                        log_info("Got too many failed TCP connection failures and truncated UDP packets, downgrading feature level...");
                         s->possible_feature_level--;
                 }
 
@@ -717,7 +717,7 @@ DnsServer *manager_set_dns_server(Manager *m, DnsServer *s) {
                 return s;
 
         if (s)
-                log_debug("Switching to %s DNS server %s.",
+                log_info("Switching to %s DNS server %s.",
                           dns_server_type_to_string(s->type),
                           dns_server_string(s));
 
diff --git a/src/resolve/resolved-dns-stream.c b/src/resolve/resolved-dns-stream.c
index 52f23cd86..249f3e1fd 100644
--- a/src/resolve/resolved-dns-stream.c
+++ b/src/resolve/resolved-dns-stream.c
@@ -175,11 +175,11 @@ static int dns_stream_identify(DnsStream *s) {
                 if (s->local.sa.sa_family == AF_INET) {
                         r = setsockopt(s->fd, IPPROTO_IP, IP_UNICAST_IF, &ifindex, sizeof(ifindex));
                         if (r < 0)
-                                log_debug_errno(errno, "Failed to invoke IP_UNICAST_IF: %m");
+                                log_info_errno(errno, "Failed to invoke IP_UNICAST_IF: %m");
                 } else if (s->local.sa.sa_family == AF_INET6) {
                         r = setsockopt(s->fd, IPPROTO_IPV6, IPV6_UNICAST_IF, &ifindex, sizeof(ifindex));
                         if (r < 0)
-                                log_debug_errno(errno, "Failed to invoke IPV6_UNICAST_IF: %m");
+                                log_info_errno(errno, "Failed to invoke IPV6_UNICAST_IF: %m");
                 }
         }
 
diff --git a/src/resolve/resolved-dns-stub.c b/src/resolve/resolved-dns-stub.c
index 5ce8d240d..627eecc77 100644
--- a/src/resolve/resolved-dns-stub.c
+++ b/src/resolve/resolved-dns-stub.c
@@ -165,7 +165,7 @@ static int dns_stub_send(Manager *m, DnsStream *s, DnsPacket *p, DnsPacket *repl
 
                 fd = manager_dns_stub_udp_fd(m);
                 if (fd < 0)
-                        return log_debug_errno(fd, "Failed to get reply socket: %m");
+                        return log_info_errno(fd, "Failed to get reply socket: %m");
 
                 /* Note that it is essential here that we explicitly choose the source IP address for this packet. This
                  * is because otherwise the kernel will choose it automatically based on the routing table and will
@@ -174,7 +174,7 @@ static int dns_stub_send(Manager *m, DnsStream *s, DnsPacket *p, DnsPacket *repl
                 r = manager_send(m, fd, LOOPBACK_IFINDEX, p->family, &p->sender, p->sender_port, &p->destination, reply);
         }
         if (r < 0)
-                return log_debug_errno(r, "Failed to send reply packet: %m");
+                return log_info_errno(r, "Failed to send reply packet: %m");
 
         return 0;
 }
@@ -188,11 +188,11 @@ static int dns_stub_send_failure(Manager *m, DnsStream *s, DnsPacket *p, int rco
 
         r = dns_stub_make_reply_packet(&reply, DNS_PACKET_PAYLOAD_SIZE_MAX(p), p->question, NULL, NULL);
         if (r < 0)
-                return log_debug_errno(r, "Failed to make failure packet: %m");
+                return log_info_errno(r, "Failed to make failure packet: %m");
 
         r = dns_stub_finish_reply_packet(reply, DNS_PACKET_ID(p), rcode, false, !!p->opt, DNS_PACKET_DO(p), authenticated);
         if (r < 0)
-                return log_debug_errno(r, "Failed to build failure packet: %m");
+                return log_info_errno(r, "Failed to build failure packet: %m");
 
         return dns_stub_send(m, s, p, reply);
 }
@@ -210,7 +210,7 @@ static void dns_stub_query_complete(DnsQuery *q) {
 
                 r = dns_stub_make_reply_packet(&q->reply_dns_packet, DNS_PACKET_PAYLOAD_SIZE_MAX(q->request_dns_packet), q->question_idna, q->answer, &truncated);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to build reply packet: %m");
+                        log_info_errno(r, "Failed to build reply packet: %m");
                         break;
                 }
 
@@ -220,7 +220,7 @@ static void dns_stub_query_complete(DnsQuery *q) {
                         break;
                 }
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to process CNAME: %m");
+                        log_info_errno(r, "Failed to process CNAME: %m");
                         break;
                 }
                 if (r == DNS_QUERY_RESTARTED)
@@ -235,7 +235,7 @@ static void dns_stub_query_complete(DnsQuery *q) {
                                 DNS_PACKET_DO(q->request_dns_packet),
                                 dns_query_fully_authenticated(q));
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to finish reply packet: %m");
+                        log_info_errno(r, "Failed to finish reply packet: %m");
                         break;
                 }
 
@@ -290,7 +290,7 @@ static void dns_stub_query_complete(DnsQuery *q) {
 static int dns_stub_stream_complete(DnsStream *s, int error) {
         assert(s);
 
-        log_debug_errno(error, "DNS TCP connection terminated, destroying query: %m");
+        log_info_errno(error, "DNS TCP connection terminated, destroying query: %m");
 
         assert(s->query);
         dns_query_free(s->query);
@@ -317,38 +317,38 @@ static void dns_stub_process_query(Manager *m, DnsStream *s, DnsPacket *p) {
 
         r = dns_packet_extract(p);
         if (r < 0) {
-                log_debug_errno(r, "Failed to extract resources from incoming packet, ignoring packet: %m");
+                log_info_errno(r, "Failed to extract resources from incoming packet, ignoring packet: %m");
                 dns_stub_send_failure(m, s, p, DNS_RCODE_FORMERR, false);
                 goto fail;
         }
 
         if (!DNS_PACKET_VERSION_SUPPORTED(p)) {
-                log_debug("Got EDNS OPT field with unsupported version number.");
+                log_info("Got EDNS OPT field with unsupported version number.");
                 dns_stub_send_failure(m, s, p, DNS_RCODE_BADVERS, false);
                 goto fail;
         }
 
         if (dns_type_is_obsolete(p->question->keys[0]->type)) {
-                log_debug("Got message with obsolete key type, refusing.");
+                log_info("Got message with obsolete key type, refusing.");
                 dns_stub_send_failure(m, s, p, DNS_RCODE_NOTIMP, false);
                 goto fail;
         }
 
         if (dns_type_is_zone_transer(p->question->keys[0]->type)) {
-                log_debug("Got request for zone transfer, refusing.");
+                log_info("Got request for zone transfer, refusing.");
                 dns_stub_send_failure(m, s, p, DNS_RCODE_NOTIMP, false);
                 goto fail;
         }
 
         if (!DNS_PACKET_RD(p))  {
                 /* If the "rd" bit is off (i.e. recursion was not requested), then refuse operation */
-                log_debug("Got request with recursion disabled, refusing.");
+                log_info("Got request with recursion disabled, refusing.");
                 dns_stub_send_failure(m, s, p, DNS_RCODE_REFUSED, false);
                 goto fail;
         }
 
         if (DNS_PACKET_DO(p) && DNS_PACKET_CD(p)) {
-                log_debug("Got request with DNSSEC CD bit set, refusing.");
+                log_info("Got request with DNSSEC CD bit set, refusing.");
                 dns_stub_send_failure(m, s, p, DNS_RCODE_NOTIMP, false);
                 goto fail;
         }
@@ -380,7 +380,7 @@ static void dns_stub_process_query(Manager *m, DnsStream *s, DnsPacket *p) {
                 goto fail;
         }
 
-        log_debug("Processing query...");
+        log_info("Processing query...");
         return;
 
 fail:
@@ -400,11 +400,11 @@ static int on_dns_stub_packet(sd_event_source *s, int fd, uint32_t revents, void
                 return r;
 
         if (dns_packet_validate_query(p) > 0) {
-                log_debug("Got DNS stub UDP query packet for id %u", DNS_PACKET_ID(p));
+                log_info("Got DNS stub UDP query packet for id %u", DNS_PACKET_ID(p));
 
                 dns_stub_process_query(m, NULL, p);
         } else
-                log_debug("Invalid DNS stub UDP packet, ignoring.");
+                log_info("Invalid DNS stub UDP packet, ignoring.");
 
         return 0;
 }
@@ -458,11 +458,11 @@ static int on_dns_stub_stream_packet(DnsStream *s) {
         assert(s->read_packet);
 
         if (dns_packet_validate_query(s->read_packet) > 0) {
-                log_debug("Got DNS stub TCP query packet for id %u", DNS_PACKET_ID(s->read_packet));
+                log_info("Got DNS stub TCP query packet for id %u", DNS_PACKET_ID(s->read_packet));
 
                 dns_stub_process_query(s->manager, s, s->read_packet);
         } else
-                log_debug("Invalid DNS stub TCP packet, ignoring.");
+                log_info("Invalid DNS stub TCP packet, ignoring.");
 
         /* Drop the reference to the stream. Either a query was created and added its own reference to the stream now,
          * or that didn't happen in which case we want to free the stream */
@@ -555,9 +555,9 @@ int manager_dns_stub_start(Manager *m) {
         assert(m);
 
         if (m->dns_stub_listener_mode == DNS_STUB_LISTENER_NO)
-                log_debug("Not creating stub listener.");
+                log_info("Not creating stub listener.");
         else
-                log_debug("Creating stub listener using %s.",
+                log_info("Creating stub listener using %s.",
                           m->dns_stub_listener_mode == DNS_STUB_LISTENER_UDP ? "UDP" :
                           m->dns_stub_listener_mode == DNS_STUB_LISTENER_TCP ? "TCP" :
                           "UDP/TCP");
diff --git a/src/resolve/resolved-dns-transaction.c b/src/resolve/resolved-dns-transaction.c
index f4bbde021..7ae6aabda 100644
--- a/src/resolve/resolved-dns-transaction.c
+++ b/src/resolve/resolved-dns-transaction.c
@@ -88,7 +88,7 @@ DnsTransaction* dns_transaction_free(DnsTransaction *t) {
         if (!t)
                 return NULL;
 
-        log_debug("Freeing transaction %" PRIu16 ".", t->id);
+        log_info("Freeing transaction %" PRIu16 ".", t->id);
 
         dns_transaction_close_connection(t);
         dns_transaction_stop_timeout(t);
@@ -253,7 +253,7 @@ static void dns_transaction_shuffle_id(DnsTransaction *t) {
         new_id = pick_new_id(t->scope->manager);
         assert_se(hashmap_remove_and_put(t->scope->manager->dns_transactions, UINT_TO_PTR(t->id), UINT_TO_PTR(new_id), t) >= 0);
 
-        log_debug("Transaction %" PRIu16 " is now %" PRIu16 ".", t->id, new_id);
+        log_info("Transaction %" PRIu16 " is now %" PRIu16 ".", t->id, new_id);
         t->id = new_id;
 
         /* Make sure we generate a new packet with the new ID */
@@ -273,7 +273,7 @@ static void dns_transaction_tentative(DnsTransaction *t, DnsPacket *p) {
 
         (void) in_addr_to_string(p->family, &p->sender, &pretty);
 
-        log_debug("Transaction %" PRIu16 " for <%s> on scope %s on %s/%s got tentative packet from %s.",
+        log_info("Transaction %" PRIu16 " for <%s> on scope %s on %s/%s got tentative packet from %s.",
                   t->id,
                   dns_resource_key_to_string(t->key, key_str, sizeof key_str),
                   dns_protocol_to_string(t->scope->protocol),
@@ -284,11 +284,11 @@ static void dns_transaction_tentative(DnsTransaction *t, DnsPacket *p) {
         /* RFC 4795, Section 4.1 says that the peer with the
          * lexicographically smaller IP address loses */
         if (memcmp(&p->sender, &p->destination, FAMILY_ADDRESS_SIZE(p->family)) >= 0) {
-                log_debug("Peer has lexicographically larger IP address and thus lost in the conflict.");
+                log_info("Peer has lexicographically larger IP address and thus lost in the conflict.");
                 return;
         }
 
-        log_debug("We have the lexicographically larger IP address and thus lost in the conflict.");
+        log_info("We have the lexicographically larger IP address and thus lost in the conflict.");
 
         t->block_gc++;
 
@@ -339,7 +339,7 @@ void dns_transaction_complete(DnsTransaction *t, DnsTransactionState state) {
         else
                 st = dns_transaction_state_to_string(state);
 
-        log_debug("Transaction %" PRIu16 " for <%s> on scope %s on %s/%s now complete with <%s> from %s (%s).",
+        log_info("Transaction %" PRIu16 " for <%s> on scope %s on %s/%s now complete with <%s> from %s (%s).",
                   t->id,
                   dns_resource_key_to_string(t->key, key_str, sizeof key_str),
                   dns_protocol_to_string(t->scope->protocol),
@@ -400,7 +400,7 @@ static int dns_transaction_pick_server(DnsTransaction *t) {
             t->current_feature_level > t->clamp_feature_level)
                 t->current_feature_level = t->clamp_feature_level;
 
-        log_debug("Using feature level %s for transaction %u.", dns_server_feature_level_to_string(t->current_feature_level), t->id);
+        log_info("Using feature level %s for transaction %u.", dns_server_feature_level_to_string(t->current_feature_level), t->id);
 
         if (server == t->server)
                 return 0;
@@ -410,7 +410,7 @@ static int dns_transaction_pick_server(DnsTransaction *t) {
 
         t->n_picked_servers ++;
 
-        log_debug("Using DNS server %s for transaction %u.", dns_server_string(t->server), t->id);
+        log_info("Using DNS server %s for transaction %u.", dns_server_string(t->server), t->id);
 
         return 1;
 }
@@ -420,7 +420,7 @@ static void dns_transaction_retry(DnsTransaction *t, bool next_server) {
 
         assert(t);
 
-        log_debug("Retrying transaction %" PRIu16 ".", t->id);
+        log_info("Retrying transaction %" PRIu16 ".", t->id);
 
         /* Before we try again, switch to a new server. */
         if (next_server)
@@ -452,7 +452,7 @@ static int dns_transaction_maybe_restart(DnsTransaction *t) {
            OPT RR or DO bit. One of these cases is documented here, for example:
            https://open.nlnetlabs.nl/pipermail/dnssec-trigger/2014-November/000376.html */
 
-        log_debug("Server feature level is now lower than when we began our transaction. Restarting with new ID.");
+        log_info("Server feature level is now lower than when we began our transaction. Restarting with new ID.");
         dns_transaction_shuffle_id(t);
 
         r = dns_transaction_go(t);
@@ -486,7 +486,7 @@ static int on_stream_complete(DnsStream *s, int error) {
                         return 0;
                 }
 
-                log_debug_errno(error, "Connection failure for DNS TCP stream: %m");
+                log_info_errno(error, "Connection failure for DNS TCP stream: %m");
                 assert_se(sd_event_now(t->scope->manager->event, clock_boottime_or_monotonic(), &usec) >= 0);
                 dns_server_packet_lost(t->server, IPPROTO_TCP, t->current_feature_level, usec - t->start_usec);
 
@@ -500,7 +500,7 @@ static int on_stream_complete(DnsStream *s, int error) {
         }
 
         if (dns_packet_validate_reply(p) <= 0) {
-                log_debug("Invalid TCP reply packet.");
+                log_info("Invalid TCP reply packet.");
                 dns_transaction_complete(t, DNS_TRANSACTION_INVALID_REPLY);
                 return 0;
         }
@@ -669,7 +669,7 @@ static int dns_transaction_dnssec_ready(DnsTransaction *t) {
 
                 case DNS_TRANSACTION_RCODE_FAILURE:
                         if (!IN_SET(dt->answer_rcode, DNS_RCODE_NXDOMAIN, DNS_RCODE_SERVFAIL)) {
-                                log_debug("Auxiliary DNSSEC RR query failed with rcode=%s.", dns_rcode_to_string(dt->answer_rcode));
+                                log_info("Auxiliary DNSSEC RR query failed with rcode=%s.", dns_rcode_to_string(dt->answer_rcode));
                                 goto fail;
                         }
 
@@ -686,14 +686,14 @@ static int dns_transaction_dnssec_ready(DnsTransaction *t) {
                         /* We handle DNSSEC failures different from other errors, as we care about the DNSSEC
                          * validationr result */
 
-                        log_debug("Auxiliary DNSSEC RR query failed validation: %s", dnssec_result_to_string(dt->answer_dnssec_result));
+                        log_info("Auxiliary DNSSEC RR query failed validation: %s", dnssec_result_to_string(dt->answer_dnssec_result));
                         t->answer_dnssec_result = dt->answer_dnssec_result; /* Copy error code over */
                         dns_transaction_complete(t, DNS_TRANSACTION_DNSSEC_FAILED);
                         return 0;
 
 
                 default:
-                        log_debug("Auxiliary DNSSEC RR query failed with %s", dns_transaction_state_to_string(dt->state));
+                        log_info("Auxiliary DNSSEC RR query failed with %s", dns_transaction_state_to_string(dt->state));
                         goto fail;
                 }
         }
@@ -845,7 +845,7 @@ void dns_transaction_process_reply(DnsTransaction *t, DnsPacket *p) {
          * should hence not attempt to access the query or transaction
          * after calling this function. */
 
-        log_debug("Processing incoming packet on transaction %" PRIu16". (rcode=%s)", t->id, dns_rcode_to_string(DNS_PACKET_RCODE(p)));
+        log_info("Processing incoming packet on transaction %" PRIu16". (rcode=%s)", t->id, dns_rcode_to_string(DNS_PACKET_RCODE(p)));
 
         switch (t->scope->protocol) {
 
@@ -939,14 +939,14 @@ void dns_transaction_process_reply(DnsTransaction *t, DnsPacket *p) {
                                 }
 
                                 /* Give up, accept the rcode */
-                                log_debug("Server returned error: %s", dns_rcode_to_string(DNS_PACKET_RCODE(p)));
+                                log_info("Server returned error: %s", dns_rcode_to_string(DNS_PACKET_RCODE(p)));
                                 break;
                         }
 
                         /* Reduce this feature level by one and try again. */
                         t->clamp_feature_level = t->current_feature_level - 1;
 
-                        log_debug("Server returned error %s, retrying transaction with reduced feature level %s.",
+                        log_info("Server returned error %s, retrying transaction with reduced feature level %s.",
                                   dns_rcode_to_string(DNS_PACKET_RCODE(p)),
                                   dns_server_feature_level_to_string(t->clamp_feature_level));
 
@@ -956,7 +956,7 @@ void dns_transaction_process_reply(DnsTransaction *t, DnsPacket *p) {
 
                 if (DNS_PACKET_RCODE(p) == DNS_RCODE_REFUSED) {
                         /* This server refused our request? If so, try again, use a different server */
-                        log_debug("Server returned REFUSED, switching servers, and retrying.");
+                        log_info("Server returned REFUSED, switching servers, and retrying.");
                         dns_transaction_retry(t, true /* pick a new server */);
                         return;
                 }
@@ -983,7 +983,7 @@ void dns_transaction_process_reply(DnsTransaction *t, DnsPacket *p) {
                         return;
                 }
 
-                log_debug("Reply truncated, retrying via TCP.");
+                log_info("Reply truncated, retrying via TCP.");
 
                 /* Response was truncated, let's try again with good old TCP */
                 r = dns_transaction_open_tcp(t);
@@ -1117,7 +1117,7 @@ static int on_dns_packet(sd_event_source *s, int fd, uint32_t revents, void *use
                 /* UDP connection failure get reported via ICMP and then are possible delivered to us on the next
                  * recvmsg(). Treat this like a lost packet. */
 
-                log_debug_errno(r, "Connection failure for DNS UDP packet: %m");
+                log_info_errno(r, "Connection failure for DNS UDP packet: %m");
                 assert_se(sd_event_now(t->scope->manager->event, clock_boottime_or_monotonic(), &usec) >= 0);
                 dns_server_packet_lost(t->server, IPPROTO_UDP, t->current_feature_level, usec - t->start_usec);
 
@@ -1132,16 +1132,16 @@ static int on_dns_packet(sd_event_source *s, int fd, uint32_t revents, void *use
 
         r = dns_packet_validate_reply(p);
         if (r < 0) {
-                log_debug_errno(r, "Received invalid DNS packet as response, ignoring: %m");
+                log_info_errno(r, "Received invalid DNS packet as response, ignoring: %m");
                 return 0;
         }
         if (r == 0) {
-                log_debug("Received inappropriate DNS packet as response, ignoring.");
+                log_info("Received inappropriate DNS packet as response, ignoring.");
                 return 0;
         }
 
         if (DNS_PACKET_ID(p) != t->id) {
-                log_debug("Received packet with incorrect transaction ID, ignoring.");
+                log_info("Received packet with incorrect transaction ID, ignoring.");
                 return 0;
         }
 
@@ -1228,7 +1228,7 @@ static int on_transaction_timeout(sd_event_source *s, usec_t usec, void *userdat
                         t->initial_jitter_elapsed = true;
         }
 
-        log_debug("Timeout reached on transaction %" PRIu16 ".", t->id);
+        log_info("Timeout reached on transaction %" PRIu16 ".", t->id);
 
         dns_transaction_retry(t, true);
         return 0;
@@ -1581,7 +1581,7 @@ int dns_transaction_go(DnsTransaction *t) {
         if (r <= 0)
                 return r;
 
-        log_debug("Transaction %" PRIu16 " for <%s> scope %s on %s/%s.",
+        log_info("Transaction %" PRIu16 " for <%s> scope %s on %s/%s.",
                   t->id,
                   dns_resource_key_to_string(t->key, key_str, sizeof key_str),
                   dns_protocol_to_string(t->scope->protocol),
@@ -1630,7 +1630,7 @@ int dns_transaction_go(DnsTransaction *t) {
                 t->next_attempt_after = ts;
                 t->state = DNS_TRANSACTION_PENDING;
 
-                log_debug("Delaying %s transaction for " USEC_FMT "us.", dns_protocol_to_string(t->scope->protocol), jitter);
+                log_info("Delaying %s transaction for " USEC_FMT "us.", dns_protocol_to_string(t->scope->protocol), jitter);
                 return 0;
         }
 
@@ -1651,9 +1651,9 @@ int dns_transaction_go(DnsTransaction *t) {
                  * support try via TCP */
                 r = dns_transaction_emit_udp(t);
                 if (r == -EMSGSIZE)
-                        log_debug("Sending query via TCP since it is too large.");
+                        log_info("Sending query via TCP since it is too large.");
                 else if (r == -EAGAIN)
-                        log_debug("Sending query via TCP since server doesn't support UDP.");
+                        log_info("Sending query via TCP since server doesn't support UDP.");
                 if (IN_SET(r, -EMSGSIZE, -EAGAIN))
                         r = dns_transaction_open_tcp(t);
         }
@@ -1750,7 +1750,7 @@ static int dns_transaction_add_dnssec_transaction(DnsTransaction *t, DnsResource
                 if (r > 0) {
                         char s[DNS_RESOURCE_KEY_STRING_MAX], saux[DNS_RESOURCE_KEY_STRING_MAX];
 
-                        log_debug("Potential cyclic dependency, refusing to add transaction %" PRIu16 " (%s) as dependency for %" PRIu16 " (%s).",
+                        log_info("Potential cyclic dependency, refusing to add transaction %" PRIu16 " (%s) as dependency for %" PRIu16 " (%s).",
                                   aux->id,
                                   dns_resource_key_to_string(t->key, s, sizeof s),
                                   t->id,
@@ -2017,7 +2017,7 @@ int dns_transaction_request_dnssec_keys(DnsTransaction *t) {
                         if (!dnskey)
                                 return -ENOMEM;
 
-                        log_debug("Requesting DNSKEY to validate transaction %" PRIu16" (%s, RRSIG with key tag: %" PRIu16 ").",
+                        log_info("Requesting DNSKEY to validate transaction %" PRIu16" (%s, RRSIG with key tag: %" PRIu16 ").",
                                   t->id, dns_resource_key_name(rr->key), rr->rrsig.key_tag);
                         r = dns_transaction_request_dnssec_rr(t, dnskey);
                         if (r < 0)
@@ -2046,7 +2046,7 @@ int dns_transaction_request_dnssec_keys(DnsTransaction *t) {
                         if (!ds)
                                 return -ENOMEM;
 
-                        log_debug("Requesting DS to validate transaction %" PRIu16" (%s, DNSKEY with key tag: %" PRIu16 ").",
+                        log_info("Requesting DS to validate transaction %" PRIu16" (%s, DNSKEY with key tag: %" PRIu16 ").",
                                   t->id, dns_resource_key_name(rr->key), dnssec_keytag(rr, false));
                         r = dns_transaction_request_dnssec_rr(t, ds);
                         if (r < 0)
@@ -2092,7 +2092,7 @@ int dns_transaction_request_dnssec_keys(DnsTransaction *t) {
                         if (!ds)
                                 return -ENOMEM;
 
-                        log_debug("Requesting DS to validate transaction %" PRIu16 " (%s, unsigned SOA/NS RRset).",
+                        log_info("Requesting DS to validate transaction %" PRIu16 " (%s, unsigned SOA/NS RRset).",
                                   t->id, dns_resource_key_name(rr->key));
                         r = dns_transaction_request_dnssec_rr(t, ds);
                         if (r < 0)
@@ -2146,7 +2146,7 @@ int dns_transaction_request_dnssec_keys(DnsTransaction *t) {
                         if (!soa)
                                 return -ENOMEM;
 
-                        log_debug("Requesting parent SOA to validate transaction %" PRIu16 " (%s, unsigned CNAME/DNAME/DS RRset).",
+                        log_info("Requesting parent SOA to validate transaction %" PRIu16 " (%s, unsigned CNAME/DNAME/DS RRset).",
                                   t->id, dns_resource_key_name(rr->key));
                         r = dns_transaction_request_dnssec_rr(t, soa);
                         if (r < 0)
@@ -2181,7 +2181,7 @@ int dns_transaction_request_dnssec_keys(DnsTransaction *t) {
                         if (!soa)
                                 return -ENOMEM;
 
-                        log_debug("Requesting SOA to validate transaction %" PRIu16 " (%s, unsigned non-SOA/NS RRset <%s>).",
+                        log_info("Requesting SOA to validate transaction %" PRIu16 " (%s, unsigned non-SOA/NS RRset <%s>).",
                                   t->id, dns_resource_key_name(rr->key), dns_resource_record_to_string(rr));
                         r = dns_transaction_request_dnssec_rr(t, soa);
                         if (r < 0)
@@ -2214,7 +2214,7 @@ int dns_transaction_request_dnssec_keys(DnsTransaction *t) {
                         r = dns_name_parent(&name);
                         if (r > 0) {
                                 type = DNS_TYPE_SOA;
-                                log_debug("Requesting parent SOA to validate transaction %" PRIu16 " (%s, unsigned empty DS response).",
+                                log_info("Requesting parent SOA to validate transaction %" PRIu16 " (%s, unsigned empty DS response).",
                                           t->id, dns_resource_key_name(t->key));
                         } else
                                 name = NULL;
@@ -2222,12 +2222,12 @@ int dns_transaction_request_dnssec_keys(DnsTransaction *t) {
                 } else if (IN_SET(t->key->type, DNS_TYPE_SOA, DNS_TYPE_NS)) {
 
                         type = DNS_TYPE_DS;
-                        log_debug("Requesting DS to validate transaction %" PRIu16 " (%s, unsigned empty SOA/NS response).",
+                        log_info("Requesting DS to validate transaction %" PRIu16 " (%s, unsigned empty SOA/NS response).",
                                   t->id, dns_resource_key_name(t->key));
 
                 } else {
                         type = DNS_TYPE_SOA;
-                        log_debug("Requesting SOA to validate transaction %" PRIu16 " (%s, unsigned empty non-SOA/NS/DS response).",
+                        log_info("Requesting SOA to validate transaction %" PRIu16 " (%s, unsigned empty non-SOA/NS/DS response).",
                                   t->id, dns_resource_key_name(t->key));
                 }
 
@@ -2379,7 +2379,7 @@ static int dns_transaction_requires_rrsig(DnsTransaction *t, DnsResourceRecord *
                                                 return true;
 
                                         /* A CNAME/DNAME without a parent? That's sooo weird. */
-                                        log_debug("Transaction %" PRIu16 " claims CNAME/DNAME at root. Refusing.", t->id);
+                                        log_info("Transaction %" PRIu16 " claims CNAME/DNAME at root. Refusing.", t->id);
                                         return -EBADMSG;
                                 }
                         }
@@ -2780,7 +2780,7 @@ static int dnssec_validate_records(
                 if (r < 0)
                         return r;
 
-                log_debug("Looking at %s: %s", strna(dns_resource_record_to_string(rr)), dnssec_result_to_string(result));
+                log_info("Looking at %s: %s", strna(dns_resource_record_to_string(rr)), dnssec_result_to_string(result));
 
                 if (result == DNSSEC_VALIDATED) {
 
@@ -3016,11 +3016,11 @@ int dns_transaction_validate_dnssec(DnsTransaction *t) {
         if (!dns_transaction_dnssec_supported_full(t)) {
                 /* The server does not support DNSSEC, or doesn't augment responses with RRSIGs. */
                 t->answer_dnssec_result = DNSSEC_INCOMPATIBLE_SERVER;
-                log_debug("Not validating response for %" PRIu16 ", used server feature level does not support DNSSEC.", t->id);
+                log_info("Not validating response for %" PRIu16 ", used server feature level does not support DNSSEC.", t->id);
                 return 0;
         }
 
-        log_debug("Validating response from transaction %" PRIu16 " (%s).",
+        log_info("Validating response from transaction %" PRIu16 " (%s).",
                   t->id,
                   dns_resource_key_to_string(t->key, key_str, sizeof key_str));
 
@@ -3114,7 +3114,7 @@ int dns_transaction_validate_dnssec(DnsTransaction *t) {
 
                 case DNSSEC_NSEC_NXDOMAIN:
                         /* NSEC proves the domain doesn't exist. Very good. */
-                        log_debug("Proved NXDOMAIN via NSEC/NSEC3 for transaction %u (%s)", t->id, key_str);
+                        log_info("Proved NXDOMAIN via NSEC/NSEC3 for transaction %u (%s)", t->id, key_str);
                         t->answer_dnssec_result = DNSSEC_VALIDATED;
                         t->answer_rcode = DNS_RCODE_NXDOMAIN;
                         t->answer_authenticated = authenticated;
@@ -3124,7 +3124,7 @@ int dns_transaction_validate_dnssec(DnsTransaction *t) {
 
                 case DNSSEC_NSEC_NODATA:
                         /* NSEC proves that there's no data here, very good. */
-                        log_debug("Proved NODATA via NSEC/NSEC3 for transaction %u (%s)", t->id, key_str);
+                        log_info("Proved NODATA via NSEC/NSEC3 for transaction %u (%s)", t->id, key_str);
                         t->answer_dnssec_result = DNSSEC_VALIDATED;
                         t->answer_rcode = DNS_RCODE_SUCCESS;
                         t->answer_authenticated = authenticated;
@@ -3134,7 +3134,7 @@ int dns_transaction_validate_dnssec(DnsTransaction *t) {
 
                 case DNSSEC_NSEC_OPTOUT:
                         /* NSEC3 says the data might not be signed */
-                        log_debug("Data is NSEC3 opt-out via NSEC/NSEC3 for transaction %u (%s)", t->id, key_str);
+                        log_info("Data is NSEC3 opt-out via NSEC/NSEC3 for transaction %u (%s)", t->id, key_str);
                         t->answer_dnssec_result = DNSSEC_UNSIGNED;
                         t->answer_authenticated = false;
 
diff --git a/src/resolve/resolved-dns-zone.c b/src/resolve/resolved-dns-zone.c
index dcb9702e5..64c9011cd 100644
--- a/src/resolve/resolved-dns-zone.c
+++ b/src/resolve/resolved-dns-zone.c
@@ -555,13 +555,13 @@ void dns_zone_item_notify(DnsZoneItem *i) {
                  * and defend it. */
 
                 if (!IN_SET(i->state, DNS_ZONE_ITEM_ESTABLISHED, DNS_ZONE_ITEM_VERIFYING)) {
-                        log_debug("Got a successful probe for not yet established RR, we lost.");
+                        log_info("Got a successful probe for not yet established RR, we lost.");
                         we_lost = true;
                 } else if (i->probe_transaction->scope->protocol == DNS_PROTOCOL_LLMNR) {
                         assert(i->probe_transaction->received);
                         we_lost = memcmp(&i->probe_transaction->received->sender, &i->probe_transaction->received->destination, FAMILY_ADDRESS_SIZE(i->probe_transaction->received->family)) < 0;
                         if (we_lost)
-                                log_debug("Got a successful probe reply for an established RR, and we have a lexicographically larger IP address and thus lost.");
+                                log_info("Got a successful probe reply for an established RR, and we have a lexicographically larger IP address and thus lost.");
                 }
 
                 if (we_lost) {
@@ -569,10 +569,10 @@ void dns_zone_item_notify(DnsZoneItem *i) {
                         return;
                 }
 
-                log_debug("Got a successful probe reply, but peer has lexicographically lower IP address and thus lost.");
+                log_info("Got a successful probe reply, but peer has lexicographically lower IP address and thus lost.");
         }
 
-        log_debug("Record %s successfully probed.", strna(dns_resource_record_to_string(i->rr)));
+        log_info("Record %s successfully probed.", strna(dns_resource_record_to_string(i->rr)));
 
         dns_zone_item_probe_stop(i);
         i->state = DNS_ZONE_ITEM_ESTABLISHED;
@@ -586,7 +586,7 @@ static int dns_zone_item_verify(DnsZoneItem *i) {
         if (i->state != DNS_ZONE_ITEM_ESTABLISHED)
                 return 0;
 
-        log_debug("Verifying RR %s", strna(dns_resource_record_to_string(i->rr)));
+        log_info("Verifying RR %s", strna(dns_resource_record_to_string(i->rr)));
 
         i->state = DNS_ZONE_ITEM_VERIFYING;
         r = dns_zone_item_probe_start(i);
diff --git a/src/resolve/resolved-dnssd.c b/src/resolve/resolved-dnssd.c
index db589f443..6b5591972 100644
--- a/src/resolve/resolved-dnssd.c
+++ b/src/resolve/resolved-dnssd.c
@@ -191,10 +191,10 @@ int dnssd_render_instance_name(DnssdService *s, char **ret_name) {
 
         r = specifier_printf(s->name_template, specifier_table, s, &name);
         if (r < 0)
-                return log_debug_errno(r, "Failed to replace specifiers: %m");
+                return log_info_errno(r, "Failed to replace specifiers: %m");
 
         if (!dns_service_name_is_valid(name)) {
-                log_debug("Service instance name '%s' is invalid.", name);
+                log_info("Service instance name '%s' is invalid.", name);
                 return -EINVAL;
         }
 
diff --git a/src/resolve/resolved-link.c b/src/resolve/resolved-link.c
index e3e50eca5..77335767c 100644
--- a/src/resolve/resolved-link.c
+++ b/src/resolve/resolved-link.c
@@ -665,7 +665,7 @@ DnsServer* link_set_dns_server(Link *l, DnsServer *s) {
                 return s;
 
         if (s)
-                log_debug("Switching to DNS server %s for interface %s.", dns_server_string(s), l->name);
+                log_info("Switching to DNS server %s for interface %s.", dns_server_string(s), l->name);
 
         dns_server_unref(l->current_dns_server);
         l->current_dns_server = dns_server_ref(s);
@@ -1024,7 +1024,7 @@ void link_address_add_rrs(LinkAddress *a, bool force_remove) {
         return;
 
 fail:
-        log_debug_errno(r, "Failed to update address RRs: %m");
+        log_info_errno(r, "Failed to update address RRs: %m");
 }
 
 int link_address_update_rtnl(LinkAddress *a, sd_netlink_message *m) {
@@ -1254,7 +1254,7 @@ int link_load_user(Link *l) {
 
                 r = link_update_dns_server_one(l, word);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to load DNS server '%s', ignoring: %m", word);
+                        log_info_errno(r, "Failed to load DNS server '%s', ignoring: %m", word);
                         continue;
                 }
         }
@@ -1275,7 +1275,7 @@ int link_load_user(Link *l) {
 
                 r = link_update_search_domain_one(l, n, is_route);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to load search domain '%s', ignoring: %m", word);
+                        log_info_errno(r, "Failed to load search domain '%s', ignoring: %m", word);
                         continue;
                 }
         }
diff --git a/src/resolve/resolved-llmnr.c b/src/resolve/resolved-llmnr.c
index 59499c9c0..fa0e5f976 100644
--- a/src/resolve/resolved-llmnr.c
+++ b/src/resolve/resolved-llmnr.c
@@ -105,12 +105,12 @@ static int on_llmnr_packet(sd_event_source *s, int fd, uint32_t revents, void *u
 
         scope = manager_find_scope(m, p);
         if (!scope) {
-                log_debug("Got LLMNR UDP packet on unknown scope. Ignoring.");
+                log_info("Got LLMNR UDP packet on unknown scope. Ignoring.");
                 return 0;
         }
 
         if (dns_packet_validate_reply(p) > 0) {
-                log_debug("Got LLMNR UDP reply packet for id %u", DNS_PACKET_ID(p));
+                log_info("Got LLMNR UDP reply packet for id %u", DNS_PACKET_ID(p));
 
                 dns_scope_check_conflicts(scope, p);
 
@@ -119,11 +119,11 @@ static int on_llmnr_packet(sd_event_source *s, int fd, uint32_t revents, void *u
                         dns_transaction_process_reply(t, p);
 
         } else if (dns_packet_validate_query(p) > 0)  {
-                log_debug("Got LLMNR UDP query packet for id %u", DNS_PACKET_ID(p));
+                log_info("Got LLMNR UDP query packet for id %u", DNS_PACKET_ID(p));
 
                 dns_scope_process_query(scope, NULL, p);
         } else
-                log_debug("Invalid LLMNR UDP packet, ignoring.");
+                log_info("Invalid LLMNR UDP packet, ignoring.");
 
         return 0;
 }
@@ -333,13 +333,13 @@ static int on_llmnr_stream_packet(DnsStream *s) {
 
         scope = manager_find_scope(s->manager, s->read_packet);
         if (!scope)
-                log_debug("Got LLMNR TCP packet on unknown scope. Ignoring.");
+                log_info("Got LLMNR TCP packet on unknown scope. Ignoring.");
         else if (dns_packet_validate_query(s->read_packet) > 0) {
-                log_debug("Got LLMNR TCP query packet for id %u", DNS_PACKET_ID(s->read_packet));
+                log_info("Got LLMNR TCP query packet for id %u", DNS_PACKET_ID(s->read_packet));
 
                 dns_scope_process_query(scope, s, s->read_packet);
         } else
-                log_debug("Invalid LLMNR TCP packet, ignoring.");
+                log_info("Invalid LLMNR TCP packet, ignoring.");
 
         dns_stream_unref(s);
         return 0;
diff --git a/src/resolve/resolved-manager.c b/src/resolve/resolved-manager.c
index 2ee027791..1d6c0cbbc 100644
--- a/src/resolve/resolved-manager.c
+++ b/src/resolve/resolved-manager.c
@@ -96,14 +96,14 @@ static int manager_process_link(sd_netlink *rtnl, sd_netlink_message *mm, void *
                         goto fail;
 
                 if (is_new)
-                        log_debug("Found new link %i/%s", ifindex, l->name);
+                        log_info("Found new link %i/%s", ifindex, l->name);
 
                 break;
         }
 
         case RTM_DELLINK:
                 if (l) {
-                        log_debug("Removing link %i/%s", l->ifindex, l->name);
+                        log_info("Removing link %i/%s", l->ifindex, l->name);
                         link_remove_user(l);
                         link_free(l);
                 }
@@ -348,7 +348,7 @@ static int determine_hostname(char **full_hostname, char **llmnr_hostname, char
 
         r = gethostname_strict(&h);
         if (r < 0)
-                return log_debug_errno(r, "Can't determine system hostname: %m");
+                return log_info_errno(r, "Can't determine system hostname: %m");
 
         p = h;
         r = dns_label_unescape(&p, label, sizeof label);
@@ -388,7 +388,7 @@ static int determine_hostname(char **full_hostname, char **llmnr_hostname, char
                 return log_error_errno(r, "Failed to escape host name: %m");
 
         if (is_localhost(n)) {
-                log_debug("System hostname is 'localhost', ignoring.");
+                log_info("System hostname is 'localhost', ignoring.");
                 return -EINVAL;
         }
 
@@ -918,7 +918,7 @@ static int write_loop(int fd, void *message, size_t length) {
 int manager_write(Manager *m, int fd, DnsPacket *p) {
         int r;
 
-        log_debug("Sending %s packet with id %" PRIu16 ".", DNS_PACKET_QR(p) ? "response" : "query", DNS_PACKET_ID(p));
+        log_info("Sending %s packet with id %" PRIu16 ".", DNS_PACKET_QR(p) ? "response" : "query", DNS_PACKET_ID(p));
 
         r = write_loop(fd, DNS_PACKET_DATA(p), p->size);
         if (r < 0)
@@ -1063,7 +1063,7 @@ int manager_send(
         assert(port > 0);
         assert(p);
 
-        log_debug("Sending %s packet with id %" PRIu16 " on interface %i/%s.", DNS_PACKET_QR(p) ? "response" : "query", DNS_PACKET_ID(p), ifindex, af_to_name(family));
+        log_info("Sending %s packet with id %" PRIu16 " on interface %i/%s.", DNS_PACKET_QR(p) ? "response" : "query", DNS_PACKET_ID(p), ifindex, af_to_name(family));
 
         if (family == AF_INET)
                 return manager_ipv4_send(m, fd, ifindex, &destination->in, port, &source->in, p);
@@ -1414,7 +1414,7 @@ void manager_dnssec_verdict(Manager *m, DnssecVerdict verdict, const DnsResource
         if (DEBUG_LOGGING) {
                 char s[DNS_RESOURCE_KEY_STRING_MAX];
 
-                log_debug("Found verdict for lookup %s: %s",
+                log_info("Found verdict for lookup %s: %s",
                           dns_resource_key_to_string(key, s, sizeof s),
                           dnssec_verdict_to_string(verdict));
         }
diff --git a/src/resolve/resolved-mdns.c b/src/resolve/resolved-mdns.c
index 38e2c5422..8633c979b 100644
--- a/src/resolve/resolved-mdns.c
+++ b/src/resolve/resolved-mdns.c
@@ -218,7 +218,7 @@ static int mdns_scope_process_query(DnsScope *s, DnsPacket *p) {
 
         r = dns_packet_extract(p);
         if (r < 0)
-                return log_debug_errno(r, "Failed to extract resource records from incoming packet: %m");
+                return log_info_errno(r, "Failed to extract resource records from incoming packet: %m");
 
         assert_return((dns_question_size(p->question) > 0), -EINVAL);
 
@@ -227,7 +227,7 @@ static int mdns_scope_process_query(DnsScope *s, DnsPacket *p) {
 
                 r = dns_zone_lookup(&s->zone, key, 0, &answer, &soa, &tentative);
                 if (r < 0)
-                        return log_debug_errno(r, "Failed to lookup key: %m");
+                        return log_info_errno(r, "Failed to lookup key: %m");
 
                 if (tentative && DNS_PACKET_NSCOUNT(p) > 0) {
                         /*
@@ -239,7 +239,7 @@ static int mdns_scope_process_query(DnsScope *s, DnsPacket *p) {
                          */
                         r = mdns_do_tiebreak(key, answer, p);
                         if (r < 0)
-                                return log_debug_errno(r, "Failed to do tiebreaking");
+                                return log_info_errno(r, "Failed to do tiebreaking");
 
                         if (r > 0) { /* we lost */
                                 DNS_ANSWER_FOREACH(rr, answer) {
@@ -256,7 +256,7 @@ static int mdns_scope_process_query(DnsScope *s, DnsPacket *p) {
 
                 r = dns_answer_extend(&full_answer, answer);
                 if (r < 0)
-                        return log_debug_errno(r, "Failed to extend answer: %m");
+                        return log_info_errno(r, "Failed to extend answer: %m");
         }
 
         if (dns_answer_isempty(full_answer))
@@ -264,14 +264,14 @@ static int mdns_scope_process_query(DnsScope *s, DnsPacket *p) {
 
         r = dns_scope_make_reply_packet(s, DNS_PACKET_ID(p), DNS_RCODE_SUCCESS, NULL, full_answer, NULL, false, &reply);
         if (r < 0)
-                return log_debug_errno(r, "Failed to build reply packet: %m");
+                return log_info_errno(r, "Failed to build reply packet: %m");
 
         if (!ratelimit_test(&s->ratelimit))
                 return 0;
 
         r = dns_scope_emit_udp(s, -1, reply);
         if (r < 0)
-                return log_debug_errno(r, "Failed to send reply packet: %m");
+                return log_info_errno(r, "Failed to send reply packet: %m");
 
         return 0;
 }
@@ -291,14 +291,14 @@ static int on_mdns_packet(sd_event_source *s, int fd, uint32_t revents, void *us
 
         scope = manager_find_scope(m, p);
         if (!scope) {
-                log_debug("Got mDNS UDP packet on unknown scope. Ignoring.");
+                log_info("Got mDNS UDP packet on unknown scope. Ignoring.");
                 return 0;
         }
 
         if (dns_packet_validate_reply(p) > 0) {
                 DnsResourceRecord *rr;
 
-                log_debug("Got mDNS reply packet");
+                log_info("Got mDNS reply packet");
 
                 /*
                  * mDNS is different from regular DNS and LLMNR with regard to handling responses.
@@ -311,7 +311,7 @@ static int on_mdns_packet(sd_event_source *s, int fd, uint32_t revents, void *us
                  */
                 r = dns_packet_extract(p);
                 if (r < 0) {
-                        log_debug("mDNS packet extraction failed.");
+                        log_info("mDNS packet extraction failed.");
                         return 0;
                 }
 
@@ -328,7 +328,7 @@ static int on_mdns_packet(sd_event_source *s, int fd, uint32_t revents, void *us
                                 return 0;
 
                         if (rr->ttl == 0) {
-                                log_debug("Got a goodbye packet");
+                                log_info("Got a goodbye packet");
                                 /* See the section 10.1 of RFC6762 */
                                 rr->ttl = 1;
                         }
@@ -354,15 +354,15 @@ static int on_mdns_packet(sd_event_source *s, int fd, uint32_t revents, void *us
                 dns_cache_put(&scope->cache, NULL, DNS_PACKET_RCODE(p), p->answer, false, (uint32_t) -1, 0, p->family, &p->sender);
 
         } else if (dns_packet_validate_query(p) > 0)  {
-                log_debug("Got mDNS query packet for id %u", DNS_PACKET_ID(p));
+                log_info("Got mDNS query packet for id %u", DNS_PACKET_ID(p));
 
                 r = mdns_scope_process_query(scope, p);
                 if (r < 0) {
-                        log_debug_errno(r, "mDNS query processing failed: %m");
+                        log_info_errno(r, "mDNS query processing failed: %m");
                         return 0;
                 }
         } else
-                log_debug("Invalid mDNS UDP packet.");
+                log_info("Invalid mDNS UDP packet.");
 
         return 0;
 }
diff --git a/src/resolve/resolved-resolv-conf.c b/src/resolve/resolved-resolv-conf.c
index bad04d6a2..f3e2f05db 100644
--- a/src/resolve/resolved-resolv-conf.c
+++ b/src/resolve/resolved-resolv-conf.c
@@ -197,7 +197,7 @@ static void write_resolv_conf_server(DnsServer *s, FILE *f, unsigned *count) {
          * it (which is a privacy violation, will most probably fail anyway,
          * and adds unnecessary load) */
         if (dns_server_limited_domains(s)) {
-                log_debug("DNS server %s has route-only domains, not using as global name server", dns_server_string(s));
+                log_info("DNS server %s has route-only domains, not using as global name server", dns_server_string(s));
                 return;
         }
 
diff --git a/src/resolve/test-resolved-packet.c b/src/resolve/test-resolved-packet.c
index af5bec139..05a88ec49 100644
--- a/src/resolve/test-resolved-packet.c
+++ b/src/resolve/test-resolved-packet.c
@@ -30,7 +30,7 @@ static void test_dns_packet_new(void) {
 
                 assert_se(dns_packet_new(&p, DNS_PROTOCOL_DNS, i, DNS_PACKET_SIZE_MAX) == 0);
 
-                log_debug("dns_packet_new: %zu → %zu", i, p->allocated);
+                log_info("dns_packet_new: %zu → %zu", i, p->allocated);
                 assert_se(p->allocated >= MIN(DNS_PACKET_SIZE_MAX, i));
 
                 if (i > DNS_PACKET_SIZE_START + 10 && i < DNS_PACKET_SIZE_MAX - 10)
diff --git a/src/rfkill/rfkill.c b/src/rfkill/rfkill.c
index ff951450b..8a34e6cf8 100644
--- a/src/rfkill/rfkill.c
+++ b/src/rfkill/rfkill.c
@@ -94,12 +94,12 @@ static int find_device(
 
         name = udev_device_get_sysattr_value(device, "name");
         if (!name) {
-                log_debug("Device has no name, ignoring.");
+                log_info("Device has no name, ignoring.");
                 udev_device_unref(device);
                 return -ENOENT;
         }
 
-        log_debug("Operating on rfkill device '%s'.", name);
+        log_info("Operating on rfkill device '%s'.", name);
 
         *ret = device;
         return 0;
@@ -252,7 +252,7 @@ static int load_state(
                 if (r < 0)
                         return log_error_errno(r, "Failed to write state file %s: %m", state_file);
 
-                log_debug("Saved state '%s' to %s.", one_zero(event->soft), state_file);
+                log_info("Saved state '%s' to %s.", one_zero(event->soft), state_file);
                 return 0;
         }
         if (r < 0)
@@ -276,7 +276,7 @@ static int load_state(
                 return -EIO;
         }
 
-        log_debug("Loaded state '%s' from %s.", one_zero(b), state_file);
+        log_info("Loaded state '%s' from %s.", one_zero(b), state_file);
         return 0;
 }
 
@@ -289,7 +289,7 @@ static void save_state_queue_remove(
 
         LIST_FOREACH_SAFE(queue, item, tmp, *write_queue) {
                 if ((state_file && streq(item->file, state_file)) || idx == item->rfkill_idx) {
-                        log_debug("Canceled previous save state of '%s' to %s.", one_zero(item->state), item->file);
+                        log_info("Canceled previous save state of '%s' to %s.", one_zero(item->state), item->file);
                         LIST_REMOVE(queue, *write_queue, item);
                         write_queue_item_free(item);
                 }
@@ -366,7 +366,7 @@ static int save_state_write(struct write_queue_item **write_queue) {
                         } else
                                 log_warning_errno(r, "Failed to write state file %s: %m", item->file);
                 } else
-                        log_debug("Saved state '%s' to %s.", one_zero(item->state), item->file);
+                        log_info("Saved state '%s' to %s.", one_zero(item->state), item->file);
 
                 LIST_REMOVE(queue, *write_queue, item);
                 write_queue_item_free(item);
@@ -421,7 +421,7 @@ int main(int argc, char *argv[]) {
                 rfkill_fd = open("/dev/rfkill", O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);
                 if (rfkill_fd < 0) {
                         if (errno == ENOENT) {
-                                log_debug_errno(errno, "Missing rfkill subsystem, or no device present, exiting.");
+                                log_info_errno(errno, "Missing rfkill subsystem, or no device present, exiting.");
                                 r = 0;
                                 goto finish;
                         }
@@ -469,7 +469,7 @@ int main(int argc, char *argv[]) {
                                 if (r > 0)
                                         continue;
 
-                                log_debug("All events read and idle, exiting.");
+                                log_info("All events read and idle, exiting.");
                                 break;
                         }
 
@@ -484,29 +484,29 @@ int main(int argc, char *argv[]) {
 
                 type = rfkill_type_to_string(event.type);
                 if (!type) {
-                        log_debug("An rfkill device of unknown type %i discovered, ignoring.", event.type);
+                        log_info("An rfkill device of unknown type %i discovered, ignoring.", event.type);
                         continue;
                 }
 
                 switch (event.op) {
 
                 case RFKILL_OP_ADD:
-                        log_debug("A new rfkill device has been added with index %i and type %s.", event.idx, type);
+                        log_info("A new rfkill device has been added with index %i and type %s.", event.idx, type);
                         (void) load_state(rfkill_fd, udev, &event);
                         break;
 
                 case RFKILL_OP_DEL:
-                        log_debug("An rfkill device has been removed with index %i and type %s", event.idx, type);
+                        log_info("An rfkill device has been removed with index %i and type %s", event.idx, type);
                         (void) save_state_cancel(&write_queue, rfkill_fd, udev, &event);
                         break;
 
                 case RFKILL_OP_CHANGE:
-                        log_debug("An rfkill device has changed state with index %i and type %s", event.idx, type);
+                        log_info("An rfkill device has changed state with index %i and type %s", event.idx, type);
                         (void) save_state_queue(&write_queue, rfkill_fd, udev, &event);
                         break;
 
                 default:
-                        log_debug("Unknown event %i from /dev/rfkill for index %i and type %s, ignoring.", event.op, event.idx, type);
+                        log_info("Unknown event %i from /dev/rfkill for index %i and type %s, ignoring.", event.op, event.idx, type);
                         break;
                 }
         }
diff --git a/src/shared/ask-password-api.c b/src/shared/ask-password-api.c
index 99d6a9b14..43690081b 100644
--- a/src/shared/ask-password-api.c
+++ b/src/shared/ask-password-api.c
@@ -149,9 +149,9 @@ static int add_to_keyring(const char *keyname, AskPasswordFlags flags, char **pa
         if (keyctl(KEYCTL_SET_TIMEOUT,
                    (unsigned long) serial,
                    (unsigned long) DIV_ROUND_UP(KEYRING_TIMEOUT_USEC, USEC_PER_SEC), 0, 0) < 0)
-                log_debug_errno(errno, "Failed to adjust timeout: %m");
+                log_info_errno(errno, "Failed to adjust timeout: %m");
 
-        log_debug("Added key to keyring as %" PRIi32 ".", serial);
+        log_info("Added key to keyring as %" PRIi32 ".", serial);
 
         return 1;
 }
@@ -164,7 +164,7 @@ static int add_to_keyring_and_log(const char *keyname, AskPasswordFlags flags, c
 
         r = add_to_keyring(keyname, flags, passwords);
         if (r < 0)
-                return log_debug_errno(r, "Failed to add password to keyring: %m");
+                return log_info_errno(r, "Failed to add password to keyring: %m");
 
         return 0;
 }
@@ -626,7 +626,7 @@ int ask_password_agent(
                 cmsg_close_all(&msghdr);
 
                 if (n <= 0) {
-                        log_debug("Message too short");
+                        log_info("Message too short");
                         continue;
                 }
 
@@ -634,13 +634,13 @@ int ask_password_agent(
                     control.cmsghdr.cmsg_level != SOL_SOCKET ||
                     control.cmsghdr.cmsg_type != SCM_CREDENTIALS ||
                     control.cmsghdr.cmsg_len != CMSG_LEN(sizeof(struct ucred))) {
-                        log_debug("Received message without credentials. Ignoring.");
+                        log_info("Received message without credentials. Ignoring.");
                         continue;
                 }
 
                 ucred = (struct ucred*) CMSG_DATA(&control.cmsghdr);
                 if (ucred->uid != 0) {
-                        log_debug("Got request from unprivileged user. Ignoring.");
+                        log_info("Got request from unprivileged user. Ignoring.");
                         continue;
                 }
 
@@ -658,7 +658,7 @@ int ask_password_agent(
 
                         if (strv_isempty(l)) {
                                 l = strv_free(l);
-                                log_debug("Invalid packet");
+                                log_info("Invalid packet");
                                 continue;
                         }
 
@@ -670,7 +670,7 @@ int ask_password_agent(
                         goto finish;
                 }
 
-                log_debug("Invalid packet");
+                log_info("Invalid packet");
         }
 
         if (keyname)
diff --git a/src/shared/bootspec.c b/src/shared/bootspec.c
index 9c3bdd47d..82acd3318 100644
--- a/src/shared/bootspec.c
+++ b/src/shared/bootspec.c
@@ -323,7 +323,7 @@ static int boot_entries_select_default(const BootConfig *config) {
         if (config->entry_oneshot)
                 for (i = config->n_entries - 1; i >= 0; i--)
                         if (streq(config->entry_oneshot, config->entries[i].filename)) {
-                                log_debug("Found default: filename \"%s\" is matched by LoaderEntryOneShot",
+                                log_info("Found default: filename \"%s\" is matched by LoaderEntryOneShot",
                                           config->entries[i].filename);
                                 return i;
                         }
@@ -331,7 +331,7 @@ static int boot_entries_select_default(const BootConfig *config) {
         if (config->entry_default)
                 for (i = config->n_entries - 1; i >= 0; i--)
                         if (streq(config->entry_default, config->entries[i].filename)) {
-                                log_debug("Found default: filename \"%s\" is matched by LoaderEntryDefault",
+                                log_info("Found default: filename \"%s\" is matched by LoaderEntryDefault",
                                           config->entries[i].filename);
                                 return i;
                         }
@@ -339,15 +339,15 @@ static int boot_entries_select_default(const BootConfig *config) {
         if (config->default_pattern)
                 for (i = config->n_entries - 1; i >= 0; i--)
                         if (fnmatch(config->default_pattern, config->entries[i].filename, FNM_CASEFOLD) == 0) {
-                                log_debug("Found default: filename \"%s\" is matched by pattern \"%s\"",
+                                log_info("Found default: filename \"%s\" is matched by pattern \"%s\"",
                                           config->entries[i].filename, config->default_pattern);
                                 return i;
                         }
 
         if (config->n_entries > 0)
-                log_debug("Found default: last entry \"%s\"", config->entries[config->n_entries - 1].filename);
+                log_info("Found default: last entry \"%s\"", config->entries[config->n_entries - 1].filename);
         else
-                log_debug("Found no default boot entry :(");
+                log_info("Found no default boot entry :(");
 
         return config->n_entries - 1; /* -1 means "no default" */
 }
diff --git a/src/shared/bus-unit-util.c b/src/shared/bus-unit-util.c
index bc77c3abd..67649f775 100644
--- a/src/shared/bus-unit-util.c
+++ b/src/shared/bus-unit-util.c
@@ -1888,7 +1888,7 @@ static int check_wait_response(BusWaitForJobs *d, bool quiet, const char* const*
 
                                 q = bus_job_get_service_result(d, &result);
                                 if (q < 0)
-                                        log_debug_errno(q, "Failed to get Result property of unit %s: %m", d->name);
+                                        log_info_errno(q, "Failed to get Result property of unit %s: %m", d->name);
 
                                 log_job_error_with_service_result(d->name, result, extra_args);
                         } else
@@ -1933,7 +1933,7 @@ int bus_wait_for_jobs(BusWaitForJobs *d, bool quiet, const char* const* extra_ar
                         if (q < 0 && r == 0)
                                 r = q;
 
-                        log_debug_errno(q, "Got result %s/%m for job %s", strna(d->result), strna(d->name));
+                        log_info_errno(q, "Got result %s/%m for job %s", strna(d->result), strna(d->name));
                 }
 
                 d->name = mfree(d->name);
diff --git a/src/shared/clean-ipc.c b/src/shared/clean-ipc.c
index 7e2ef4a8e..e4b35c863 100644
--- a/src/shared/clean-ipc.c
+++ b/src/shared/clean-ipc.c
@@ -106,7 +106,7 @@ static int clean_sysvipc_shm(uid_t delete_uid, gid_t delete_gid, bool rm) {
                                                 "Failed to remove SysV shared memory segment %i: %m",
                                                 shmid);
                 } else {
-                        log_debug("Removed SysV shared memory segment %i.", shmid);
+                        log_info("Removed SysV shared memory segment %i.", shmid);
                         if (ret == 0)
                                 ret = 1;
                 }
@@ -164,7 +164,7 @@ static int clean_sysvipc_sem(uid_t delete_uid, gid_t delete_gid, bool rm) {
                                                 "Failed to remove SysV semaphores object %i: %m",
                                                 semid);
                 } else {
-                        log_debug("Removed SysV semaphore %i.", semid);
+                        log_info("Removed SysV semaphore %i.", semid);
                         if (ret == 0)
                                 ret = 1;
                 }
@@ -223,7 +223,7 @@ static int clean_sysvipc_msg(uid_t delete_uid, gid_t delete_gid, bool rm) {
                                                 "Failed to remove SysV message queue %i: %m",
                                                 msgid);
                 } else {
-                        log_debug("Removed SysV message queue %i.", msgid);
+                        log_info("Removed SysV message queue %i.", msgid);
                         if (ret == 0)
                                 ret = 1;
                 }
@@ -281,7 +281,7 @@ static int clean_posix_shm_internal(DIR *dir, uid_t uid, gid_t gid, bool rm) {
 
                                 ret = log_warning_errno(errno, "Failed to remove POSIX shared memory directory %s: %m", de->d_name);
                         } else {
-                                log_debug("Removed POSIX shared memory directory %s", de->d_name);
+                                log_info("Removed POSIX shared memory directory %s", de->d_name);
                                 if (ret == 0)
                                         ret = 1;
                         }
@@ -300,7 +300,7 @@ static int clean_posix_shm_internal(DIR *dir, uid_t uid, gid_t gid, bool rm) {
 
                                 ret = log_warning_errno(errno, "Failed to remove POSIX shared memory segment %s: %m", de->d_name);
                         } else {
-                                log_debug("Removed POSIX shared memory segment %s", de->d_name);
+                                log_info("Removed POSIX shared memory segment %s", de->d_name);
                                 if (ret == 0)
                                         ret = 1;
                         }
@@ -374,7 +374,7 @@ static int clean_posix_mq(uid_t uid, gid_t gid, bool rm) {
                                                 "Failed to unlink POSIX message queue %s: %m",
                                                 fn);
                 } else {
-                        log_debug("Removed POSIX message queue %s", fn);
+                        log_info("Removed POSIX message queue %s", fn);
                         if (ret == 0)
                                 ret = 1;
                 }
diff --git a/src/shared/condition.c b/src/shared/condition.c
index a2fd05c42..0619ae1fd 100644
--- a/src/shared/condition.c
+++ b/src/shared/condition.c
@@ -253,14 +253,14 @@ static int condition_test_control_group_controller(Condition *c) {
 
         r = cg_mask_supported(&system_mask);
         if (r < 0)
-                return log_debug_errno(r, "Failed to determine supported controllers: %m");
+                return log_info_errno(r, "Failed to determine supported controllers: %m");
 
         r = cg_mask_from_string(c->parameter, &wanted_mask);
         if (r < 0 || wanted_mask <= 0) {
                 /* This won't catch the case that we have an unknown controller
                  * mixed in with valid ones -- these are only assessed on the
                  * validity of the valid controllers found. */
-                log_debug("Failed to parse cgroup string: %s", c->parameter);
+                log_info("Failed to parse cgroup string: %s", c->parameter);
                 return 1;
         }
 
@@ -482,7 +482,7 @@ static int condition_test_needs_update(Condition *c) {
                         log_error_errno(r, "Failed to parse timestamp file '%s', using mtime: %m", p);
                         return true;
                 } else if (r == 0) {
-                        log_debug("No data in timestamp file '%s', using mtime", p);
+                        log_info("No data in timestamp file '%s', using mtime", p);
                         return true;
                 }
 
diff --git a/src/shared/dev-setup.c b/src/shared/dev-setup.c
index 6d2cc685f..14a8fc609 100644
--- a/src/shared/dev-setup.c
+++ b/src/shared/dev-setup.c
@@ -63,11 +63,11 @@ int dev_setup(const char *prefix, uid_t uid, gid_t gid) {
 
                 r = symlink_label(j, n);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to symlink %s to %s: %m", j, n);
+                        log_info_errno(r, "Failed to symlink %s to %s: %m", j, n);
 
                 if (uid != UID_INVALID || gid != GID_INVALID)
                         if (lchown(n, uid, gid) < 0)
-                                log_debug_errno(errno, "Failed to chown %s: %m", n);
+                                log_info_errno(errno, "Failed to chown %s: %m", n);
         }
 
         return 0;
diff --git a/src/shared/dissect-image.c b/src/shared/dissect-image.c
index 86114e3dd..f5ea28a1a 100644
--- a/src/shared/dissect-image.c
+++ b/src/shared/dissect-image.c
@@ -77,11 +77,11 @@ int probe_filesystem(const char *node, char **ret_fstype) {
         errno = 0;
         r = blkid_do_safeprobe(b);
         if (r == 1) {
-                log_debug("No type detected on partition %s", node);
+                log_info("No type detected on partition %s", node);
                 goto not_found;
         }
         if (r == -2) {
-                log_debug("Results ambiguous for partition %s", node);
+                log_info("Results ambiguous for partition %s", node);
                 return -EUCLEAN;
         }
         if (r != 0)
@@ -180,7 +180,7 @@ int dissect_image(int fd, const void *root_hash, size_t root_hash_size, DissectI
         errno = 0;
         r = blkid_do_safeprobe(b);
         if (IN_SET(r, -2, 1)) {
-                log_debug("Failed to identify any partition table.");
+                log_info("Failed to identify any partition table.");
                 return -ENOPKG;
         }
         if (r != 0)
@@ -258,7 +258,7 @@ int dissect_image(int fd, const void *root_hash, size_t root_hash_size, DissectI
                 int n, z;
 
                 if (i >= 10) {
-                        log_debug("Kernel partitions never appeared.");
+                        log_info("Kernel partitions never appeared.");
                         return -ENXIO;
                 }
 
@@ -285,7 +285,7 @@ int dissect_image(int fd, const void *root_hash, size_t root_hash_size, DissectI
                 if (n == z + 1)
                         break;
                 if (n > z + 1) {
-                        log_debug("blkid and kernel partition list do not match.");
+                        log_info("blkid and kernel partition list do not match.");
                         return -EIO;
                 }
                 if (n < z + 1) {
@@ -310,7 +310,7 @@ int dissect_image(int fd, const void *root_hash, size_t root_hash_size, DissectI
                                                  * can generate a proper message explaining the situation. */
 
                                                 if (ioctl(fd, LOOP_GET_STATUS64, &info) >= 0 && (info.lo_flags & LO_FLAGS_PARTSCAN) == 0) {
-                                                        log_debug("Device is loop device and partition scanning is off!");
+                                                        log_info("Device is loop device and partition scanning is off!");
                                                         return -EPROTONOSUPPORT;
                                                 }
                                         }
@@ -824,7 +824,7 @@ DecryptedImage* decrypted_image_unref(DecryptedImage* d) {
                 if (p->device && p->name && !p->relinquished) {
                         r = crypt_deactivate(p->device, p->name);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to deactivate encrypted partition %s", p->name);
+                                log_info_errno(r, "Failed to deactivate encrypted partition %s", p->name);
                 }
 
                 if (p->device)
@@ -903,17 +903,17 @@ static int decrypt_partition(
 
         r = crypt_init(&cd, m->node);
         if (r < 0)
-                return log_debug_errno(r, "Failed to initialize dm-crypt: %m");
+                return log_info_errno(r, "Failed to initialize dm-crypt: %m");
 
         r = crypt_load(cd, CRYPT_LUKS, NULL);
         if (r < 0)
-                return log_debug_errno(r, "Failed to load LUKS metadata: %m");
+                return log_info_errno(r, "Failed to load LUKS metadata: %m");
 
         r = crypt_activate_by_passphrase(cd, name, CRYPT_ANY_SLOT, passphrase, strlen(passphrase),
                                          ((flags & DISSECT_IMAGE_READ_ONLY) ? CRYPT_ACTIVATE_READONLY : 0) |
                                          ((flags & DISSECT_IMAGE_DISCARD_ON_CRYPTO) ? CRYPT_ACTIVATE_ALLOW_DISCARDS : 0));
         if (r < 0) {
-                log_debug_errno(r, "Failed to activate LUKS device: %m");
+                log_info_errno(r, "Failed to activate LUKS device: %m");
                 return r == -EPERM ? -EKEYREJECTED : r;
         }
 
@@ -1158,7 +1158,7 @@ int decrypted_image_relinquish(DecryptedImage *d) {
 
                 r = deferred_remove(p);
                 if (r < 0)
-                        return log_debug_errno(r, "Failed to mark %s for auto-removal: %m", p->name);
+                        return log_info_errno(r, "Failed to mark %s for auto-removal: %m", p->name);
 
                 p->relinquished = true;
         }
@@ -1322,7 +1322,7 @@ int dissected_image_acquire_metadata(DissectedImage *m) {
                 case META_HOSTNAME:
                         r = read_etc_hostname_stream(f, &hostname);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to read /etc/hostname: %m");
+                                log_info_errno(r, "Failed to read /etc/hostname: %m");
 
                         break;
 
@@ -1331,15 +1331,15 @@ int dissected_image_acquire_metadata(DissectedImage *m) {
 
                         r = read_line(f, LONG_LINE_MAX, &line);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to read /etc/machine-id: %m");
+                                log_info_errno(r, "Failed to read /etc/machine-id: %m");
                         else if (r == 33) {
                                 r = sd_id128_from_string(line, &machine_id);
                                 if (r < 0)
-                                        log_debug_errno(r, "Image contains invalid /etc/machine-id: %s", line);
+                                        log_info_errno(r, "Image contains invalid /etc/machine-id: %s", line);
                         } else if (r == 0)
-                                log_debug("/etc/machine-id file is empty.");
+                                log_info("/etc/machine-id file is empty.");
                         else
-                                log_debug("/etc/machine-id has unexpected length %i.", r);
+                                log_info("/etc/machine-id has unexpected length %i.", r);
 
                         break;
                 }
@@ -1347,14 +1347,14 @@ int dissected_image_acquire_metadata(DissectedImage *m) {
                 case META_MACHINE_INFO:
                         r = load_env_file_pairs(f, "machine-info", NULL, &machine_info);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to read /etc/machine-info: %m");
+                                log_info_errno(r, "Failed to read /etc/machine-info: %m");
 
                         break;
 
                 case META_OS_RELEASE:
                         r = load_env_file_pairs(f, "os-release", NULL, &os_release);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to read OS release file: %m");
+                                log_info_errno(r, "Failed to read OS release file: %m");
 
                         break;
                 }
diff --git a/src/shared/dns-domain.c b/src/shared/dns-domain.c
index 8c807e0e2..32c0006ef 100644
--- a/src/shared/dns-domain.c
+++ b/src/shared/dns-domain.c
@@ -1290,20 +1290,20 @@ int dns_name_apply_idna(const char *name, char **ret) {
 
         r = idn2_lookup_u8((uint8_t*) name, (uint8_t**) &t,
                            IDN2_NFC_INPUT | IDN2_NONTRANSITIONAL);
-        log_debug("idn2_lookup_u8: %s → %s", name, t);
+        log_info("idn2_lookup_u8: %s → %s", name, t);
         if (r == IDN2_OK) {
                 if (!startswith(name, "xn--")) {
                         _cleanup_free_ char *s = NULL;
 
                         r = idn2_to_unicode_8z8z(t, &s, 0);
                         if (r != IDN2_OK) {
-                                log_debug("idn2_to_unicode_8z8z(\"%s\") failed: %d/%s",
+                                log_info("idn2_to_unicode_8z8z(\"%s\") failed: %d/%s",
                                           t, r, idn2_strerror(r));
                                 return 0;
                         }
 
                         if (!streq_ptr(name, s)) {
-                                log_debug("idn2 roundtrip failed: \"%s\" → \"%s\" → \"%s\", ignoring.",
+                                log_info("idn2 roundtrip failed: \"%s\" → \"%s\" → \"%s\", ignoring.",
                                           name, t, s);
                                 return 0;
                         }
@@ -1314,7 +1314,7 @@ int dns_name_apply_idna(const char *name, char **ret) {
                 return 1; /* *ret has been written */
         }
 
-        log_debug("idn2_lookup_u8(\"%s\") failed: %d/%s", name, r, idn2_strerror(r));
+        log_info("idn2_lookup_u8(\"%s\") failed: %d/%s", name, r, idn2_strerror(r));
         if (r == IDN2_2HYPHEN)
                 /* The name has two hypens — forbidden by IDNA2008 in some cases */
                 return 0;
diff --git a/src/shared/fdset.c b/src/shared/fdset.c
index 9ce129522..eab7c233e 100644
--- a/src/shared/fdset.c
+++ b/src/shared/fdset.c
@@ -80,7 +80,7 @@ FDSet* fdset_free(FDSet *s) {
                  * duplicates. So don't be surprised about these log
                  * messages. */
 
-                log_debug("Closing left-over fd %i", PTR_TO_FD(p));
+                log_info("Closing left-over fd %i", PTR_TO_FD(p));
                 close_nointr(PTR_TO_FD(p));
         }
 
diff --git a/src/shared/generator.c b/src/shared/generator.c
index 2b0a4ecdc..3a9f9912f 100644
--- a/src/shared/generator.c
+++ b/src/shared/generator.c
@@ -104,7 +104,7 @@ static int write_fsck_sysroot_service(const char *dir, const char *what) {
                 return log_oom();
 
         unit = strjoina(dir, "/systemd-fsck-root.service");
-        log_debug("Creating %s", unit);
+        log_info("Creating %s", unit);
 
         r = unit_name_from_path(what, ".device", &device);
         if (r < 0)
@@ -166,7 +166,7 @@ int generator_write_fsck_deps(
                         log_warning_errno(r, "Checking was requested for %s, but couldn't detect if fsck.%s may be used, proceeding: %m", what, fstype);
                 else if (r == 0) {
                         /* treat missing check as essentially OK */
-                        log_debug("Checking was requested for %s, but fsck.%s does not exist.", what, fstype);
+                        log_info("Checking was requested for %s, but fsck.%s does not exist.", what, fstype);
                         return 0;
                 }
         }
@@ -339,7 +339,7 @@ int generator_hook_up_mkswap(
                                        node);
 
         unit_file = strjoina(dir, "/", unit);
-        log_debug("Creating %s", unit_file);
+        log_info("Creating %s", unit_file);
 
         escaped = cescape(node);
         if (!escaped)
@@ -414,7 +414,7 @@ int generator_hook_up_mkfs(
                                        node);
 
         unit_file = strjoina(dir, "/", unit);
-        log_debug("Creating %s", unit_file);
+        log_info("Creating %s", unit_file);
 
         escaped = cescape(node);
         if (!escaped)
@@ -487,7 +487,7 @@ int generator_hook_up_growfs(
                                        where);
 
         unit_file = strjoina(dir, "/", unit);
-        log_debug("Creating %s", unit_file);
+        log_info("Creating %s", unit_file);
 
         f = fopen(unit_file, "wxe");
         if (!f)
diff --git a/src/shared/import-util.c b/src/shared/import-util.c
index 07ba216e9..7ae28919b 100644
--- a/src/shared/import-util.c
+++ b/src/shared/import-util.c
@@ -164,7 +164,7 @@ int import_assign_pool_quota_and_warn(const char *path) {
 
         r = btrfs_subvol_auto_qgroup("/var/lib/machines", 0, true);
         if (r == -ENOTTY)  {
-                log_debug_errno(r, "Failed to set up default quota hierarchy for /var/lib/machines, as directory is not on btrfs or not a subvolume. Ignoring.");
+                log_info_errno(r, "Failed to set up default quota hierarchy for /var/lib/machines, as directory is not on btrfs or not a subvolume. Ignoring.");
                 return 0;
         }
         if (r < 0)
@@ -174,7 +174,7 @@ int import_assign_pool_quota_and_warn(const char *path) {
 
         r = btrfs_subvol_auto_qgroup(path, 0, true);
         if (r == -ENOTTY) {
-                log_debug_errno(r, "Failed to set up quota hierarchy for %s, as directory is not on btrfs or not a subvolume. Ignoring.", path);
+                log_info_errno(r, "Failed to set up quota hierarchy for %s, as directory is not on btrfs or not a subvolume. Ignoring.", path);
                 return 0;
         }
         if (r < 0)
diff --git a/src/shared/install.c b/src/shared/install.c
index 026aa3230..097832e4c 100644
--- a/src/shared/install.c
+++ b/src/shared/install.c
@@ -1299,7 +1299,7 @@ static int unit_file_load(
                          config_item_table_lookup, items,
                          CONFIG_PARSE_RELAXED|CONFIG_PARSE_ALLOW_INCLUDE, info);
         if (r < 0)
-                return log_debug_errno(r, "Failed to parse %s: %m", info->name);
+                return log_info_errno(r, "Failed to parse %s: %m", info->name);
 
         info->type = UNIT_FILE_TYPE_REGULAR;
 
@@ -1457,7 +1457,7 @@ static int unit_file_search(
         }
 
         if (!found_unit) {
-                log_debug("Cannot find unit %s%s%s.", info->name, template ? " or " : "", strempty(template));
+                log_info("Cannot find unit %s%s%s.", info->name, template ? " or " : "", strempty(template));
                 return -ENOENT;
         }
 
@@ -1495,12 +1495,12 @@ static int unit_file_search(
 
         r = conf_files_list_strv(&files, ".conf", NULL, 0, (const char**) dirs);
         if (r < 0)
-                return log_debug_errno(r, "Failed to get list of conf files: %m");
+                return log_info_errno(r, "Failed to get list of conf files: %m");
 
         STRV_FOREACH(p, files) {
                 r = unit_file_load_or_readlink(c, info, *p, paths->root_dir, flags);
                 if (r < 0)
-                        return log_debug_errno(r, "Failed to load conf file %s: %m", *p);
+                        return log_info_errno(r, "Failed to load conf file %s: %m", *p);
         }
 
         return result;
@@ -1948,26 +1948,26 @@ static int install_context_mark_for_removal(
 
                 r = install_info_traverse(scope, c, paths, i, SEARCH_LOAD|SEARCH_FOLLOW_CONFIG_SYMLINKS, NULL);
                 if (r == -ENOLINK) {
-                        log_debug_errno(r, "Name %s leads to a dangling symlink, removing name.", i->name);
+                        log_info_errno(r, "Name %s leads to a dangling symlink, removing name.", i->name);
                         unit_file_changes_add(changes, n_changes, UNIT_FILE_IS_DANGLING, i->path ?: i->name, NULL);
                 } else if (r == -ENOENT) {
 
                         if (i->auxiliary)  /* some unit specified in Also= or similar is missing */
-                                log_debug_errno(r, "Auxiliary unit of %s not found, removing name.", i->name);
+                                log_info_errno(r, "Auxiliary unit of %s not found, removing name.", i->name);
                         else {
-                                log_debug_errno(r, "Unit %s not found, removing name.", i->name);
+                                log_info_errno(r, "Unit %s not found, removing name.", i->name);
                                 unit_file_changes_add(changes, n_changes, r, i->path ?: i->name, NULL);
                         }
 
                 } else if (r < 0) {
-                        log_debug_errno(r, "Failed to find unit %s, removing name: %m", i->name);
+                        log_info_errno(r, "Failed to find unit %s, removing name: %m", i->name);
                         unit_file_changes_add(changes, n_changes, r, i->path ?: i->name, NULL);
                 } else if (i->type == UNIT_FILE_TYPE_MASKED) {
-                        log_debug("Unit file %s is masked, ignoring.", i->name);
+                        log_info("Unit file %s is masked, ignoring.", i->name);
                         unit_file_changes_add(changes, n_changes, UNIT_FILE_IS_MASKED, i->path ?: i->name, NULL);
                         continue;
                 } else if (i->type != UNIT_FILE_TYPE_REGULAR) {
-                        log_debug("Unit %s has type %s, ignoring.", i->name, unit_file_type_to_string(i->type) ?: "invalid");
+                        log_info("Unit %s has type %s, ignoring.", i->name, unit_file_type_to_string(i->type) ?: "invalid");
                         continue;
                 }
 
@@ -2894,13 +2894,13 @@ static int query_presets(const char *name, const Presets presets) {
 
         switch (action) {
         case PRESET_UNKNOWN:
-                log_debug("Preset files don't specify rule for %s. Enabling.", name);
+                log_info("Preset files don't specify rule for %s. Enabling.", name);
                 return 1;
         case PRESET_ENABLE:
-                log_debug("Preset files say enable %s.", name);
+                log_info("Preset files say enable %s.", name);
                 return 1;
         case PRESET_DISABLE:
-                log_debug("Preset files say disable %s.", name);
+                log_info("Preset files say disable %s.", name);
                 return 0;
         default:
                 assert_not_reached("invalid preset action");
@@ -2986,7 +2986,7 @@ static int preset_prepare_one(
         if (r < 0)
                 return r;
         if (!streq(name, i->name)) {
-                log_debug("Skipping %s because it is an alias for %s.", name, i->name);
+                log_info("Skipping %s because it is an alias for %s.", name, i->name);
                 return 0;
         }
 
@@ -3164,7 +3164,7 @@ int unit_file_get_list(
                         if (errno == ENOENT)
                                 continue;
                         if (IN_SET(errno, ENOTDIR, EACCES)) {
-                                log_debug_errno(errno, "Failed to open \"%s\": %m", *i);
+                                log_info_errno(errno, "Failed to open \"%s\": %m", *i);
                                 continue;
                         }
 
diff --git a/src/shared/logs-show.c b/src/shared/logs-show.c
index 5609e42fe..a3058bff5 100644
--- a/src/shared/logs-show.c
+++ b/src/shared/logs-show.c
@@ -441,14 +441,14 @@ static int output_short(
                         return r;
         }
         if (r == -EBADMSG) {
-                log_debug_errno(r, "Skipping message we can't read: %m");
+                log_info_errno(r, "Skipping message we can't read: %m");
                 return 0;
         }
         if (r < 0)
                 return log_error_errno(r, "Failed to get journal fields: %m");
 
         if (!message) {
-                log_debug("Skipping message without MESSAGE= field.");
+                log_info("Skipping message without MESSAGE= field.");
                 return 0;
         }
 
@@ -535,7 +535,7 @@ static int output_verbose(
 
         r = sd_journal_get_data(j, "_SOURCE_REALTIME_TIMESTAMP", &data, &length);
         if (r == -ENOENT)
-                log_debug("Source realtime timestamp not found");
+                log_info("Source realtime timestamp not found");
         else if (r < 0)
                 return log_full_errno(r == -EADDRNOTAVAIL ? LOG_DEBUG : LOG_ERR, r, "Failed to get source realtime timestamp: %m");
         else {
@@ -550,7 +550,7 @@ static int output_verbose(
 
                 r = safe_atou64(value, &realtime);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse realtime timestamp: %m");
+                        log_info_errno(r, "Failed to parse realtime timestamp: %m");
         }
 
         if (r < 0) {
@@ -698,7 +698,7 @@ static int output_export(
                 fputc('\n', f);
         }
         if (r == -EBADMSG) {
-                log_debug_errno(r, "Skipping message we can't read: %m");
+                log_info_errno(r, "Skipping message we can't read: %m");
                 return 0;
         }
 
@@ -866,7 +866,7 @@ static int output_json(
         }
 
         if (r == -EBADMSG) {
-                log_debug_errno(r, "Skipping message we can't read: %m");
+                log_info_errno(r, "Skipping message we can't read: %m");
                 return 0;
         }
 
@@ -1018,7 +1018,7 @@ static int output_cat(
 
         r = sd_journal_get_data(j, "MESSAGE", &data, &l);
         if (r == -EBADMSG) {
-                log_debug_errno(r, "Skipping message we can't read: %m");
+                log_info_errno(r, "Skipping message we can't read: %m");
                 return 0;
         }
         if (r < 0) {
@@ -1468,7 +1468,7 @@ int show_journal_by_unit(
                 if (!filter)
                         return log_oom();
 
-                log_debug("Journal filter: %s", filter);
+                log_info("Journal filter: %s", filter);
         }
 
         return show_journal(f, j, mode, n_columns, not_before, how_many, flags, ellipsized);
diff --git a/src/shared/loop-util.c b/src/shared/loop-util.c
index 37b8479f8..0d1788915 100644
--- a/src/shared/loop-util.c
+++ b/src/shared/loop-util.c
@@ -133,7 +133,7 @@ LoopDevice* loop_device_unref(LoopDevice *d) {
 
                 if (d->nr >= 0 && !d->relinquished) {
                         if (ioctl(d->fd, LOOP_CLR_FD) < 0)
-                                log_debug_errno(errno, "Failed to clear loop device: %m");
+                                log_info_errno(errno, "Failed to clear loop device: %m");
 
                 }
 
@@ -145,10 +145,10 @@ LoopDevice* loop_device_unref(LoopDevice *d) {
 
                 control = open("/dev/loop-control", O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);
                 if (control < 0)
-                        log_debug_errno(errno, "Failed to open loop control device: %m");
+                        log_info_errno(errno, "Failed to open loop control device: %m");
                 else {
                         if (ioctl(control, LOOP_CTL_REMOVE, d->nr) < 0)
-                                log_debug_errno(errno, "Failed to remove loop device: %m");
+                                log_info_errno(errno, "Failed to remove loop device: %m");
                 }
         }
 
diff --git a/src/shared/machine-image.c b/src/shared/machine-image.c
index 66eefb303..25c06df55 100644
--- a/src/shared/machine-image.c
+++ b/src/shared/machine-image.c
@@ -311,7 +311,7 @@ static int image_make(
 
                 block_fd = openat(dfd, filename, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_NOCTTY);
                 if (block_fd < 0)
-                        log_debug_errno(errno, "Failed to open block device %s/%s, ignoring: %m", path, filename);
+                        log_info_errno(errno, "Failed to open block device %s/%s, ignoring: %m", path, filename);
                 else {
                         if (fstat(block_fd, &st) < 0)
                                 return -errno;
@@ -322,13 +322,13 @@ static int image_make(
                                 int state = 0;
 
                                 if (ioctl(block_fd, BLKROGET, &state) < 0)
-                                        log_debug_errno(errno, "Failed to issue BLKROGET on device %s/%s, ignoring: %m", path, filename);
+                                        log_info_errno(errno, "Failed to issue BLKROGET on device %s/%s, ignoring: %m", path, filename);
                                 else if (state)
                                         read_only = true;
                         }
 
                         if (ioctl(block_fd, BLKGETSIZE64, &size) < 0)
-                                log_debug_errno(errno, "Failed to issue BLKFLSBUF on device %s/%s, ignoring: %m", path, filename);
+                                log_info_errno(errno, "Failed to issue BLKFLSBUF on device %s/%s, ignoring: %m", path, filename);
 
                         block_fd = safe_close(block_fd);
                 }
@@ -526,11 +526,11 @@ int image_remove(Image *i) {
 
         STRV_FOREACH(j, settings) {
                 if (unlink(*j) < 0 && errno != ENOENT)
-                        log_debug_errno(errno, "Failed to unlink %s, ignoring: %m", *j);
+                        log_info_errno(errno, "Failed to unlink %s, ignoring: %m", *j);
         }
 
         if (unlink(roothash) < 0 && errno != ENOENT)
-                log_debug_errno(errno, "Failed to unlink %s, ignoring: %m", roothash);
+                log_info_errno(errno, "Failed to unlink %s, ignoring: %m", roothash);
 
         return 0;
 }
@@ -646,12 +646,12 @@ int image_rename(Image *i, const char *new_name) {
         STRV_FOREACH(j, settings) {
                 r = rename_auxiliary_file(*j, new_name, ".nspawn");
                 if (r < 0 && r != -ENOENT)
-                        log_debug_errno(r, "Failed to rename settings file %s, ignoring: %m", *j);
+                        log_info_errno(r, "Failed to rename settings file %s, ignoring: %m", *j);
         }
 
         r = rename_auxiliary_file(roothash, new_name, ".roothash");
         if (r < 0 && r != -ENOENT)
-                log_debug_errno(r, "Failed to rename roothash file %s, ignoring: %m", roothash);
+                log_info_errno(r, "Failed to rename roothash file %s, ignoring: %m", roothash);
 
         return 0;
 }
@@ -742,12 +742,12 @@ int image_clone(Image *i, const char *new_name, bool read_only) {
         STRV_FOREACH(j, settings) {
                 r = clone_auxiliary_file(*j, new_name, ".nspawn");
                 if (r < 0 && r != -ENOENT)
-                        log_debug_errno(r, "Failed to clone settings %s, ignoring: %m", *j);
+                        log_info_errno(r, "Failed to clone settings %s, ignoring: %m", *j);
         }
 
         r = clone_auxiliary_file(roothash, new_name, ".roothash");
         if (r < 0 && r != -ENOENT)
-                log_debug_errno(r, "Failed to clone root hash file %s, ignoring: %m", roothash);
+                log_info_errno(r, "Failed to clone root hash file %s, ignoring: %m", roothash);
 
         return 0;
 }
@@ -940,28 +940,28 @@ int image_read_metadata(Image *i) {
 
                 r = chase_symlinks("/etc/hostname", i->path, CHASE_PREFIX_ROOT, &path);
                 if (r < 0 && r != -ENOENT)
-                        log_debug_errno(r, "Failed to chase /etc/hostname in image %s: %m", i->name);
+                        log_info_errno(r, "Failed to chase /etc/hostname in image %s: %m", i->name);
                 else if (r >= 0) {
                         r = read_etc_hostname(path, &hostname);
                         if (r < 0)
-                                log_debug_errno(errno, "Failed to read /etc/hostname of image %s: %m", i->name);
+                                log_info_errno(errno, "Failed to read /etc/hostname of image %s: %m", i->name);
                 }
 
                 path = mfree(path);
 
                 r = chase_symlinks("/etc/machine-id", i->path, CHASE_PREFIX_ROOT, &path);
                 if (r < 0 && r != -ENOENT)
-                        log_debug_errno(r, "Failed to chase /etc/machine-id in image %s: %m", i->name);
+                        log_info_errno(r, "Failed to chase /etc/machine-id in image %s: %m", i->name);
                 else if (r >= 0) {
                         _cleanup_close_ int fd = -1;
 
                         fd = open(path, O_RDONLY|O_CLOEXEC|O_NOCTTY);
                         if (fd < 0)
-                                log_debug_errno(errno, "Failed to open %s: %m", path);
+                                log_info_errno(errno, "Failed to open %s: %m", path);
                         else {
                                 r = id128_read_fd(fd, ID128_PLAIN, &machine_id);
                                 if (r < 0)
-                                        log_debug_errno(r, "Image %s contains invalid machine ID.", i->name);
+                                        log_info_errno(r, "Image %s contains invalid machine ID.", i->name);
                         }
                 }
 
@@ -969,11 +969,11 @@ int image_read_metadata(Image *i) {
 
                 r = chase_symlinks("/etc/machine-info", i->path, CHASE_PREFIX_ROOT, &path);
                 if (r < 0 && r != -ENOENT)
-                        log_debug_errno(r, "Failed to chase /etc/machine-info in image %s: %m", i->name);
+                        log_info_errno(r, "Failed to chase /etc/machine-info in image %s: %m", i->name);
                 else if (r >= 0) {
                         r = load_env_file_pairs(NULL, path, NULL, &machine_info);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to parse machine-info data of %s: %m", i->name);
+                                log_info_errno(r, "Failed to parse machine-info data of %s: %m", i->name);
                 }
 
                 path = mfree(path);
@@ -982,11 +982,11 @@ int image_read_metadata(Image *i) {
                 if (r == -ENOENT)
                         r = chase_symlinks("/usr/lib/os-release", i->path, CHASE_PREFIX_ROOT, &path);
                 if (r < 0 && r != -ENOENT)
-                        log_debug_errno(r, "Failed to chase os-release in image: %m");
+                        log_info_errno(r, "Failed to chase os-release in image: %m");
                 else if (r >= 0) {
                         r = load_env_file_pairs(NULL, path, NULL, &os_release);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to parse os-release data of %s: %m", i->name);
+                                log_info_errno(r, "Failed to parse os-release data of %s: %m", i->name);
                 }
 
                 free_and_replace(i->hostname, hostname);
diff --git a/src/shared/machine-pool.c b/src/shared/machine-pool.c
index 031d443e9..00c9ea8e8 100644
--- a/src/shared/machine-pool.c
+++ b/src/shared/machine-pool.c
@@ -217,7 +217,7 @@ int setup_machine_directory(uint64_t size, sd_bus_error *error) {
         }
 
         if (path_is_mount_point("/var/lib/machines", NULL, AT_SYMLINK_FOLLOW) > 0) {
-                log_debug("/var/lib/machines is already a mount point, not creating loopback file for it.");
+                log_info("/var/lib/machines is already a mount point, not creating loopback file for it.");
                 return 0;
         }
 
@@ -225,7 +225,7 @@ int setup_machine_directory(uint64_t size, sd_bus_error *error) {
         if (r < 0 && r != -ENOENT)
                 return r;
         if (r > 0) {
-                log_debug("/var/log/machines is already populated, not creating loopback file for it.");
+                log_info("/var/log/machines is already populated, not creating loopback file for it.");
                 return 0;
         }
 
diff --git a/src/shared/path-lookup.c b/src/shared/path-lookup.c
index d57c78a8b..1ca2bdfe6 100644
--- a/src/shared/path-lookup.c
+++ b/src/shared/path-lookup.c
@@ -765,7 +765,7 @@ int lookup_paths_reduce(LookupPaths *p) {
                                 goto remove_item;
 
                         /* If something we don't grok happened, let's better leave it in. */
-                        log_debug_errno(errno, "Failed to stat %s: %m", p->search_path[c]);
+                        log_info_errno(errno, "Failed to stat %s: %m", p->search_path[c]);
                         c++;
                         continue;
                 }
@@ -794,7 +794,7 @@ int lookup_paths_reduce(LookupPaths *p) {
         }
 
         if (strv_isempty(p->search_path)) {
-                log_debug("Ignoring unit files.");
+                log_info("Ignoring unit files.");
                 p->search_path = strv_free(p->search_path);
         } else {
                 _cleanup_free_ char *t;
@@ -803,7 +803,7 @@ int lookup_paths_reduce(LookupPaths *p) {
                 if (!t)
                         return -ENOMEM;
 
-                log_debug("Looking for unit files in (higher priority first):\n\t%s", t);
+                log_info("Looking for unit files in (higher priority first):\n\t%s", t);
         }
 
         return 0;
diff --git a/src/shared/ptyfwd.c b/src/shared/ptyfwd.c
index 94a4dd513..aef7761cb 100644
--- a/src/shared/ptyfwd.c
+++ b/src/shared/ptyfwd.c
@@ -183,12 +183,12 @@ static bool drained(PTYForward *f) {
                 return false;
 
         if (ioctl(f->master, TIOCINQ, &q) < 0)
-                log_debug_errno(errno, "TIOCINQ failed on master: %m");
+                log_info_errno(errno, "TIOCINQ failed on master: %m");
         else if (q > 0)
                 return false;
 
         if (ioctl(f->master, TIOCOUTQ, &q) < 0)
-                log_debug_errno(errno, "TIOCOUTQ failed on master: %m");
+                log_info_errno(errno, "TIOCOUTQ failed on master: %m");
         else if (q > 0)
                 return false;
 
diff --git a/src/shared/seccomp-util.c b/src/shared/seccomp-util.c
index fbb232cd4..264e39f73 100644
--- a/src/shared/seccomp-util.c
+++ b/src/shared/seccomp-util.c
@@ -822,7 +822,7 @@ int seccomp_add_syscall_filter_item(scmp_filter_ctx *seccomp, const char *name,
 
                 other = syscall_filter_set_find(name);
                 if (!other) {
-                        log_debug("Filter set %s is not known!", name);
+                        log_info("Filter set %s is not known!", name);
                         return -EINVAL;
                 }
 
@@ -834,14 +834,14 @@ int seccomp_add_syscall_filter_item(scmp_filter_ctx *seccomp, const char *name,
 
                 id = seccomp_syscall_resolve_name(name);
                 if (id == __NR_SCMP_ERROR) {
-                        log_debug("System call %s is not known, ignoring.", name);
+                        log_info("System call %s is not known, ignoring.", name);
                         return 0;
                 }
 
                 r = seccomp_rule_add_exact(seccomp, action, id, 0);
                 if (r < 0)
                         /* If the system call is not known on this architecture, then that's fine, let's ignore it */
-                        log_debug_errno(r, "Failed to add rule for system call %s() / %d, ignoring: %m", name, id);
+                        log_info_errno(r, "Failed to add rule for system call %s() / %d, ignoring: %m", name, id);
         }
 
         return 0;
@@ -880,7 +880,7 @@ int seccomp_load_syscall_filter_set(uint32_t default_action, const SyscallFilter
         SECCOMP_FOREACH_LOCAL_ARCH(arch) {
                 _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;
 
-                log_debug("Operating on architecture: %s", seccomp_arch_to_string(arch));
+                log_info("Operating on architecture: %s", seccomp_arch_to_string(arch));
 
                 r = seccomp_init_for_arch(&seccomp, arch, default_action);
                 if (r < 0)
@@ -888,7 +888,7 @@ int seccomp_load_syscall_filter_set(uint32_t default_action, const SyscallFilter
 
                 r = seccomp_add_syscall_filter_set(seccomp, set, action, NULL);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to add filter set, ignoring: %m");
+                        log_info_errno(r, "Failed to add filter set, ignoring: %m");
                         continue;
                 }
 
@@ -896,7 +896,7 @@ int seccomp_load_syscall_filter_set(uint32_t default_action, const SyscallFilter
                 if (IN_SET(r, -EPERM, -EACCES))
                         return r;
                 if (r < 0)
-                        log_debug_errno(r, "Failed to install filter set for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to install filter set for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         return 0;
@@ -917,7 +917,7 @@ int seccomp_load_syscall_filter_set_raw(uint32_t default_action, Hashmap* set, u
                 Iterator i;
                 void *id, *val;
 
-                log_debug("Operating on architecture: %s", seccomp_arch_to_string(arch));
+                log_info("Operating on architecture: %s", seccomp_arch_to_string(arch));
 
                 r = seccomp_init_for_arch(&seccomp, arch, default_action);
                 if (r < 0)
@@ -936,7 +936,7 @@ int seccomp_load_syscall_filter_set_raw(uint32_t default_action, Hashmap* set, u
                                 _cleanup_free_ char *n = NULL;
 
                                 n = seccomp_syscall_resolve_num_arch(arch, PTR_TO_INT(id) - 1);
-                                log_debug_errno(r, "Failed to add rule for system call %s() / %d, ignoring: %m", strna(n), PTR_TO_INT(id) - 1);
+                                log_info_errno(r, "Failed to add rule for system call %s() / %d, ignoring: %m", strna(n), PTR_TO_INT(id) - 1);
                         }
                 }
 
@@ -944,7 +944,7 @@ int seccomp_load_syscall_filter_set_raw(uint32_t default_action, Hashmap* set, u
                 if (IN_SET(r, -EPERM, -EACCES))
                         return r;
                 if (r < 0)
-                        log_debug_errno(r, "Failed to install filter set for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to install filter set for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         return 0;
@@ -1017,7 +1017,7 @@ int seccomp_restrict_namespaces(unsigned long retain) {
                 _cleanup_free_ char *s = NULL;
 
                 (void) namespace_flag_to_string_many(retain, &s);
-                log_debug("Restricting namespace to: %s.", strna(s));
+                log_info("Restricting namespace to: %s.", strna(s));
         }
 
         /* NOOP? */
@@ -1028,7 +1028,7 @@ int seccomp_restrict_namespaces(unsigned long retain) {
                 _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;
                 unsigned i;
 
-                log_debug("Operating on architecture: %s", seccomp_arch_to_string(arch));
+                log_info("Operating on architecture: %s", seccomp_arch_to_string(arch));
 
                 r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);
                 if (r < 0)
@@ -1052,7 +1052,7 @@ int seccomp_restrict_namespaces(unsigned long retain) {
                                         1,
                                         SCMP_A1(SCMP_CMP_EQ, 0));
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to add setns() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to add setns() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                         continue;
                 }
 
@@ -1061,11 +1061,11 @@ int seccomp_restrict_namespaces(unsigned long retain) {
 
                         f = namespace_flag_map[i].flag;
                         if ((retain & f) == f) {
-                                log_debug("Permitting %s.", namespace_flag_map[i].name);
+                                log_info("Permitting %s.", namespace_flag_map[i].name);
                                 continue;
                         }
 
-                        log_debug("Blocking %s.", namespace_flag_map[i].name);
+                        log_info("Blocking %s.", namespace_flag_map[i].name);
 
                         r = seccomp_rule_add_exact(
                                         seccomp,
@@ -1074,7 +1074,7 @@ int seccomp_restrict_namespaces(unsigned long retain) {
                                         1,
                                         SCMP_A0(SCMP_CMP_MASKED_EQ, f, f));
                         if (r < 0) {
-                                log_debug_errno(r, "Failed to add unshare() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                                log_info_errno(r, "Failed to add unshare() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                                 break;
                         }
 
@@ -1094,7 +1094,7 @@ int seccomp_restrict_namespaces(unsigned long retain) {
                                                 1,
                                                 SCMP_A1(SCMP_CMP_MASKED_EQ, f, f));
                         if (r < 0) {
-                                log_debug_errno(r, "Failed to add clone() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                                log_info_errno(r, "Failed to add clone() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                                 break;
                         }
 
@@ -1106,7 +1106,7 @@ int seccomp_restrict_namespaces(unsigned long retain) {
                                                 1,
                                                 SCMP_A1(SCMP_CMP_MASKED_EQ, f, f));
                                 if (r < 0) {
-                                        log_debug_errno(r, "Failed to add setns() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                                        log_info_errno(r, "Failed to add setns() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                                         break;
                                 }
                         }
@@ -1118,7 +1118,7 @@ int seccomp_restrict_namespaces(unsigned long retain) {
                 if (IN_SET(r, -EPERM, -EACCES))
                         return r;
                 if (r < 0)
-                        log_debug_errno(r, "Failed to install namespace restriction rules for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to install namespace restriction rules for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         return 0;
@@ -1131,7 +1131,7 @@ int seccomp_protect_sysctl(void) {
         SECCOMP_FOREACH_LOCAL_ARCH(arch) {
                 _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;
 
-                log_debug("Operating on architecture: %s", seccomp_arch_to_string(arch));
+                log_info("Operating on architecture: %s", seccomp_arch_to_string(arch));
 
                 if (IN_SET(arch, SCMP_ARCH_X32, SCMP_ARCH_AARCH64))
                         /* No _sysctl syscall */
@@ -1147,7 +1147,7 @@ int seccomp_protect_sysctl(void) {
                                 SCMP_SYS(_sysctl),
                                 0);
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to add _sysctl() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to add _sysctl() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                         continue;
                 }
 
@@ -1155,7 +1155,7 @@ int seccomp_protect_sysctl(void) {
                 if (IN_SET(r, -EPERM, -EACCES))
                         return r;
                 if (r < 0)
-                        log_debug_errno(r, "Failed to install sysctl protection rules for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to install sysctl protection rules for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         return 0;
@@ -1170,7 +1170,7 @@ int seccomp_restrict_address_families(Set *address_families, bool whitelist) {
                 bool supported;
                 Iterator i;
 
-                log_debug("Operating on architecture: %s", seccomp_arch_to_string(arch));
+                log_info("Operating on architecture: %s", seccomp_arch_to_string(arch));
 
                 switch (arch) {
 
@@ -1234,7 +1234,7 @@ int seccomp_restrict_address_families(Set *address_families, bool whitelist) {
                                                 SCMP_SYS(socket),
                                                 0);
                                 if (r < 0) {
-                                        log_debug_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                                        log_info_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                                         continue;
                                 }
 
@@ -1248,7 +1248,7 @@ int seccomp_restrict_address_families(Set *address_families, bool whitelist) {
                                                 1,
                                                 SCMP_A0(SCMP_CMP_LT, first));
                                 if (r < 0) {
-                                        log_debug_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                                        log_info_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                                         continue;
                                 }
 
@@ -1260,7 +1260,7 @@ int seccomp_restrict_address_families(Set *address_families, bool whitelist) {
                                                 1,
                                                 SCMP_A0(SCMP_CMP_GT, last));
                                 if (r < 0) {
-                                        log_debug_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                                        log_info_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                                         continue;
                                 }
 
@@ -1280,7 +1280,7 @@ int seccomp_restrict_address_families(Set *address_families, bool whitelist) {
                                                 break;
                                 }
                                 if (r < 0) {
-                                        log_debug_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                                        log_info_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                                         continue;
                                 }
                         }
@@ -1304,7 +1304,7 @@ int seccomp_restrict_address_families(Set *address_families, bool whitelist) {
                                         break;
                         }
                         if (r < 0) {
-                                log_debug_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                                log_info_errno(r, "Failed to add socket() rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                                 continue;
                         }
                 }
@@ -1313,7 +1313,7 @@ int seccomp_restrict_address_families(Set *address_families, bool whitelist) {
                 if (IN_SET(r, -EPERM, -EACCES))
                         return r;
                 if (r < 0)
-                        log_debug_errno(r, "Failed to install socket family rules for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to install socket family rules for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         return 0;
@@ -1339,7 +1339,7 @@ int seccomp_restrict_realtime(void) {
                 _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;
                 int p;
 
-                log_debug("Operating on architecture: %s", seccomp_arch_to_string(arch));
+                log_info("Operating on architecture: %s", seccomp_arch_to_string(arch));
 
                 r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);
                 if (r < 0)
@@ -1368,7 +1368,7 @@ int seccomp_restrict_realtime(void) {
                                         1,
                                         SCMP_A1(SCMP_CMP_EQ, p));
                         if (r < 0) {
-                                log_debug_errno(r, "Failed to add scheduler rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                                log_info_errno(r, "Failed to add scheduler rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                                 continue;
                         }
                 }
@@ -1382,7 +1382,7 @@ int seccomp_restrict_realtime(void) {
                                 1,
                                 SCMP_A1(SCMP_CMP_GT, max_policy));
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to add scheduler rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to add scheduler rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                         continue;
                 }
 
@@ -1390,7 +1390,7 @@ int seccomp_restrict_realtime(void) {
                 if (IN_SET(r, -EPERM, -EACCES))
                         return r;
                 if (r < 0)
-                        log_debug_errno(r, "Failed to install realtime protection rules for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to install realtime protection rules for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         return 0;
@@ -1408,7 +1408,7 @@ static int add_seccomp_syscall_filter(scmp_filter_ctx seccomp,
                 _cleanup_free_ char *n = NULL;
 
                 n = seccomp_syscall_resolve_num_arch(arch, nr);
-                log_debug_errno(r, "Failed to add %s() rule for architecture %s, skipping: %m",
+                log_info_errno(r, "Failed to add %s() rule for architecture %s, skipping: %m",
                                 strna(n),
                                 seccomp_arch_to_string(arch));
         }
@@ -1436,7 +1436,7 @@ int seccomp_memory_deny_write_execute(void) {
                 _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;
                 int filter_syscall = 0, block_syscall = 0, shmat_syscall = 0;
 
-                log_debug("Operating on architecture: %s", seccomp_arch_to_string(arch));
+                log_info("Operating on architecture: %s", seccomp_arch_to_string(arch));
 
                 switch (arch) {
 
@@ -1521,7 +1521,7 @@ int seccomp_memory_deny_write_execute(void) {
                 if (IN_SET(r, -EPERM, -EACCES))
                         return r;
                 if (r < 0)
-                        log_debug_errno(r, "Failed to install MemoryDenyWriteExecute= rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to install MemoryDenyWriteExecute= rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         return 0;
@@ -1556,7 +1556,7 @@ int seccomp_restrict_archs(Set *archs) {
         if (IN_SET(r, -EPERM, -EACCES))
                 return r;
         if (r < 0)
-                log_debug_errno(r, "Failed to restrict system call architectures, skipping: %m");
+                log_info_errno(r, "Failed to restrict system call architectures, skipping: %m");
 
         return 0;
 }
@@ -1614,7 +1614,7 @@ int seccomp_filter_set_add(Hashmap *filter, bool add, const SyscallFilterSet *se
 
                         id = seccomp_syscall_resolve_name(i);
                         if (id == __NR_SCMP_ERROR) {
-                                log_debug("Couldn't resolve system call, ignoring: %s", i);
+                                log_info("Couldn't resolve system call, ignoring: %s", i);
                                 continue;
                         }
 
@@ -1651,7 +1651,7 @@ int seccomp_lock_personality(unsigned long personality) {
                                 1,
                                 SCMP_A0(SCMP_CMP_NE, personality));
                 if (r < 0) {
-                        log_debug_errno(r, "Failed to add scheduler rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to add scheduler rule for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
                         continue;
                 }
 
@@ -1659,7 +1659,7 @@ int seccomp_lock_personality(unsigned long personality) {
                 if (IN_SET(r, -EPERM, -EACCES))
                         return r;
                 if (r < 0)
-                        log_debug_errno(r, "Failed to enable personality lock for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
+                        log_info_errno(r, "Failed to enable personality lock for architecture %s, skipping: %m", seccomp_arch_to_string(arch));
         }
 
         return 0;
diff --git a/src/shared/sleep-config.c b/src/shared/sleep-config.c
index ecac98e0a..c57ce7827 100644
--- a/src/shared/sleep-config.c
+++ b/src/shared/sleep-config.c
@@ -223,7 +223,7 @@ static int hibernation_partition_size(size_t *size, size_t *used) {
                 return 0;
         }
 
-        log_debug("No swap partitions were found.");
+        log_info("No swap partitions were found.");
         return -ENOSYS;
 }
 
@@ -254,7 +254,7 @@ static bool enough_memory_for_hibernation(void) {
         }
 
         r = act <= (size - used) * HIBERNATION_SWAP_THRESHOLD;
-        log_debug("Hibernation is %spossible, Active(anon)=%llu kB, size=%zu kB, used=%zu kB, threshold=%.2g%%",
+        log_info("Hibernation is %spossible, Active(anon)=%llu kB, size=%zu kB, used=%zu kB, threshold=%.2g%%",
                   r ? "" : "im", act, size, used, 100*HIBERNATION_SWAP_THRESHOLD);
 
         return r;
diff --git a/src/shared/sysctl-util.c b/src/shared/sysctl-util.c
index 0bc81aaa5..4eac32111 100644
--- a/src/shared/sysctl-util.c
+++ b/src/shared/sysctl-util.c
@@ -62,7 +62,7 @@ int sysctl_write(const char *property, const char *value) {
         assert(property);
         assert(value);
 
-        log_debug("Setting '%s' to '%s'", property, value);
+        log_info("Setting '%s' to '%s'", property, value);
 
         p = strjoina("/proc/sys/", property);
         fd = open(p, O_WRONLY|O_CLOEXEC);
diff --git a/src/shared/udev-util.c b/src/shared/udev-util.c
index 65a09e9c2..4f96568a5 100644
--- a/src/shared/udev-util.c
+++ b/src/shared/udev-util.c
@@ -51,7 +51,7 @@ int udev_parse_config(void) {
          * to regulate the code in libudev/ and udev/. */
         r = log_set_max_level_from_string_realm(LOG_REALM_UDEV, log);
         if (r < 0)
-                log_debug_errno(r, "/etc/udev/udev.conf: failed to set udev log level '%s', ignoring: %m", log);
+                log_info_errno(r, "/etc/udev/udev.conf: failed to set udev log level '%s', ignoring: %m", log);
 
         return 0;
 }
diff --git a/src/sleep/sleep.c b/src/sleep/sleep.c
index 518032ec6..30a7f99ca 100644
--- a/src/sleep/sleep.c
+++ b/src/sleep/sleep.c
@@ -48,7 +48,7 @@ static int write_mode(char **modes) {
                 if (k == 0)
                         return 0;
 
-                log_debug_errno(k, "Failed to write '%s' to /sys/power/disk: %m",
+                log_info_errno(k, "Failed to write '%s' to /sys/power/disk: %m",
                                 *mode);
                 if (r == 0)
                         r = k;
@@ -70,7 +70,7 @@ static int write_state(FILE **f, char **states) {
                 k = write_string_stream(*f, *state, 0);
                 if (k == 0)
                         return 0;
-                log_debug_errno(k, "Failed to write '%s' to /sys/power/state: %m",
+                log_info_errno(k, "Failed to write '%s' to /sys/power/state: %m",
                                 *state);
                 if (r == 0)
                         r = k;
diff --git a/src/socket-proxy/socket-proxyd.c b/src/socket-proxy/socket-proxyd.c
index d4f401d99..d45c00f78 100644
--- a/src/socket-proxy/socket-proxyd.c
+++ b/src/socket-proxy/socket-proxyd.c
@@ -417,7 +417,7 @@ static int resolve_remote(Connection *c) {
                 service = "80";
         }
 
-        log_debug("Looking up address info for %s:%s", node, service);
+        log_info("Looking up address info for %s:%s", node, service);
         r = sd_resolve_getaddrinfo(c->context->resolve, &c->resolve_query, node, service, &hints, resolve_cb, c);
         if (r < 0) {
                 log_error_errno(r, "Failed to resolve remote host: %m");
@@ -488,7 +488,7 @@ static int accept_cb(sd_event_source *s, int fd, uint32_t revents, void *userdat
                         log_warning_errno(errno, "Failed to accept() socket: %m");
         } else {
                 getpeername_pretty(nfd, true, &peer);
-                log_debug("New connection from %s", strna(peer));
+                log_info("New connection from %s", strna(peer));
 
                 r = add_connection_socket(context, nfd);
                 if (r < 0) {
diff --git a/src/sysctl/sysctl.c b/src/sysctl/sysctl.c
index a1dc95b2b..540f1c7d1 100644
--- a/src/sysctl/sysctl.c
+++ b/src/sysctl/sysctl.c
@@ -104,7 +104,7 @@ static int parse_file(OrderedHashmap *sysctl_options, const char *path, bool ign
                 return log_error_errno(r, "Failed to open file '%s', ignoring: %m", path);
         }
 
-        log_debug("Parsing %s", path);
+        log_info("Parsing %s", path);
         for (;;) {
                 char *p, *value, *new_value, *property, *existing;
                 _cleanup_free_ char *l = NULL;
@@ -149,7 +149,7 @@ static int parse_file(OrderedHashmap *sysctl_options, const char *path, bool ign
                         if (streq(value, existing))
                                 continue;
 
-                        log_debug("Overwriting earlier assignment of %s at '%s:%u'.", p, path, c);
+                        log_info("Overwriting earlier assignment of %s at '%s:%u'.", p, path, c);
                         free(ordered_hashmap_remove(sysctl_options, p));
                         free(v);
                 }
diff --git a/src/systemctl/systemctl.c b/src/systemctl/systemctl.c
index 5732d88a1..6480ec9ca 100644
--- a/src/systemctl/systemctl.c
+++ b/src/systemctl/systemctl.c
@@ -648,7 +648,7 @@ static int get_unit_list(
                       sd_bus_error_has_name(&error, SD_BUS_ERROR_ACCESS_DENIED))) {
                 /* Fallback to legacy ListUnitsFiltered method */
                 fallback = true;
-                log_debug_errno(r, "Failed to list units: %s Falling back to ListUnitsFiltered method.", bus_error_message(&error, r));
+                log_info_errno(r, "Failed to list units: %s Falling back to ListUnitsFiltered method.", bus_error_message(&error, r));
                 m = sd_bus_message_unref(m);
                 sd_bus_error_free(&error);
 
@@ -1551,7 +1551,7 @@ static int list_unit_files(int argc, char *argv[], void *userdata) {
                 if (r < 0 && sd_bus_error_has_name(&error, SD_BUS_ERROR_UNKNOWN_METHOD)) {
                         /* Fallback to legacy ListUnitFiles method */
                         fallback = true;
-                        log_debug_errno(r, "Failed to list unit files: %s Falling back to ListUnitsFiles method.", bus_error_message(&error, r));
+                        log_info_errno(r, "Failed to list unit files: %s Falling back to ListUnitsFiles method.", bus_error_message(&error, r));
                         m = sd_bus_message_unref(m);
                         sd_bus_error_free(&error);
 
@@ -2216,7 +2216,7 @@ static int output_waiting_jobs(sd_bus *bus, uint32_t id, const char *method, con
                         &reply,
                         "u", id);
         if (r < 0)
-                return log_debug_errno(r, "Failed to get waiting jobs for job %" PRIu32, id);
+                return log_info_errno(r, "Failed to get waiting jobs for job %" PRIu32, id);
 
         r = sd_bus_message_enter_container(reply, 'a', "(usssoo)");
         if (r < 0)
@@ -2836,11 +2836,11 @@ static int on_properties_changed(sd_bus_message *m, void *userdata, sd_bus_error
 
                         is_failed = streq(s, "failed");
                         if (streq(s, "inactive") || is_failed) {
-                                log_debug("%s became %s, dropping from --wait tracking", path, s);
+                                log_info("%s became %s, dropping from --wait tracking", path, s);
                                 free(set_remove(c->unit_paths, path));
                                 c->any_failed = c->any_failed || is_failed;
                         } else
-                                log_debug("ActiveState on %s changed to %s", path, s);
+                                log_info("ActiveState on %s changed to %s", path, s);
 
                         break; /* no need to dissect the rest of the message */
                 } else {
@@ -2883,7 +2883,7 @@ static int start_unit_one(
         if (wait_context) {
                 _cleanup_free_ char *unit_path = NULL;
 
-                log_debug("Watching for property changes of %s", name);
+                log_info("Watching for property changes of %s", name);
                 r = sd_bus_call_method(
                                 bus,
                                 "org.freedesktop.systemd1",
@@ -2915,7 +2915,7 @@ static int start_unit_one(
                         return log_error_errno(r, "Failed to request match for PropertiesChanged signal: %m");
         }
 
-        log_debug("%s manager for %s on %s, %s",
+        log_info("%s manager for %s on %s, %s",
                   arg_dry_run ? "Would call" : "Calling",
                   method, name, mode);
         if (arg_dry_run)
@@ -2960,7 +2960,7 @@ static int start_unit_one(
                 warn_unit_file_changed(name);
 
         if (w) {
-                log_debug("Adding %s to the set", path);
+                log_info("Adding %s to the set", path);
                 r = bus_wait_for_jobs_add(w, path);
                 if (r < 0)
                         return log_oom();
@@ -3462,7 +3462,7 @@ static int prepare_firmware_setup(void) {
 
                 r = efi_set_reboot_to_firmware(true);
                 if (r < 0)
-                        log_debug_errno(r, "Cannot indicate to EFI to boot into setup mode, will retry via logind: %m");
+                        log_info_errno(r, "Cannot indicate to EFI to boot into setup mode, will retry via logind: %m");
                 else
                         return r;
         }
@@ -3478,7 +3478,7 @@ static int load_kexec_kernel(void) {
         int r;
 
         if (kexec_loaded()) {
-                log_debug("Kexec kernel already loaded.");
+                log_info("Kexec kernel already loaded.");
                 return 0;
         }
 
@@ -3510,7 +3510,7 @@ static int load_kexec_kernel(void) {
         if (!options)
                 return log_oom();
 
-        log_debug("%s kexec kernel %s initrd %s options \"%s\".",
+        log_info("%s kexec kernel %s initrd %s options \"%s\".",
                   arg_dry_run ? "Would load" : "loading",
                   kernel, initrd, options);
         if (arg_dry_run)
@@ -4662,7 +4662,7 @@ static int status_property(const char *name, sd_bus_message *m, UnitStatusInfo *
                         while ((r = sd_bus_message_read(m, "(sbbsi)", &cond, &trigger, &negate, &param, &state)) > 0) {
                                 _cleanup_(unit_condition_freep) UnitCondition *c = NULL;
 
-                                log_debug("%s trigger=%d negate=%d %s →%d", cond, trigger, negate, param, state);
+                                log_info("%s trigger=%d negate=%d %s →%d", cond, trigger, negate, param, state);
 
                                 c = new0(UnitCondition, 1);
                                 if (!c)
@@ -4697,7 +4697,7 @@ static int status_property(const char *name, sd_bus_message *m, UnitStatusInfo *
                                 return bus_log_parse_error(r);
 
                         while ((r = sd_bus_message_read(m, "(sbbsi)", &cond, &trigger, &negate, &param, &state)) > 0) {
-                                log_debug("%s %d %d %s %d", cond, trigger, negate, param, state);
+                                log_info("%s %d %d %s %d", cond, trigger, negate, param, state);
                                 if (state < 0 && (!trigger || !i->failed_assert)) {
                                         i->failed_assert = cond;
                                         i->failed_assert_trigger = trigger;
@@ -5113,7 +5113,7 @@ static int show_one(
         assert(path);
         assert(new_line);
 
-        log_debug("Showing one %s", path);
+        log_info("Showing one %s", path);
 
         r = sd_bus_call_method(
                         bus,
@@ -5208,7 +5208,7 @@ static int show_one(
 
                 STRV_FOREACH(pp, arg_properties)
                         if (!set_contains(found_properties, *pp))
-                                log_debug("Property %s does not exist.", *pp);
+                                log_info("Property %s does not exist.", *pp);
 
         } else if (streq(verb, "help"))
                 show_unit_help(&info);
@@ -5843,7 +5843,7 @@ static int switch_root(int argc, char *argv[], void *userdata) {
                                    "init", &cmdline_init,
                                    NULL);
                 if (r < 0)
-                        log_debug_errno(r, "Failed to parse /proc/cmdline: %m");
+                        log_info_errno(r, "Failed to parse /proc/cmdline: %m");
 
                 init = cmdline_init;
         }
@@ -5878,7 +5878,7 @@ static int switch_root(int argc, char *argv[], void *userdata) {
         if (r < 0)
                 log_warning_errno(r, "Failed to change disposition of SIGTERM to ignore: %m");
 
-        log_debug("Switching root - root: %s; init: %s", root, strna(init));
+        log_info("Switching root - root: %s; init: %s", root, strna(init));
 
         r = sd_bus_call_method(
                         bus,
@@ -8612,7 +8612,7 @@ static int halt_main(void) {
 
         if (!arg_no_wtmp) {
                 if (sd_booted() > 0)
-                        log_debug("Not writing utmp record, assuming that systemd-update-utmp is used.");
+                        log_info("Not writing utmp record, assuming that systemd-update-utmp is used.");
                 else {
                         r = utmp_put_shutdown();
                         if (r < 0)
diff --git a/src/sysusers/sysusers.c b/src/sysusers/sysusers.c
index e06b4b6d5..599b0c29d 100644
--- a/src/sysusers/sysusers.c
+++ b/src/sysusers/sysusers.c
@@ -923,7 +923,7 @@ static int add_user(Item *i) {
         /* Check the database directly */
         z = hashmap_get(database_user, i->name);
         if (z) {
-                log_debug("User %s already exists.", i->name);
+                log_info("User %s already exists.", i->name);
                 i->uid = PTR_TO_UID(z);
                 i->uid_set = true;
                 return 0;
@@ -936,7 +936,7 @@ static int add_user(Item *i) {
                 errno = 0;
                 p = getpwnam(i->name);
                 if (p) {
-                        log_debug("User %s already exists.", i->name);
+                        log_info("User %s already exists.", i->name);
                         i->uid = p->pw_uid;
                         i->uid_set = true;
 
@@ -956,7 +956,7 @@ static int add_user(Item *i) {
                 if (r < 0)
                         return log_error_errno(r, "Failed to verify uid " UID_FMT ": %m", i->uid);
                 if (r == 0) {
-                        log_debug("Suggested user ID " UID_FMT " for %s already used.", i->uid, i->name);
+                        log_info("Suggested user ID " UID_FMT " for %s already used.", i->uid, i->name);
                         i->uid_set = false;
                 }
         }
@@ -968,7 +968,7 @@ static int add_user(Item *i) {
                 if (read_id_from_file(i, &c, NULL) > 0) {
 
                         if (c <= 0 || !uid_range_contains(uid_range, n_uid_range, c))
-                                log_debug("User ID " UID_FMT " of file not suitable for %s.", c, i->name);
+                                log_info("User ID " UID_FMT " of file not suitable for %s.", c, i->name);
                         else {
                                 r = uid_is_ok(c, i->name);
                                 if (r < 0)
@@ -977,7 +977,7 @@ static int add_user(Item *i) {
                                         i->uid = c;
                                         i->uid_set = true;
                                 } else
-                                        log_debug("User ID " UID_FMT " of file for %s is already used.", c, i->name);
+                                        log_info("User ID " UID_FMT " of file for %s is already used.", c, i->name);
                         }
                 }
         }
@@ -1072,7 +1072,7 @@ static int add_group(Item *i) {
         /* Check the database directly */
         z = hashmap_get(database_group, i->name);
         if (z) {
-                log_debug("Group %s already exists.", i->name);
+                log_info("Group %s already exists.", i->name);
                 i->gid = PTR_TO_GID(z);
                 i->gid_set = true;
                 return 0;
@@ -1085,7 +1085,7 @@ static int add_group(Item *i) {
                 errno = 0;
                 g = getgrnam(i->name);
                 if (g) {
-                        log_debug("Group %s already exists.", i->name);
+                        log_info("Group %s already exists.", i->name);
                         i->gid = g->gr_gid;
                         i->gid_set = true;
                         return 0;
@@ -1112,7 +1112,7 @@ static int add_group(Item *i) {
                                 return 0;
                 }
                 if (r == 0) {
-                        log_debug("Suggested group ID " GID_FMT " for %s already used.", i->gid, i->name);
+                        log_info("Suggested group ID " GID_FMT " for %s already used.", i->gid, i->name);
                         i->gid_set = false;
                 }
         }
@@ -1135,7 +1135,7 @@ static int add_group(Item *i) {
                 if (read_id_from_file(i, NULL, &c) > 0) {
 
                         if (c <= 0 || !uid_range_contains(uid_range, n_uid_range, c))
-                                log_debug("Group ID " GID_FMT " of file not suitable for %s.", c, i->name);
+                                log_info("Group ID " GID_FMT " of file not suitable for %s.", c, i->name);
                         else {
                                 r = gid_is_ok(c);
                                 if (r < 0)
@@ -1144,7 +1144,7 @@ static int add_group(Item *i) {
                                         i->gid = c;
                                         i->gid_set = true;
                                 } else
-                                        log_debug("Group ID " GID_FMT " of file for %s already used.", c, i->name);
+                                        log_info("Group ID " GID_FMT " of file for %s already used.", c, i->name);
                         }
                 }
         }
@@ -1253,7 +1253,7 @@ static int add_implicit(void) {
                         if (r < 0)
                                 return log_oom();
 
-                        log_debug("Adding implicit group '%s' due to m line", j->name);
+                        log_info("Adding implicit group '%s' due to m line", j->name);
                         j = NULL;
                 }
 
@@ -1280,7 +1280,7 @@ static int add_implicit(void) {
                                 if (r < 0)
                                         return log_oom();
 
-                                log_debug("Adding implicit user '%s' due to m line", j->name);
+                                log_info("Adding implicit user '%s' due to m line", j->name);
                                 j = NULL;
                         }
                 }
diff --git a/src/sysv-generator/sysv-generator.c b/src/sysv-generator/sysv-generator.c
index 087ba0855..a9277b05b 100644
--- a/src/sysv-generator/sysv-generator.c
+++ b/src/sysv-generator/sysv-generator.c
@@ -354,7 +354,7 @@ static int handle_provides(SysvStub *s, unsigned line, const char *full_text, co
                 switch (unit_name_to_type(m)) {
 
                 case UNIT_SERVICE:
-                        log_debug("Adding Provides: alias '%s' for '%s'", m, s->name);
+                        log_info("Adding Provides: alias '%s' for '%s'", m, s->name);
                         r = add_alias(s->name, m);
                         if (r < 0)
                                 log_warning_errno(r, "[%s:%u] Failed to add LSB Provides name %s, ignoring: %m", s->path, line, m);
@@ -464,7 +464,7 @@ static int load_sysv(SysvStub *s) {
                 return log_error_errno(errno, "Failed to open %s: %m", s->path);
         }
 
-        log_debug("Loading SysV script %s", s->path);
+        log_info("Loading SysV script %s", s->path);
 
         FOREACH_LINE(l, f, goto fail) {
                 char *t;
@@ -794,10 +794,10 @@ static int enumerate_sysv(const LookupPaths *lp, Hashmap *all_services) {
 
                         r = unit_file_exists(UNIT_FILE_SYSTEM, lp, name);
                         if (r < 0 && !IN_SET(r, -ELOOP, -ERFKILL, -EADDRNOTAVAIL)) {
-                                log_debug_errno(r, "Failed to detect whether %s exists, skipping: %m", name);
+                                log_info_errno(r, "Failed to detect whether %s exists, skipping: %m", name);
                                 continue;
                         } else if (r != 0) {
-                                log_debug("Native unit for %s already exists, skipping.", name);
+                                log_info("Native unit for %s already exists, skipping.", name);
                                 continue;
                         }
 
@@ -891,7 +891,7 @@ static int set_dependencies_from_rcnd(const LookupPaths *lp, Hashmap *all_servic
 
                                 service = hashmap_get(all_services, name);
                                 if (!service) {
-                                        log_debug("Ignoring %s symlink in %s, not generating %s.", de->d_name, rcnd_table[i].path, name);
+                                        log_info("Ignoring %s symlink in %s, not generating %s.", de->d_name, rcnd_table[i].path, name);
                                         continue;
                                 }
 
diff --git a/src/test/test-conf-files.c b/src/test/test-conf-files.c
index de91efac7..0c37347d1 100644
--- a/src/test/test-conf-files.c
+++ b/src/test/test-conf-files.c
@@ -51,7 +51,7 @@ static void test_conf_files_list(bool use_root) {
         _cleanup_strv_free_ char **found_files = NULL, **found_files2 = NULL;
         const char *root_dir, *search_1, *search_2, *expect_a, *expect_b, *expect_c;
 
-        log_debug("/* %s */", __func__);
+        log_info("/* %s */", __func__);
 
         setup_test_dir(tmp_dir,
                        "/dir1/a.conf",
@@ -74,7 +74,7 @@ static void test_conf_files_list(bool use_root) {
         expect_b = strjoina(tmp_dir, "/dir2/b.conf");
         expect_c = strjoina(tmp_dir, "/dir2/c.foo");
 
-        log_debug("/* Check when filtered by suffix */");
+        log_info("/* Check when filtered by suffix */");
 
         assert_se(conf_files_list(&found_files, ".conf", root_dir, 0, search_1, search_2, NULL) == 0);
         strv_print(found_files);
@@ -84,7 +84,7 @@ static void test_conf_files_list(bool use_root) {
         assert_se(streq_ptr(found_files[1], expect_b));
         assert_se(found_files[2] == NULL);
 
-        log_debug("/* Check when unfiltered */");
+        log_info("/* Check when unfiltered */");
         assert_se(conf_files_list(&found_files2, NULL, root_dir, 0, search_1, search_2, NULL) == 0);
         strv_print(found_files2);
 
diff --git a/src/test/test-dns-domain.c b/src/test/test-dns-domain.c
index 0ad7d088a..dea6d11c6 100644
--- a/src/test/test-dns-domain.c
+++ b/src/test/test-dns-domain.c
@@ -638,7 +638,7 @@ static void test_dns_name_apply_idna_one(const char *s, int expected, const char
         int r;
 
         r = dns_name_apply_idna(s, &buf);
-        log_debug("dns_name_apply_idna: \"%s\" → %d/\"%s\" (expected %d/\"%s\")",
+        log_info("dns_name_apply_idna: \"%s\" → %d/\"%s\" (expected %d/\"%s\")",
                   s, r, strnull(buf), expected, strnull(result));
 
         /* Different libidn2 versions are more and less accepting
diff --git a/src/test/test-escape.c b/src/test/test-escape.c
index aa05520ab..84a634bf8 100644
--- a/src/test/test-escape.c
+++ b/src/test/test-escape.c
@@ -101,7 +101,7 @@ static void test_shell_maybe_quote_one(const char *s,
         _cleanup_free_ char *ret = NULL;
 
         assert_se(ret = shell_maybe_quote(s, style));
-        log_debug("[%s] → [%s] (%s)", s, ret, expected);
+        log_info("[%s] → [%s] (%s)", s, ret, expected);
         assert_se(streq(ret, expected));
 }
 
diff --git a/src/test/test-mount-util.c b/src/test/test-mount-util.c
index 09a624842..1a2cab265 100644
--- a/src/test/test-mount-util.c
+++ b/src/test/test-mount-util.c
@@ -81,15 +81,15 @@ static void test_mnt_id(void) {
 
                 r = path_get_mnt_id(p, &mnt_id2);
                 if (r == -EOPNOTSUPP) { /* kernel or file system too old? */
-                        log_debug("%s doesn't support mount IDs\n", p);
+                        log_info("%s doesn't support mount IDs\n", p);
                         continue;
                 }
                 if (IN_SET(r, -EACCES, -EPERM)) {
-                        log_debug("Can't access %s\n", p);
+                        log_info("Can't access %s\n", p);
                         continue;
                 }
 
-                log_debug("mnt id of %s is %i\n", p, mnt_id2);
+                log_info("mnt id of %s is %i\n", p, mnt_id2);
 
                 if (mnt_id == mnt_id2)
                         continue;
diff --git a/src/test/test-nss.c b/src/test/test-nss.c
index acfb6760a..34dad1a92 100644
--- a/src/test/test-nss.c
+++ b/src/test/test-nss.c
@@ -162,7 +162,7 @@ static void test_gethostbyname4_r(void *handle, const char *module, const char *
 
         fname = strjoina("_nss_", module, "_gethostbyname4_r");
         f = dlsym(handle, fname);
-        log_debug("dlsym(0x%p, %s) → 0x%p", handle, fname, f);
+        log_info("dlsym(0x%p, %s) → 0x%p", handle, fname, f);
         assert_se(f);
 
         status = f(name, &pat, buffer, sizeof buffer, &errno1, &errno2, &ttl);
@@ -213,7 +213,7 @@ static void test_gethostbyname3_r(void *handle, const char *module, const char *
 
         fname = strjoina("_nss_", module, "_gethostbyname3_r");
         f = dlsym(handle, fname);
-        log_debug("dlsym(0x%p, %s) → 0x%p", handle, fname, f);
+        log_info("dlsym(0x%p, %s) → 0x%p", handle, fname, f);
         assert_se(f);
 
         status = f(name, af, &host, buffer, sizeof buffer, &errno1, &errno2, &ttl, &canon);
@@ -239,7 +239,7 @@ static void test_gethostbyname2_r(void *handle, const char *module, const char *
 
         fname = strjoina("_nss_", module, "_gethostbyname2_r");
         f = dlsym(handle, fname);
-        log_debug("dlsym(0x%p, %s) → 0x%p", handle, fname, f);
+        log_info("dlsym(0x%p, %s) → 0x%p", handle, fname, f);
         assert_se(f);
 
         status = f(name, af, &host, buffer, sizeof buffer, &errno1, &errno2);
@@ -263,7 +263,7 @@ static void test_gethostbyname_r(void *handle, const char *module, const char *n
 
         fname = strjoina("_nss_", module, "_gethostbyname_r");
         f = dlsym(handle, fname);
-        log_debug("dlsym(0x%p, %s) → 0x%p", handle, fname, f);
+        log_info("dlsym(0x%p, %s) → 0x%p", handle, fname, f);
         assert_se(f);
 
         status = f(name, &host, buffer, sizeof buffer, &errno1, &errno2);
diff --git a/src/test/test-socket-util.c b/src/test/test-socket-util.c
index d1ab7486e..7fd1f555b 100644
--- a/src/test/test-socket-util.c
+++ b/src/test/test-socket-util.c
@@ -403,7 +403,7 @@ static void test_nameinfo_pretty(void) {
 
         assert_se(asynchronous_job(connect_thread, &s) == 0);
 
-        log_debug("Accepting new connection on fd:%d", sfd);
+        log_info("Accepting new connection on fd:%d", sfd);
         cfd = accept4(sfd, &c.sa, &clen, SOCK_CLOEXEC);
         assert_se(cfd >= 0);
 
diff --git a/src/test/test-tmpfiles.c b/src/test/test-tmpfiles.c
index 8e57fe046..42c9d4a8e 100644
--- a/src/test/test-tmpfiles.c
+++ b/src/test/test-tmpfiles.c
@@ -50,7 +50,7 @@ int main(int argc, char** argv) {
         assert_se(asprintf(&cmd, "ls -l /proc/"PID_FMT"/fd/%d", getpid_cached(), fd) > 0);
         (void) system(cmd);
         assert_se(readlink_malloc(cmd + 6, &ans) >= 0);
-        log_debug("link1: %s", ans);
+        log_info("link1: %s", ans);
         assert_se(endswith(ans, " (deleted)"));
 
         fd2 = mkostemp_safe(pattern);
@@ -60,7 +60,7 @@ int main(int argc, char** argv) {
         assert_se(asprintf(&cmd2, "ls -l /proc/"PID_FMT"/fd/%d", getpid_cached(), fd2) > 0);
         (void) system(cmd2);
         assert_se(readlink_malloc(cmd2 + 6, &ans2) >= 0);
-        log_debug("link2: %s", ans2);
+        log_info("link2: %s", ans2);
         assert_se(endswith(ans2, " (deleted)"));
 
         pattern = strjoina(p, "/tmpfiles-test");
diff --git a/src/test/test-udev.c b/src/test/test-udev.c
index e765f716c..a1aebf6c6 100644
--- a/src/test/test-udev.c
+++ b/src/test/test-udev.c
@@ -89,7 +89,7 @@ int main(int argc, char *argv[]) {
         if (udev == NULL)
                 return EXIT_FAILURE;
 
-        log_debug("version %s", PACKAGE_VERSION);
+        log_info("version %s", PACKAGE_VERSION);
         mac_selinux_init();
 
         action = argv[1];
@@ -109,7 +109,7 @@ int main(int argc, char *argv[]) {
         strscpyl(syspath, sizeof(syspath), "/sys", devpath, NULL);
         dev = udev_device_new_from_synthetic_event(udev, syspath, action);
         if (dev == NULL) {
-                log_debug("unknown device '%s'", devpath);
+                log_info("unknown device '%s'", devpath);
                 goto out;
         }
 
diff --git a/src/timedate/timedated.c b/src/timedate/timedated.c
index 822835cce..c5b2ae671 100644
--- a/src/timedate/timedated.c
+++ b/src/timedate/timedated.c
@@ -316,7 +316,7 @@ static int property_get_rtc_time(
                 log_warning("/dev/rtc is busy. Is somebody keeping it open continuously? That's not a good idea... Returning a bogus RTC timestamp.");
                 t = 0;
         } else if (r == -ENOENT) {
-                log_debug("/dev/rtc not found.");
+                log_info("/dev/rtc not found.");
                 t = 0; /* no RTC found */
         } else if (r < 0)
                 return sd_bus_error_set_errnof(error, r, "Failed to read RTC: %m");
diff --git a/src/timesync/timesyncd-manager.c b/src/timesync/timesyncd-manager.c
index a6d336c46..4604ef2db 100644
--- a/src/timesync/timesyncd-manager.c
+++ b/src/timesync/timesyncd-manager.c
@@ -190,9 +190,9 @@ static int manager_send_request(Manager *m) {
         len = sendto(m->server_socket, &ntpmsg, sizeof(ntpmsg), MSG_DONTWAIT, &m->current_server_address->sockaddr.sa, m->current_server_address->socklen);
         if (len == sizeof(ntpmsg)) {
                 m->pending = true;
-                log_debug("Sent NTP request to %s (%s).", strna(pretty), m->current_server_name->string);
+                log_info("Sent NTP request to %s (%s).", strna(pretty), m->current_server_name->string);
         } else {
-                log_debug_errno(errno, "Sending NTP request to %s (%s) failed: %m", strna(pretty), m->current_server_name->string);
+                log_info_errno(errno, "Sending NTP request to %s (%s) failed: %m", strna(pretty), m->current_server_name->string);
                 return manager_connect(m);
         }
 
@@ -271,7 +271,7 @@ static int manager_clock_watch(sd_event_source *source, int fd, uint32_t revents
         }
 
         /* resync */
-        log_debug("System time changed. Resyncing.");
+        log_info("System time changed. Resyncing.");
         m->poll_resync = true;
 
         return manager_send_request(m);
@@ -322,7 +322,7 @@ static int manager_adjust_clock(Manager *m, double offset, int leap_sec) {
                 tmx.constant = log2i(m->poll_interval_usec / USEC_PER_SEC) - 4;
                 tmx.maxerror = 0;
                 tmx.esterror = 0;
-                log_debug("  adjust (slew): %+.3f sec", offset);
+                log_info("  adjust (slew): %+.3f sec", offset);
         } else {
                 tmx.modes = ADJ_STATUS | ADJ_NANO | ADJ_SETOFFSET | ADJ_MAXERROR | ADJ_ESTERROR;
 
@@ -339,7 +339,7 @@ static int manager_adjust_clock(Manager *m, double offset, int leap_sec) {
                 }
 
                 m->jumped = true;
-                log_debug("  adjust (jump): %+.3f sec", offset);
+                log_info("  adjust (jump): %+.3f sec", offset);
         }
 
         /*
@@ -371,7 +371,7 @@ static int manager_adjust_clock(Manager *m, double offset, int leap_sec) {
 
         m->drift_ppm = tmx.freq / 65536;
 
-        log_debug("  status       : %04i %s\n"
+        log_info("  status       : %04i %s\n"
                   "  time now     : %"PRI_TIME".%03"PRI_USEC"\n"
                   "  constant     : %"PRI_TIMEX"\n"
                   "  offset       : %+.3f sec\n"
@@ -523,7 +523,7 @@ static int manager_receive_response(sd_event_source *source, int fd, uint32_t re
         if (!m->current_server_name ||
             !m->current_server_address ||
             !sockaddr_equal(&server_addr, &m->current_server_address->sockaddr)) {
-                log_debug("Response from unknown server.");
+                log_info("Response from unknown server.");
                 return 0;
         }
 
@@ -544,7 +544,7 @@ static int manager_receive_response(sd_event_source *source, int fd, uint32_t re
         }
 
         if (!m->pending) {
-                log_debug("Unexpected reply. Ignoring.");
+                log_info("Unexpected reply. Ignoring.");
                 return 0;
         }
 
@@ -553,7 +553,7 @@ static int manager_receive_response(sd_event_source *source, int fd, uint32_t re
         /* check our "time cookie" (we just stored nanoseconds in the fraction field) */
         if (be32toh(ntpmsg.origin_time.sec) != m->trans_time.tv_sec + OFFSET_1900_1970 ||
             be32toh(ntpmsg.origin_time.frac) != (unsigned long) m->trans_time.tv_nsec) {
-                log_debug("Invalid reply; not our transmit time. Ignoring.");
+                log_info("Invalid reply; not our transmit time. Ignoring.");
                 return 0;
         }
 
@@ -561,29 +561,29 @@ static int manager_receive_response(sd_event_source *source, int fd, uint32_t re
 
         if (be32toh(ntpmsg.recv_time.sec) < TIME_EPOCH + OFFSET_1900_1970 ||
             be32toh(ntpmsg.trans_time.sec) < TIME_EPOCH + OFFSET_1900_1970) {
-                log_debug("Invalid reply, returned times before epoch. Ignoring.");
+                log_info("Invalid reply, returned times before epoch. Ignoring.");
                 return manager_connect(m);
         }
 
         if (NTP_FIELD_LEAP(ntpmsg.field) == NTP_LEAP_NOTINSYNC ||
             ntpmsg.stratum == 0 || ntpmsg.stratum >= 16) {
-                log_debug("Server is not synchronized. Disconnecting.");
+                log_info("Server is not synchronized. Disconnecting.");
                 return manager_connect(m);
         }
 
         if (!IN_SET(NTP_FIELD_VERSION(ntpmsg.field), 3, 4)) {
-                log_debug("Response NTPv%d. Disconnecting.", NTP_FIELD_VERSION(ntpmsg.field));
+                log_info("Response NTPv%d. Disconnecting.", NTP_FIELD_VERSION(ntpmsg.field));
                 return manager_connect(m);
         }
 
         if (NTP_FIELD_MODE(ntpmsg.field) != NTP_MODE_SERVER) {
-                log_debug("Unsupported mode %d. Disconnecting.", NTP_FIELD_MODE(ntpmsg.field));
+                log_info("Unsupported mode %d. Disconnecting.", NTP_FIELD_MODE(ntpmsg.field));
                 return manager_connect(m);
         }
 
         root_distance = ntp_ts_short_to_d(&ntpmsg.root_delay) / 2 + ntp_ts_short_to_d(&ntpmsg.root_dispersion);
         if (root_distance > (double) m->max_root_distance_usec / (double) USEC_PER_SEC) {
-                log_debug("Server has too large root distance. Disconnecting.");
+                log_info("Server has too large root distance. Disconnecting.");
                 return manager_connect(m);
         }
 
@@ -625,7 +625,7 @@ static int manager_receive_response(sd_event_source *source, int fd, uint32_t re
 
         manager_adjust_poll(m, offset, spike);
 
-        log_debug("NTP response:\n"
+        log_info("NTP response:\n"
                   "  leap         : %u\n"
                   "  version      : %u\n"
                   "  mode         : %u\n"
@@ -665,7 +665,7 @@ static int manager_receive_response(sd_event_source *source, int fd, uint32_t re
                         log_error_errno(r, "Failed to call clock_adjtime(): %m");
         }
 
-        log_debug("interval/delta/delay/jitter/drift " USEC_FMT "s/%+.3fs/%.3fs/%.3fs/%+ippm%s",
+        log_info("interval/delta/delay/jitter/drift " USEC_FMT "s/%+.3fs/%.3fs/%.3fs/%+ippm%s",
                   m->poll_interval_usec / USEC_PER_SEC, offset, delay, m->samples_jitter, m->drift_ppm,
                   spike ? " (ignored)" : "");
 
@@ -740,7 +740,7 @@ static int manager_begin(Manager *m) {
                 m->poll_interval_usec = m->poll_interval_min_usec;
 
         server_address_pretty(m->current_server_address, &pretty);
-        log_debug("Connecting to time server %s (%s).", strna(pretty), m->current_server_name->string);
+        log_info("Connecting to time server %s (%s).", strna(pretty), m->current_server_name->string);
         sd_notifyf(false, "STATUS=Connecting to time server %s (%s).", strna(pretty), m->current_server_name->string);
 
         r = manager_clock_watch_setup(m);
@@ -762,7 +762,7 @@ void manager_set_server_name(Manager *m, ServerName *n) {
         manager_disconnect(m);
 
         if (n)
-                log_debug("Selected server %s.", n->string);
+                log_info("Selected server %s.", n->string);
 }
 
 void manager_set_server_address(Manager *m, ServerAddress *a) {
@@ -782,7 +782,7 @@ void manager_set_server_address(Manager *m, ServerAddress *a) {
         if (a) {
                 _cleanup_free_ char *pretty = NULL;
                 server_address_pretty(a, &pretty);
-                log_debug("Selected address %s of server %s.", strna(pretty), a->name->string);
+                log_info("Selected address %s of server %s.", strna(pretty), a->name->string);
         }
 }
 
@@ -797,7 +797,7 @@ static int manager_resolve_handler(sd_resolve_query *q, int ret, const struct ad
         m->resolve_query = sd_resolve_query_unref(m->resolve_query);
 
         if (ret != 0) {
-                log_debug("Failed to resolve %s: %s", m->current_server_name->string, gai_strerror(ret));
+                log_info("Failed to resolve %s: %s", m->current_server_name->string, gai_strerror(ret));
 
                 /* Try next host */
                 return manager_connect(m);
@@ -820,7 +820,7 @@ static int manager_resolve_handler(sd_resolve_query *q, int ret, const struct ad
                         return log_error_errno(r, "Failed to add server address: %m");
 
                 server_address_pretty(a, &pretty);
-                log_debug("Resolved address %s for %s.", pretty, m->current_server_name->string);
+                log_info("Resolved address %s for %s.", pretty, m->current_server_name->string);
         }
 
         if (!m->current_server_name->addresses) {
@@ -852,7 +852,7 @@ int manager_connect(Manager *m) {
 
         m->event_retry = sd_event_source_unref(m->event_retry);
         if (!ratelimit_test(&m->ratelimit)) {
-                log_debug("Slowing down attempts to contact servers.");
+                log_info("Slowing down attempts to contact servers.");
 
                 r = sd_event_add_time(m->event, &m->event_retry, clock_boottime_or_monotonic(), now(clock_boottime_or_monotonic()) + RETRY_USEC, 0, manager_retry_connect, m);
                 if (r < 0)
@@ -902,12 +902,12 @@ int manager_connect(Manager *m) {
 
                         if (!f) {
                                 manager_set_server_name(m, NULL);
-                                log_debug("No server found.");
+                                log_info("No server found.");
                                 return 0;
                         }
 
                         if (restart && !m->exhausted_servers && m->poll_interval_usec) {
-                                log_debug("Waiting after exhausting servers.");
+                                log_info("Waiting after exhausting servers.");
                                 r = sd_event_add_time(m->event, &m->event_retry, clock_boottime_or_monotonic(), now(clock_boottime_or_monotonic()) + m->poll_interval_usec, 0, manager_retry_connect, m);
                                 if (r < 0)
                                         return log_error_errno(r, "Failed to create retry timer: %m");
@@ -933,7 +933,7 @@ int manager_connect(Manager *m) {
                 /* Flush out any previously resolved addresses */
                 server_name_flush_addresses(m->current_server_name);
 
-                log_debug("Resolving %s...", m->current_server_name->string);
+                log_info("Resolving %s...", m->current_server_name->string);
 
                 r = sd_resolve_getaddrinfo(m->resolve, &m->resolve_query, m->current_server_name->string, "123", &hints, manager_resolve_handler, m);
                 if (r < 0)
diff --git a/src/timesync/timesyncd-server.c b/src/timesync/timesyncd-server.c
index bd0030b98..60e7ab1d4 100644
--- a/src/timesync/timesyncd-server.c
+++ b/src/timesync/timesyncd-server.c
@@ -106,7 +106,7 @@ int server_name_new(
             m->current_server_name->type == SERVER_FALLBACK)
                 manager_set_server_name(m, NULL);
 
-        log_debug("Added new server %s.", string);
+        log_info("Added new server %s.", string);
 
         if (ret)
                 *ret = n;
@@ -134,7 +134,7 @@ ServerName *server_name_free(ServerName *n) {
                         manager_set_server_name(n->manager, NULL);
         }
 
-        log_debug("Removed server %s.", n->string);
+        log_info("Removed server %s.", n->string);
 
         free(n->string);
         return mfree(n);
diff --git a/src/timesync/timesyncd.c b/src/timesync/timesyncd.c
index bea800171..32584f6ae 100644
--- a/src/timesync/timesyncd.c
+++ b/src/timesync/timesyncd.c
@@ -161,7 +161,7 @@ int main(int argc, char *argv[]) {
                 goto finish;
         }
 
-        log_debug("systemd-timesyncd running as pid " PID_FMT, getpid_cached());
+        log_info("systemd-timesyncd running as pid " PID_FMT, getpid_cached());
         sd_notify(false,
                   "READY=1\n"
                   "STATUS=Daemon is running");
diff --git a/src/tmpfiles/tmpfiles.c b/src/tmpfiles/tmpfiles.c
index 38cbb739c..0e2ac9f19 100644
--- a/src/tmpfiles/tmpfiles.c
+++ b/src/tmpfiles/tmpfiles.c
@@ -503,13 +503,13 @@ static DIR* xopendirat_nomod(int dirfd, const char *path) {
         if (dir)
                 return dir;
 
-        log_debug_errno(errno, "Cannot open %sdirectory \"%s\": %m", dirfd == AT_FDCWD ? "" : "sub", path);
+        log_info_errno(errno, "Cannot open %sdirectory \"%s\": %m", dirfd == AT_FDCWD ? "" : "sub", path);
         if (errno != EPERM)
                 return NULL;
 
         dir = xopendirat(dirfd, path, O_NOFOLLOW);
         if (!dir)
-                log_debug_errno(errno, "Cannot open %sdirectory \"%s\": %m", dirfd == AT_FDCWD ? "" : "sub", path);
+                log_info_errno(errno, "Cannot open %sdirectory \"%s\": %m", dirfd == AT_FDCWD ? "" : "sub", path);
 
         return dir;
 }
@@ -554,7 +554,7 @@ static int dir_cleanup(
 
                 /* Stay on the same filesystem */
                 if (s.st_dev != rootdev) {
-                        log_debug("Ignoring \"%s/%s\": different filesystem.", p, dent->d_name);
+                        log_info("Ignoring \"%s/%s\": different filesystem.", p, dent->d_name);
                         continue;
                 }
 
@@ -562,14 +562,14 @@ static int dir_cleanup(
                  * do not differ in device major/minors. This type of query is not
                  * supported on all kernels or filesystem types though. */
                 if (S_ISDIR(s.st_mode) && dir_is_mount_point(d, dent->d_name) > 0) {
-                        log_debug("Ignoring \"%s/%s\": different mount of the same filesystem.",
+                        log_info("Ignoring \"%s/%s\": different mount of the same filesystem.",
                                   p, dent->d_name);
                         continue;
                 }
 
                 /* Do not delete read-only files owned by root */
                 if (s.st_uid == 0 && !(s.st_mode & S_IWUSR)) {
-                        log_debug("Ignoring \"%s/%s\": read-only and owner by root.", p, dent->d_name);
+                        log_info("Ignoring \"%s/%s\": read-only and owner by root.", p, dent->d_name);
                         continue;
                 }
 
@@ -581,12 +581,12 @@ static int dir_cleanup(
 
                 /* Is there an item configured for this path? */
                 if (ordered_hashmap_get(items, sub_path)) {
-                        log_debug("Ignoring \"%s\": a separate entry exists.", sub_path);
+                        log_info("Ignoring \"%s\": a separate entry exists.", sub_path);
                         continue;
                 }
 
                 if (find_glob(globs, sub_path)) {
-                        log_debug("Ignoring \"%s\": a separate glob exists.", sub_path);
+                        log_info("Ignoring \"%s\": a separate glob exists.", sub_path);
                         continue;
                 }
 
@@ -595,7 +595,7 @@ static int dir_cleanup(
                         if (mountpoint &&
                             streq(dent->d_name, "lost+found") &&
                             s.st_uid == 0) {
-                                log_debug("Ignoring \"%s\".", sub_path);
+                                log_info("Ignoring \"%s\".", sub_path);
                                 continue;
                         }
 
@@ -626,7 +626,7 @@ static int dir_cleanup(
                          * so we don't want to overload that. */
 
                         if (keep_this_level) {
-                                log_debug("Keeping \"%s\".", sub_path);
+                                log_info("Keeping \"%s\".", sub_path);
                                 continue;
                         }
 
@@ -635,7 +635,7 @@ static int dir_cleanup(
                         if (age >= cutoff) {
                                 char a[FORMAT_TIMESTAMP_MAX];
                                 /* Follows spelling in stat(1). */
-                                log_debug("Directory \"%s\": modify time %s is too new.",
+                                log_info("Directory \"%s\": modify time %s is too new.",
                                           sub_path,
                                           format_timestamp_us(a, sizeof(a), age));
                                 continue;
@@ -644,13 +644,13 @@ static int dir_cleanup(
                         age = timespec_load(&s.st_atim);
                         if (age >= cutoff) {
                                 char a[FORMAT_TIMESTAMP_MAX];
-                                log_debug("Directory \"%s\": access time %s is too new.",
+                                log_info("Directory \"%s\": access time %s is too new.",
                                           sub_path,
                                           format_timestamp_us(a, sizeof(a), age));
                                 continue;
                         }
 
-                        log_debug("Removing directory \"%s\".", sub_path);
+                        log_info("Removing directory \"%s\".", sub_path);
                         if (unlinkat(dirfd(d), dent->d_name, AT_REMOVEDIR) < 0)
                                 if (!IN_SET(errno, ENOENT, ENOTEMPTY))
                                         r = log_error_errno(errno, "rmdir(%s): %m", sub_path);
@@ -661,7 +661,7 @@ static int dir_cleanup(
                          * unknown elsewhere. See XDG_RUNTIME_DIR
                          * specification for details. */
                         if (s.st_mode & S_ISVTX) {
-                                log_debug("Skipping \"%s\": sticky bit set.", sub_path);
+                                log_info("Skipping \"%s\": sticky bit set.", sub_path);
                                 continue;
                         }
 
@@ -670,26 +670,26 @@ static int dir_cleanup(
                                                                 ".journal",
                                                                 "aquota.user",
                                                                 "aquota.group")) {
-                                        log_debug("Skipping \"%s\".", sub_path);
+                                        log_info("Skipping \"%s\".", sub_path);
                                         continue;
                                 }
 
                         /* Ignore sockets that are listed in /proc/net/unix */
                         if (S_ISSOCK(s.st_mode) && unix_socket_alive(sub_path)) {
-                                log_debug("Skipping \"%s\": live socket.", sub_path);
+                                log_info("Skipping \"%s\": live socket.", sub_path);
                                 continue;
                         }
 
                         /* Ignore device nodes */
                         if (S_ISCHR(s.st_mode) || S_ISBLK(s.st_mode)) {
-                                log_debug("Skipping \"%s\": a device.", sub_path);
+                                log_info("Skipping \"%s\": a device.", sub_path);
                                 continue;
                         }
 
                         /* Keep files on this level around if this is
                          * requested */
                         if (keep_this_level) {
-                                log_debug("Keeping \"%s\".", sub_path);
+                                log_info("Keeping \"%s\".", sub_path);
                                 continue;
                         }
 
@@ -697,7 +697,7 @@ static int dir_cleanup(
                         if (age >= cutoff) {
                                 char a[FORMAT_TIMESTAMP_MAX];
                                 /* Follows spelling in stat(1). */
-                                log_debug("File \"%s\": modify time %s is too new.",
+                                log_info("File \"%s\": modify time %s is too new.",
                                           sub_path,
                                           format_timestamp_us(a, sizeof(a), age));
                                 continue;
@@ -706,7 +706,7 @@ static int dir_cleanup(
                         age = timespec_load(&s.st_atim);
                         if (age >= cutoff) {
                                 char a[FORMAT_TIMESTAMP_MAX];
-                                log_debug("File \"%s\": access time %s is too new.",
+                                log_info("File \"%s\": access time %s is too new.",
                                           sub_path,
                                           format_timestamp_us(a, sizeof(a), age));
                                 continue;
@@ -715,13 +715,13 @@ static int dir_cleanup(
                         age = timespec_load(&s.st_ctim);
                         if (age >= cutoff) {
                                 char a[FORMAT_TIMESTAMP_MAX];
-                                log_debug("File \"%s\": change time %s is too new.",
+                                log_info("File \"%s\": change time %s is too new.",
                                           sub_path,
                                           format_timestamp_us(a, sizeof(a), age));
                                 continue;
                         }
 
-                        log_debug("unlink \"%s\"", sub_path);
+                        log_info("unlink \"%s\"", sub_path);
 
                         if (unlinkat(dirfd(d), dent->d_name, 0) < 0)
                                 if (errno != ENOENT)
@@ -742,7 +742,7 @@ finish:
 
                 age1 = timespec_load(&ds->st_atim);
                 age2 = timespec_load(&ds->st_mtim);
-                log_debug("Restoring access and modification time on \"%s\": %s, %s",
+                log_info("Restoring access and modification time on \"%s\": %s, %s",
                           p,
                           format_timestamp_us(a, sizeof(a), age1),
                           format_timestamp_us(b, sizeof(b), age2));
@@ -766,13 +766,13 @@ static bool dangerous_hardlinks(void) {
 
         r = read_one_line_file("/proc/sys/fs/protected_hardlinks", &value);
         if (r < 0) {
-                log_debug_errno(r, "Failed to read fs.protected_hardlinks sysctl: %m");
+                log_info_errno(r, "Failed to read fs.protected_hardlinks sysctl: %m");
                 return true;
         }
 
         r = parse_boolean(value);
         if (r < 0) {
-                log_debug_errno(r, "Failed to parse fs.protected_hardlinks sysctl: %m");
+                log_info_errno(r, "Failed to parse fs.protected_hardlinks sysctl: %m");
                 return true;
         }
 
@@ -829,7 +829,7 @@ static int path_set_perms(Item *i, const char *path) {
 
         if (i->mode_set) {
                 if (S_ISLNK(st.st_mode))
-                        log_debug("Skipping mode fix for symlink %s.", path);
+                        log_info("Skipping mode fix for symlink %s.", path);
                 else {
                         mode_t m = i->mode;
 
@@ -845,9 +845,9 @@ static int path_set_perms(Item *i, const char *path) {
                         }
 
                         if (m == (st.st_mode & 07777))
-                                log_debug("\"%s\" has correct mode %o already.", path, st.st_mode);
+                                log_info("\"%s\" has correct mode %o already.", path, st.st_mode);
                         else {
-                                log_debug("Changing \"%s\" to mode %o.", path, m);
+                                log_info("Changing \"%s\" to mode %o.", path, m);
 
                                 if (chmod(fn, m) < 0)
                                         return log_error_errno(errno, "chmod() of %s via %s failed: %m", path, fn);
@@ -857,7 +857,7 @@ static int path_set_perms(Item *i, const char *path) {
 
         if ((i->uid_set && i->uid != st.st_uid) ||
             (i->gid_set && i->gid != st.st_gid)) {
-                log_debug("Changing \"%s\" to owner "UID_FMT":"GID_FMT,
+                log_info("Changing \"%s\" to owner "UID_FMT":"GID_FMT,
                           path,
                           i->uid_set ? i->uid : UID_INVALID,
                           i->gid_set ? i->gid : GID_INVALID);
@@ -919,7 +919,7 @@ static int path_set_xattrs(Item *i, const char *path) {
         assert(path);
 
         STRV_FOREACH_PAIR(name, value, i->xattrs) {
-                log_debug("Setting extended attribute '%s=%s' on %s.", *name, *value, path);
+                log_info("Setting extended attribute '%s=%s' on %s.", *name, *value, path);
                 if (lsetxattr(path, *name, *value, strlen(*value), 0) < 0)
                         return log_error_errno(errno, "Setting extended attribute %s=%s on %s failed: %m",
                                                *name, *value, path);
@@ -976,7 +976,7 @@ static int path_set_acl(const char *path, const char *pretty, acl_type_t type, a
                 return r;
 
         t = acl_to_any_text(dup, NULL, ',', TEXT_ABBREVIATE);
-        log_debug("Setting %s ACL %s on %s.",
+        log_info("Setting %s ACL %s on %s.",
                   type == ACL_TYPE_ACCESS ? "access" : "default",
                   strna(t), pretty);
 
@@ -1015,7 +1015,7 @@ static int path_set_acls(Item *item, const char *path) {
         }
 
         if (S_ISLNK(st.st_mode)) {
-                log_debug("Skipping ACL fix for symlink %s.", path);
+                log_info("Skipping ACL fix for symlink %s.", path);
                 return 0;
         }
 
@@ -1030,7 +1030,7 @@ static int path_set_acls(Item *item, const char *path) {
         if (r > 0)
                 return -r; /* already warned */
         else if (r == -EOPNOTSUPP) {
-                log_debug_errno(r, "ACLs not supported by file system at %s", path);
+                log_info_errno(r, "ACLs not supported by file system at %s", path);
                 return 0;
         } else if (r < 0)
                 log_error_errno(r, "ACL operation on \"%s\" failed: %m", path);
@@ -1200,11 +1200,11 @@ static int write_one_file(Item *i, const char *path) {
 
         if (fd < 0) {
                 if (i->type == WRITE_FILE && errno == ENOENT) {
-                        log_debug_errno(errno, "Not writing missing file \"%s\": %m", path);
+                        log_info_errno(errno, "Not writing missing file \"%s\": %m", path);
                         return 0;
                 }
                 if (i->type == CREATE_FILE && errno == EEXIST) {
-                        log_debug_errno(errno, "Not writing to pre-existing file \"%s\": %m", path);
+                        log_info_errno(errno, "Not writing to pre-existing file \"%s\": %m", path);
                         goto done;
                 }
 
@@ -1217,13 +1217,13 @@ static int write_one_file(Item *i, const char *path) {
         }
 
         if (i->argument) {
-                log_debug("%s to \"%s\".", i->type == CREATE_FILE ? "Appending" : "Writing", path);
+                log_info("%s to \"%s\".", i->type == CREATE_FILE ? "Appending" : "Writing", path);
 
                 r = loop_write(fd, i->argument, strlen(i->argument), false);
                 if (r < 0)
                         return log_error_errno(r, "Failed to write file \"%s\": %m", path);
         } else
-                log_debug("\"%s\" has been created.", path);
+                log_info("\"%s\" has been created.", path);
 
         fd = safe_close(fd);
 
@@ -1336,7 +1336,7 @@ static int create_item(Item *i) {
 
         assert(i);
 
-        log_debug("Running create action for entry %c %s", (char) i->type, i->path);
+        log_info("Running create action for entry %c %s", (char) i->type, i->path);
 
         switch (i->type) {
 
@@ -1361,7 +1361,7 @@ static int create_item(Item *i) {
                 RUN_WITH_UMASK(0000)
                         (void) mkdir_parents_label(i->path, 0755);
 
-                log_debug("Copying tree \"%s\" to \"%s\".", i->argument, i->path);
+                log_info("Copying tree \"%s\" to \"%s\".", i->argument, i->path);
                 r = copy_tree(i->argument, i->path,
                               i->uid_set ? i->uid : UID_INVALID,
                               i->gid_set ? i->gid : GID_INVALID,
@@ -1383,7 +1383,7 @@ static int create_item(Item *i) {
                                 return log_error_errno(errno, "stat(%s) failed: %m", i->path);
 
                         if ((a.st_mode ^ b.st_mode) & S_IFMT) {
-                                log_debug("Can't copy to %s, file exists already and is of different type", i->path);
+                                log_info("Can't copy to %s, file exists already and is of different type", i->path);
                                 return 0;
                         }
                 }
@@ -1459,22 +1459,22 @@ static int create_item(Item *i) {
                 } else
                         creation = CREATION_NORMAL;
 
-                log_debug("%s directory \"%s\".", creation_mode_verb_to_string(creation), i->path);
+                log_info("%s directory \"%s\".", creation_mode_verb_to_string(creation), i->path);
 
                 if (IN_SET(i->type, CREATE_SUBVOLUME_NEW_QUOTA, CREATE_SUBVOLUME_INHERIT_QUOTA)) {
                         r = btrfs_subvol_auto_qgroup(i->path, 0, i->type == CREATE_SUBVOLUME_NEW_QUOTA);
                         if (r == -ENOTTY)
-                                log_debug_errno(r, "Couldn't adjust quota for subvolume \"%s\" (unsupported fs or dir not a subvolume): %m", i->path);
+                                log_info_errno(r, "Couldn't adjust quota for subvolume \"%s\" (unsupported fs or dir not a subvolume): %m", i->path);
                         else if (r == -EROFS)
-                                log_debug_errno(r, "Couldn't adjust quota for subvolume \"%s\" (fs is read-only).", i->path);
+                                log_info_errno(r, "Couldn't adjust quota for subvolume \"%s\" (fs is read-only).", i->path);
                         else if (r == -ENOPROTOOPT)
-                                log_debug_errno(r, "Couldn't adjust quota for subvolume \"%s\" (quota support is disabled).", i->path);
+                                log_info_errno(r, "Couldn't adjust quota for subvolume \"%s\" (quota support is disabled).", i->path);
                         else if (r < 0)
                                 q = log_error_errno(r, "Failed to adjust quota for subvolume \"%s\": %m", i->path);
                         else if (r > 0)
-                                log_debug("Adjusted quota for subvolume \"%s\".", i->path);
+                                log_info("Adjusted quota for subvolume \"%s\".", i->path);
                         else if (r == 0)
-                                log_debug("Quota for subvolume \"%s\" already in place, no change made.", i->path);
+                                log_info("Quota for subvolume \"%s\" already in place, no change made.", i->path);
                 }
 
                 _fallthrough_;
@@ -1523,7 +1523,7 @@ static int create_item(Item *i) {
                                 creation = CREATION_EXISTING;
                 } else
                         creation = CREATION_NORMAL;
-                log_debug("%s fifo \"%s\".", creation_mode_verb_to_string(creation), i->path);
+                log_info("%s fifo \"%s\".", creation_mode_verb_to_string(creation), i->path);
 
                 r = path_set_perms(i, i->path);
                 if (r < 0)
@@ -1568,7 +1568,7 @@ static int create_item(Item *i) {
 
                                         creation = CREATION_FORCE;
                                 } else {
-                                        log_debug("\"%s\" is not a symlink or does not point to the correct path.", i->path);
+                                        log_info("\"%s\" is not a symlink or does not point to the correct path.", i->path);
                                         return 0;
                                 }
                         } else
@@ -1576,7 +1576,7 @@ static int create_item(Item *i) {
                 } else
 
                         creation = CREATION_NORMAL;
-                log_debug("%s symlink \"%s\".", creation_mode_verb_to_string(creation), i->path);
+                log_info("%s symlink \"%s\".", creation_mode_verb_to_string(creation), i->path);
                 break;
         }
 
@@ -1590,7 +1590,7 @@ static int create_item(Item *i) {
                         that case to avoid noise, and we don't support
                         virtualized devices in containers anyway. */
 
-                        log_debug("We lack CAP_MKNOD, skipping creation of device node %s.", i->path);
+                        log_info("We lack CAP_MKNOD, skipping creation of device node %s.", i->path);
                         return 0;
                 }
 
@@ -1607,7 +1607,7 @@ static int create_item(Item *i) {
 
                 if (r < 0) {
                         if (errno == EPERM) {
-                                log_debug("We lack permissions, possibly because of cgroup configuration; "
+                                log_info("We lack permissions, possibly because of cgroup configuration; "
                                           "skipping creation of device node %s.", i->path);
                                 return 0;
                         }
@@ -1632,7 +1632,7 @@ static int create_item(Item *i) {
                                                 return log_error_errno(r, "Failed to create device node \"%s\": %m", i->path);
                                         creation = CREATION_FORCE;
                                 } else {
-                                        log_debug("%s is not a device node.", i->path);
+                                        log_info("%s is not a device node.", i->path);
                                         return 0;
                                 }
                         } else
@@ -1640,7 +1640,7 @@ static int create_item(Item *i) {
                 } else
                         creation = CREATION_NORMAL;
 
-                log_debug("%s %s device node \"%s\" %u:%u.",
+                log_info("%s %s device node \"%s\" %u:%u.",
                           creation_mode_verb_to_string(creation),
                           i->type == CREATE_BLOCK_DEVICE ? "block" : "char",
                           i->path, major(i->mode), minor(i->mode));
@@ -1722,7 +1722,7 @@ static int remove_item_instance(Item *i, const char *instance) {
         case RECURSIVE_REMOVE_PATH:
                 /* FIXME: we probably should use dir_cleanup() here
                  * instead of rm_rf() so that 'x' is honoured. */
-                log_debug("rm -rf \"%s\"", instance);
+                log_info("rm -rf \"%s\"", instance);
                 r = rm_rf(instance, (i->type == RECURSIVE_REMOVE_PATH ? REMOVE_ROOT|REMOVE_SUBVOLUME : 0) | REMOVE_PHYSICAL);
                 if (r < 0 && r != -ENOENT)
                         return log_error_errno(r, "rm_rf(%s): %m", instance);
@@ -1739,7 +1739,7 @@ static int remove_item_instance(Item *i, const char *instance) {
 static int remove_item(Item *i) {
         assert(i);
 
-        log_debug("Running remove action for entry %c %s", (char) i->type, i->path);
+        log_info("Running remove action for entry %c %s", (char) i->type, i->path);
 
         switch (i->type) {
 
@@ -1774,7 +1774,7 @@ static int clean_item_instance(Item *i, const char* instance) {
         d = opendir_nomod(instance);
         if (!d) {
                 if (IN_SET(errno, ENOENT, ENOTDIR)) {
-                        log_debug_errno(errno, "Directory \"%s\": %m", instance);
+                        log_info_errno(errno, "Directory \"%s\": %m", instance);
                         return 0;
                 }
 
@@ -1794,7 +1794,7 @@ static int clean_item_instance(Item *i, const char* instance) {
 
         mountpoint = s.st_dev != ps.st_dev || s.st_ino == ps.st_ino;
 
-        log_debug("Cleanup threshold for %s \"%s\" is %s",
+        log_info("Cleanup threshold for %s \"%s\" is %s",
                   mountpoint ? "mount point" : "directory",
                   instance,
                   format_timestamp_us(timestamp, sizeof(timestamp), cutoff));
@@ -1806,7 +1806,7 @@ static int clean_item_instance(Item *i, const char* instance) {
 static int clean_item(Item *i) {
         assert(i);
 
-        log_debug("Running clean action for entry %c %s", (char) i->type, i->path);
+        log_info("Running clean action for entry %c %s", (char) i->type, i->path);
 
         switch (i->type) {
         case CREATE_DIRECTORY:
@@ -1957,14 +1957,14 @@ static bool should_include_path(const char *path) {
 
         STRV_FOREACH(prefix, arg_exclude_prefixes)
                 if (path_startswith(path, *prefix)) {
-                        log_debug("Entry \"%s\" matches exclude prefix \"%s\", skipping.",
+                        log_info("Entry \"%s\" matches exclude prefix \"%s\", skipping.",
                                   path, *prefix);
                         return false;
                 }
 
         STRV_FOREACH(prefix, arg_include_prefixes)
                 if (path_startswith(path, *prefix)) {
-                        log_debug("Entry \"%s\" matches include prefix \"%s\".", path, *prefix);
+                        log_info("Entry \"%s\" matches include prefix \"%s\".", path, *prefix);
                         return true;
                 }
 
@@ -1973,7 +1973,7 @@ static bool should_include_path(const char *path) {
         if (strv_isempty(arg_include_prefixes))
                 return true;
 
-        log_debug("Entry \"%s\" does not match any include prefix, skipping.", path);
+        log_info("Entry \"%s\" does not match any include prefix, skipping.", path);
         return false;
 }
 
@@ -2086,7 +2086,7 @@ static int parse_line(const char *fname, unsigned line, const char *buffer, bool
         }
 
         if (boot && !arg_boot) {
-                log_debug("Ignoring entry %s \"%s\" because --boot is not specified.",
+                log_info("Ignoring entry %s \"%s\" because --boot is not specified.",
                           action, path);
                 return 0;
         }
@@ -2474,20 +2474,20 @@ static int read_config_file(const char **config_dirs, const char *fn, bool ignor
         assert(fn);
 
         if (streq(fn, "-")) {
-                log_debug("Reading config from stdin.");
+                log_info("Reading config from stdin.");
                 fn = "<stdin>";
                 f = stdin;
         } else {
                 r = search_and_fopen(fn, "re", arg_root, config_dirs, &_f);
                 if (r < 0) {
                         if (ignore_enoent && r == -ENOENT) {
-                                log_debug_errno(r, "Failed to open \"%s\", ignoring: %m", fn);
+                                log_info_errno(r, "Failed to open \"%s\", ignoring: %m", fn);
                                 return 0;
                         }
 
                         return log_error_errno(r, "Failed to open '%s': %m", fn);
                 }
-                log_debug("Reading config file \"%s\".", fn);
+                log_info("Reading config file \"%s\".", fn);
                 f = _f;
         }
 
@@ -2599,7 +2599,7 @@ int main(int argc, char *argv[]) {
 
                 t = strv_join(config_dirs, "\n\t");
                 if (t)
-                        log_debug("Looking for configuration files in (higher priority first:\n\t%s", t);
+                        log_info("Looking for configuration files in (higher priority first:\n\t%s", t);
         }
 
         if (optind < argc) {
diff --git a/src/tty-ask-password-agent/tty-ask-password-agent.c b/src/tty-ask-password-agent/tty-ask-password-agent.c
index 9dfb0d80d..b43ce0b81 100644
--- a/src/tty-ask-password-agent/tty-ask-password-agent.c
+++ b/src/tty-ask-password-agent/tty-ask-password-agent.c
@@ -273,7 +273,7 @@ static int send_passwords(const char *socket_name, char **passwords) {
 
         socket_fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0);
         if (socket_fd < 0) {
-                r = log_debug_errno(errno, "socket(): %m");
+                r = log_info_errno(errno, "socket(): %m");
                 goto finish;
         }
 
@@ -281,7 +281,7 @@ static int send_passwords(const char *socket_name, char **passwords) {
 
         r = sendto(socket_fd, packet, packet_length, MSG_NOSIGNAL, &sa.sa, SOCKADDR_UN_LEN(sa.un));
         if (r < 0)
-                r = log_debug_errno(errno, "sendto(): %m");
+                r = log_info_errno(errno, "sendto(): %m");
 
 finish:
         explicit_bzero(packet, packet_length);
@@ -422,7 +422,7 @@ static int wall_tty_block(void) {
 
         fd = open(p, O_RDONLY|O_CLOEXEC|O_NONBLOCK|O_NOCTTY);
         if (fd < 0)
-                return log_debug_errno(errno, "Failed to open %s: %m", p);
+                return log_info_errno(errno, "Failed to open %s: %m", p);
 
         return fd;
 }
@@ -436,12 +436,12 @@ static bool wall_tty_match(const char *path, void *userdata) {
                 path = strjoina("/dev/", path);
 
         if (lstat(path, &st) < 0) {
-                log_debug_errno(errno, "Failed to stat %s: %m", path);
+                log_info_errno(errno, "Failed to stat %s: %m", path);
                 return true;
         }
 
         if (!S_ISCHR(st.st_mode)) {
-                log_debug("%s is not a character device.", path);
+                log_info("%s is not a character device.", path);
                 return true;
         }
 
@@ -460,7 +460,7 @@ static bool wall_tty_match(const char *path, void *userdata) {
 
         fd = open(p, O_WRONLY|O_CLOEXEC|O_NONBLOCK|O_NOCTTY);
         if (fd < 0) {
-                log_debug_errno(errno, "Failed top open the wall pipe: %m");
+                log_info_errno(errno, "Failed top open the wall pipe: %m");
                 return 1;
         }
 
diff --git a/src/udev/ata_id/ata_id.c b/src/udev/ata_id/ata_id.c
index 7e3654c30..9c9d0fda9 100644
--- a/src/udev/ata_id/ata_id.c
+++ b/src/udev/ata_id/ata_id.c
@@ -499,7 +499,7 @@ int main(int argc, char *argv[])
         } else {
                 /* If this fails, then try HDIO_GET_IDENTITY */
                 if (ioctl(fd, HDIO_GET_IDENTITY, &id) != 0) {
-                        log_debug_errno(errno, "HDIO_GET_IDENTITY failed for '%s': %m", node);
+                        log_info_errno(errno, "HDIO_GET_IDENTITY failed for '%s': %m", node);
                         return 2;
                 }
         }
diff --git a/src/udev/cdrom_id/cdrom_id.c b/src/udev/cdrom_id/cdrom_id.c
index 9644861ad..789f289ff 100644
--- a/src/udev/cdrom_id/cdrom_id.c
+++ b/src/udev/cdrom_id/cdrom_id.c
@@ -127,10 +127,10 @@ static bool is_mounted(const char *device)
 static void info_scsi_cmd_err(struct udev *udev, const char *cmd, int err)
 {
         if (err == -1) {
-                log_debug("%s failed", cmd);
+                log_info("%s failed", cmd);
                 return;
         }
-        log_debug("%s failed with SK=%Xh/ASC=%02Xh/ACQ=%02Xh", cmd, SK(err), ASC(err), ASCQ(err));
+        log_info("%s failed with SK=%Xh/ASC=%02Xh/ACQ=%02Xh", cmd, SK(err), ASC(err), ASCQ(err));
 }
 
 struct scsi_cmd {
@@ -195,11 +195,11 @@ static int media_lock(struct udev *udev, int fd, bool lock)
         /* disable the kernel's lock logic */
         err = ioctl(fd, CDROM_CLEAR_OPTIONS, CDO_LOCK);
         if (err < 0)
-                log_debug("CDROM_CLEAR_OPTIONS, CDO_LOCK failed");
+                log_info("CDROM_CLEAR_OPTIONS, CDO_LOCK failed");
 
         err = ioctl(fd, CDROM_LOCKDOOR, lock ? 1 : 0);
         if (err < 0)
-                log_debug("CDROM_LOCKDOOR failed");
+                log_info("CDROM_LOCKDOOR failed");
 
         return err;
 }
@@ -227,7 +227,7 @@ static int cd_capability_compat(struct udev *udev, int fd)
 
         capability = ioctl(fd, CDROM_GET_CAPABILITY, NULL);
         if (capability < 0) {
-                log_debug("CDROM_GET_CAPABILITY failed");
+                log_info("CDROM_GET_CAPABILITY failed");
                 return -1;
         }
 
@@ -251,7 +251,7 @@ static int cd_capability_compat(struct udev *udev, int fd)
 static int cd_media_compat(struct udev *udev, int fd)
 {
         if (ioctl(fd, CDROM_DRIVE_STATUS, CDSL_CURRENT) != CDS_DISC_OK) {
-                log_debug("CDROM_DRIVE_STATUS != CDS_DISC_OK");
+                log_info("CDROM_DRIVE_STATUS != CDS_DISC_OK");
                 return -1;
         }
         cd_media = 1;
@@ -275,11 +275,11 @@ static int cd_inquiry(struct udev *udev, int fd)
         }
 
         if ((inq[0] & 0x1F) != 5) {
-                log_debug("not an MMC unit");
+                log_info("not an MMC unit");
                 return -1;
         }
 
-        log_debug("INQUIRY: [%.8s][%.16s][%.4s]", inq + 8, inq + 16, inq + 32);
+        log_info("INQUIRY: [%.8s][%.16s][%.4s]", inq + 8, inq + 16, inq + 32);
         return 0;
 }
 
@@ -289,105 +289,105 @@ static void feature_profile_media(struct udev *udev, int cur_profile)
         case 0x03:
         case 0x04:
         case 0x05:
-                log_debug("profile 0x%02x ", cur_profile);
+                log_info("profile 0x%02x ", cur_profile);
                 cd_media = 1;
                 cd_media_mo = 1;
                 break;
         case 0x08:
-                log_debug("profile 0x%02x media_cd_rom", cur_profile);
+                log_info("profile 0x%02x media_cd_rom", cur_profile);
                 cd_media = 1;
                 cd_media_cd_rom = 1;
                 break;
         case 0x09:
-                log_debug("profile 0x%02x media_cd_r", cur_profile);
+                log_info("profile 0x%02x media_cd_r", cur_profile);
                 cd_media = 1;
                 cd_media_cd_r = 1;
                 break;
         case 0x0a:
-                log_debug("profile 0x%02x media_cd_rw", cur_profile);
+                log_info("profile 0x%02x media_cd_rw", cur_profile);
                 cd_media = 1;
                 cd_media_cd_rw = 1;
                 break;
         case 0x10:
-                log_debug("profile 0x%02x media_dvd_ro", cur_profile);
+                log_info("profile 0x%02x media_dvd_ro", cur_profile);
                 cd_media = 1;
                 cd_media_dvd_rom = 1;
                 break;
         case 0x11:
-                log_debug("profile 0x%02x media_dvd_r", cur_profile);
+                log_info("profile 0x%02x media_dvd_r", cur_profile);
                 cd_media = 1;
                 cd_media_dvd_r = 1;
                 break;
         case 0x12:
-                log_debug("profile 0x%02x media_dvd_ram", cur_profile);
+                log_info("profile 0x%02x media_dvd_ram", cur_profile);
                 cd_media = 1;
                 cd_media_dvd_ram = 1;
                 break;
         case 0x13:
-                log_debug("profile 0x%02x media_dvd_rw_ro", cur_profile);
+                log_info("profile 0x%02x media_dvd_rw_ro", cur_profile);
                 cd_media = 1;
                 cd_media_dvd_rw = 1;
                 cd_media_dvd_rw_ro = 1;
                 break;
         case 0x14:
-                log_debug("profile 0x%02x media_dvd_rw_seq", cur_profile);
+                log_info("profile 0x%02x media_dvd_rw_seq", cur_profile);
                 cd_media = 1;
                 cd_media_dvd_rw = 1;
                 cd_media_dvd_rw_seq = 1;
                 break;
         case 0x1B:
-                log_debug("profile 0x%02x media_dvd_plus_r", cur_profile);
+                log_info("profile 0x%02x media_dvd_plus_r", cur_profile);
                 cd_media = 1;
                 cd_media_dvd_plus_r = 1;
                 break;
         case 0x1A:
-                log_debug("profile 0x%02x media_dvd_plus_rw", cur_profile);
+                log_info("profile 0x%02x media_dvd_plus_rw", cur_profile);
                 cd_media = 1;
                 cd_media_dvd_plus_rw = 1;
                 break;
         case 0x2A:
-                log_debug("profile 0x%02x media_dvd_plus_rw_dl", cur_profile);
+                log_info("profile 0x%02x media_dvd_plus_rw_dl", cur_profile);
                 cd_media = 1;
                 cd_media_dvd_plus_rw_dl = 1;
                 break;
         case 0x2B:
-                log_debug("profile 0x%02x media_dvd_plus_r_dl", cur_profile);
+                log_info("profile 0x%02x media_dvd_plus_r_dl", cur_profile);
                 cd_media = 1;
                 cd_media_dvd_plus_r_dl = 1;
                 break;
         case 0x40:
-                log_debug("profile 0x%02x media_bd", cur_profile);
+                log_info("profile 0x%02x media_bd", cur_profile);
                 cd_media = 1;
                 cd_media_bd = 1;
                 break;
         case 0x41:
         case 0x42:
-                log_debug("profile 0x%02x media_bd_r", cur_profile);
+                log_info("profile 0x%02x media_bd_r", cur_profile);
                 cd_media = 1;
                 cd_media_bd_r = 1;
                 break;
         case 0x43:
-                log_debug("profile 0x%02x media_bd_re", cur_profile);
+                log_info("profile 0x%02x media_bd_re", cur_profile);
                 cd_media = 1;
                 cd_media_bd_re = 1;
                 break;
         case 0x50:
-                log_debug("profile 0x%02x media_hddvd", cur_profile);
+                log_info("profile 0x%02x media_hddvd", cur_profile);
                 cd_media = 1;
                 cd_media_hddvd = 1;
                 break;
         case 0x51:
-                log_debug("profile 0x%02x media_hddvd_r", cur_profile);
+                log_info("profile 0x%02x media_hddvd_r", cur_profile);
                 cd_media = 1;
                 cd_media_hddvd_r = 1;
                 break;
         case 0x52:
-                log_debug("profile 0x%02x media_hddvd_rw", cur_profile);
+                log_info("profile 0x%02x media_hddvd_rw", cur_profile);
                 cd_media = 1;
                 cd_media_hddvd_rw = 1;
                 break;
         default:
-                log_debug("profile 0x%02x <ignored>", cur_profile);
+                log_info("profile 0x%02x <ignored>", cur_profile);
                 break;
         }
 }
@@ -404,77 +404,77 @@ static int feature_profiles(struct udev *udev, const unsigned char *profiles, si
                 case 0x03:
                 case 0x04:
                 case 0x05:
-                        log_debug("profile 0x%02x mo", profile);
+                        log_info("profile 0x%02x mo", profile);
                         cd_mo = 1;
                         break;
                 case 0x08:
-                        log_debug("profile 0x%02x cd_rom", profile);
+                        log_info("profile 0x%02x cd_rom", profile);
                         cd_cd_rom = 1;
                         break;
                 case 0x09:
-                        log_debug("profile 0x%02x cd_r", profile);
+                        log_info("profile 0x%02x cd_r", profile);
                         cd_cd_r = 1;
                         break;
                 case 0x0A:
-                        log_debug("profile 0x%02x cd_rw", profile);
+                        log_info("profile 0x%02x cd_rw", profile);
                         cd_cd_rw = 1;
                         break;
                 case 0x10:
-                        log_debug("profile 0x%02x dvd_rom", profile);
+                        log_info("profile 0x%02x dvd_rom", profile);
                         cd_dvd_rom = 1;
                         break;
                 case 0x12:
-                        log_debug("profile 0x%02x dvd_ram", profile);
+                        log_info("profile 0x%02x dvd_ram", profile);
                         cd_dvd_ram = 1;
                         break;
                 case 0x13:
                 case 0x14:
-                        log_debug("profile 0x%02x dvd_rw", profile);
+                        log_info("profile 0x%02x dvd_rw", profile);
                         cd_dvd_rw = 1;
                         break;
                 case 0x1B:
-                        log_debug("profile 0x%02x dvd_plus_r", profile);
+                        log_info("profile 0x%02x dvd_plus_r", profile);
                         cd_dvd_plus_r = 1;
                         break;
                 case 0x1A:
-                        log_debug("profile 0x%02x dvd_plus_rw", profile);
+                        log_info("profile 0x%02x dvd_plus_rw", profile);
                         cd_dvd_plus_rw = 1;
                         break;
                 case 0x2A:
-                        log_debug("profile 0x%02x dvd_plus_rw_dl", profile);
+                        log_info("profile 0x%02x dvd_plus_rw_dl", profile);
                         cd_dvd_plus_rw_dl = 1;
                         break;
                 case 0x2B:
-                        log_debug("profile 0x%02x dvd_plus_r_dl", profile);
+                        log_info("profile 0x%02x dvd_plus_r_dl", profile);
                         cd_dvd_plus_r_dl = 1;
                         break;
                 case 0x40:
                         cd_bd = 1;
-                        log_debug("profile 0x%02x bd", profile);
+                        log_info("profile 0x%02x bd", profile);
                         break;
                 case 0x41:
                 case 0x42:
                         cd_bd_r = 1;
-                        log_debug("profile 0x%02x bd_r", profile);
+                        log_info("profile 0x%02x bd_r", profile);
                         break;
                 case 0x43:
                         cd_bd_re = 1;
-                        log_debug("profile 0x%02x bd_re", profile);
+                        log_info("profile 0x%02x bd_re", profile);
                         break;
                 case 0x50:
                         cd_hddvd = 1;
-                        log_debug("profile 0x%02x hddvd", profile);
+                        log_info("profile 0x%02x hddvd", profile);
                         break;
                 case 0x51:
                         cd_hddvd_r = 1;
-                        log_debug("profile 0x%02x hddvd_r", profile);
+                        log_info("profile 0x%02x hddvd_r", profile);
                         break;
                 case 0x52:
                         cd_hddvd_rw = 1;
-                        log_debug("profile 0x%02x hddvd_rw", profile);
+                        log_info("profile 0x%02x hddvd_rw", profile);
                         break;
                 default:
-                        log_debug("profile 0x%02x <ignored>", profile);
+                        log_info("profile 0x%02x <ignored>", profile);
                         break;
                 }
         }
@@ -497,13 +497,13 @@ static int cd_profiles_old_mmc(struct udev *udev, int fd)
         if ((err != 0)) {
                 info_scsi_cmd_err(udev, "READ DISC INFORMATION", err);
                 if (cd_media == 1) {
-                        log_debug("no current profile, but disc is present; assuming CD-ROM");
+                        log_info("no current profile, but disc is present; assuming CD-ROM");
                         cd_media_cd_rom = 1;
                         cd_media_track_count = 1;
                         cd_media_track_count_data = 1;
                         return 0;
                 } else {
-                        log_debug("no current profile, assuming no media");
+                        log_info("no current profile, assuming no media");
                         return -1;
                 }
         };
@@ -512,13 +512,13 @@ static int cd_profiles_old_mmc(struct udev *udev, int fd)
 
         if (header[2] & 16) {
                 cd_media_cd_rw = 1;
-                log_debug("profile 0x0a media_cd_rw");
+                log_info("profile 0x0a media_cd_rw");
         } else if ((header[2] & 3) < 2 && cd_cd_r) {
                 cd_media_cd_r = 1;
-                log_debug("profile 0x09 media_cd_r");
+                log_info("profile 0x09 media_cd_r");
         } else {
                 cd_media_cd_rom = 1;
-                log_debug("profile 0x08 media_cd_rom");
+                log_info("profile 0x08 media_cd_rom");
         }
         return 0;
 }
@@ -546,8 +546,8 @@ static int cd_profiles(struct udev *udev, int fd)
                 info_scsi_cmd_err(udev, "GET CONFIGURATION", err);
                 /* handle pre-MMC2 drives which do not support GET CONFIGURATION */
                 if (SK(err) == 0x5 && IN_SET(ASC(err), 0x20, 0x24)) {
-                        log_debug("drive is pre-MMC2 and does not support 46h get configuration command");
-                        log_debug("trying to work around the problem");
+                        log_info("drive is pre-MMC2 and does not support 46h get configuration command");
+                        log_info("trying to work around the problem");
                         ret = cd_profiles_old_mmc(udev, fd);
                 }
                 goto out;
@@ -555,18 +555,18 @@ static int cd_profiles(struct udev *udev, int fd)
 
         cur_profile = features[6] << 8 | features[7];
         if (cur_profile > 0) {
-                log_debug("current profile 0x%02x", cur_profile);
+                log_info("current profile 0x%02x", cur_profile);
                 feature_profile_media (udev, cur_profile);
                 ret = 0; /* we have media */
         } else {
-                log_debug("no current profile, assuming no media");
+                log_info("no current profile, assuming no media");
         }
 
         len = features[0] << 24 | features[1] << 16 | features[2] << 8 | features[3];
-        log_debug("GET CONFIGURATION: size of features buffer 0x%04x", len);
+        log_info("GET CONFIGURATION: size of features buffer 0x%04x", len);
 
         if (len > sizeof(features)) {
-                log_debug("can not get features in a single query, truncating");
+                log_info("can not get features in a single query, truncating");
                 len = sizeof(features);
         } else if (len <= 8)
                 len = sizeof(features);
@@ -585,10 +585,10 @@ static int cd_profiles(struct udev *udev, int fd)
 
         /* parse the length once more, in case the drive decided to have other features suddenly :) */
         len = features[0] << 24 | features[1] << 16 | features[2] << 8 | features[3];
-        log_debug("GET CONFIGURATION: size of features buffer 0x%04x", len);
+        log_info("GET CONFIGURATION: size of features buffer 0x%04x", len);
 
         if (len > sizeof(features)) {
-                log_debug("can not get features in a single query, truncating");
+                log_info("can not get features in a single query, truncating");
                 len = sizeof(features);
         }
 
@@ -600,11 +600,11 @@ static int cd_profiles(struct udev *udev, int fd)
 
                 switch (feature) {
                 case 0x00:
-                        log_debug("GET CONFIGURATION: feature 'profiles', with %i entries", features[i+3] / 4);
+                        log_info("GET CONFIGURATION: feature 'profiles', with %i entries", features[i+3] / 4);
                         feature_profiles(udev, &features[i]+4, MIN(features[i+3], len - i - 4));
                         break;
                 default:
-                        log_debug("GET CONFIGURATION: feature 0x%04x <ignored>, with 0x%02x bytes", feature, features[i+3]);
+                        log_info("GET CONFIGURATION: feature 0x%04x <ignored>, with 0x%02x bytes", feature, features[i+3]);
                         break;
                 }
         }
@@ -635,8 +635,8 @@ static int cd_media_info(struct udev *udev, int fd)
         };
 
         cd_media = 1;
-        log_debug("disk type %02x", header[8]);
-        log_debug("hardware reported media status: %s", media_status[header[2] & 3]);
+        log_info("disk type %02x", header[8]);
+        log_info("hardware reported media status: %s", media_status[header[2] & 3]);
 
         /* exclude plain CDROM, some fake cdroms return 0 for "blank" media here */
         if (!cd_media_cd_rom)
@@ -674,7 +674,7 @@ static int cd_media_info(struct udev *udev, int fd)
                         }
                         if (dvdstruct[4] & 0x02) {
                                 cd_media_state = media_status[2];
-                                log_debug("write-protected DVD-RAM media inserted");
+                                log_info("write-protected DVD-RAM media inserted");
                                 goto determined;
                         }
 
@@ -691,13 +691,13 @@ static int cd_media_info(struct udev *udev, int fd)
 
                         len = format[3];
                         if (len & 7 || len < 16) {
-                                log_debug("invalid format capacities length");
+                                log_info("invalid format capacities length");
                                 return -1;
                         }
 
                         switch(format[8] & 3) {
                             case 1:
-                                log_debug("unformatted DVD-RAM media inserted");
+                                log_info("unformatted DVD-RAM media inserted");
                                 /* This means that last format was interrupted
                                  * or failed, blank dvd-ram discs are factory
                                  * formatted. Take no action here as it takes
@@ -706,12 +706,12 @@ static int cd_media_info(struct udev *udev, int fd)
                                 goto determined;
 
                             case 2:
-                                log_debug("formatted DVD-RAM media inserted");
+                                log_info("formatted DVD-RAM media inserted");
                                 break;
 
                             case 3:
                                 cd_media = 0; //return no media
-                                log_debug("format capacities returned no media");
+                                log_info("format capacities returned no media");
                                 return -1;
                         }
                 }
@@ -738,20 +738,20 @@ static int cd_media_info(struct udev *udev, int fd)
 
                 for (offset = 32768; offset < (32768 + 2048); offset++) {
                         if (buffer [offset]) {
-                                log_debug("data in block 16, assuming complete");
+                                log_info("data in block 16, assuming complete");
                                 goto determined;
                         }
                 }
 
                 for (offset = 0; offset < 2048; offset++) {
                         if (buffer [offset]) {
-                                log_debug("data in block 0, assuming complete");
+                                log_info("data in block 0, assuming complete");
                                 goto determined;
                         }
                 }
 
                 cd_media_state = media_status[0];
-                log_debug("no data in blocks 0 or 16, assuming blank");
+                log_info("no data in blocks 0 or 16, assuming blank");
         }
 
 determined:
@@ -786,7 +786,7 @@ static int cd_media_toc(struct udev *udev, int fd)
         }
 
         len = (header[0] << 8 | header[1]) + 2;
-        log_debug("READ TOC: len: %d, start track: %d, end track: %d", len, header[2], header[3]);
+        log_info("READ TOC: len: %d, start track: %d, end track: %d", len, header[2], header[3]);
         if (len > sizeof(toc))
                 return -1;
         if (len < 2)
@@ -820,7 +820,7 @@ static int cd_media_toc(struct udev *udev, int fd)
                 is_data_track = (p[1] & 0x04) != 0;
 
                 block = p[4] << 24 | p[5] << 16 | p[6] << 8 | p[7];
-                log_debug("track=%u info=0x%x(%s) start_block=%u",
+                log_info("track=%u info=0x%x(%s) start_block=%u",
                      p[2], p[1] & 0x0f, is_data_track ? "data":"audio", block);
 
                 if (is_data_track)
@@ -840,7 +840,7 @@ static int cd_media_toc(struct udev *udev, int fd)
                 return -1;
         }
         len = header[4+4] << 24 | header[4+5] << 16 | header[4+6] << 8 | header[4+7];
-        log_debug("last track %u starts at block %u", header[4+2], len);
+        log_info("last track %u starts at block %u", header[4+2], len);
         cd_media_session_last_offset = (unsigned long long int)len * 2048;
         return 0;
 }
@@ -928,12 +928,12 @@ int main(int argc, char *argv[]) {
                 nanosleep(&duration, NULL);
         }
         if (fd < 0) {
-                log_debug("unable to open '%s'", node);
+                log_info("unable to open '%s'", node);
                 fprintf(stderr, "unable to open '%s'\n", node);
                 rc = 1;
                 goto exit;
         }
-        log_debug("probing: '%s'", node);
+        log_info("probing: '%s'", node);
 
         /* same data as original cdrom_id */
         if (cd_capability_compat(udev, fd) < 0) {
@@ -964,19 +964,19 @@ int main(int argc, char *argv[]) {
 work:
         /* lock the media, so we enable eject button events */
         if (lock && cd_media) {
-                log_debug("PREVENT_ALLOW_MEDIUM_REMOVAL (lock)");
+                log_info("PREVENT_ALLOW_MEDIUM_REMOVAL (lock)");
                 media_lock(udev, fd, true);
         }
 
         if (unlock && cd_media) {
-                log_debug("PREVENT_ALLOW_MEDIUM_REMOVAL (unlock)");
+                log_info("PREVENT_ALLOW_MEDIUM_REMOVAL (unlock)");
                 media_lock(udev, fd, false);
         }
 
         if (eject) {
-                log_debug("PREVENT_ALLOW_MEDIUM_REMOVAL (unlock)");
+                log_info("PREVENT_ALLOW_MEDIUM_REMOVAL (unlock)");
                 media_lock(udev, fd, false);
-                log_debug("START_STOP_UNIT (eject)");
+                log_info("START_STOP_UNIT (eject)");
                 media_eject(udev, fd);
         }
 
diff --git a/src/udev/net/link-config.c b/src/udev/net/link-config.c
index a4368f088..5c6d85a1c 100644
--- a/src/udev/net/link-config.c
+++ b/src/udev/net/link-config.c
@@ -158,7 +158,7 @@ static int load_link(link_config_ctx *ctx, const char *filename) {
         }
 
         if (null_or_empty_fd(fileno(file))) {
-                log_debug("Skipping empty file: %s", filename);
+                log_info("Skipping empty file: %s", filename);
                 return 0;
         }
 
@@ -181,7 +181,7 @@ static int load_link(link_config_ctx *ctx, const char *filename) {
         if (r < 0)
                 return r;
         else
-                log_debug("Parsed configuration file %s", filename);
+                log_info("Parsed configuration file %s", filename);
 
         if (link->mtu > UINT_MAX || link->speed > UINT_MAX)
                 return -ERANGE;
@@ -278,7 +278,7 @@ int link_config_get(link_config_ctx *ctx, struct udev_device *device,
                                 }
                         }
 
-                        log_debug("Config file %s applies to device %s",
+                        log_info("Config file %s applies to device %s",
                                   link->filename,  udev_device_get_sysname(device));
 
                         *ret = link;
diff --git a/src/udev/scsi_id/scsi_serial.c b/src/udev/scsi_id/scsi_serial.c
index bf6b28e8e..eb49e28fb 100644
--- a/src/udev/scsi_id/scsi_serial.c
+++ b/src/udev/scsi_id/scsi_serial.c
@@ -196,7 +196,7 @@ static int scsi_dump_sense(struct udev *udev,
          */
 
         if (sb_len < 1) {
-                log_debug("%s: sense buffer empty", dev_scsi->kernel);
+                log_info("%s: sense buffer empty", dev_scsi->kernel);
                 return -1;
         }
 
@@ -209,7 +209,7 @@ static int scsi_dump_sense(struct udev *udev,
                  */
                 s = sense_buffer[7] + 8;
                 if (sb_len < s) {
-                        log_debug("%s: sense buffer too small %d bytes, %d bytes too short",
+                        log_info("%s: sense buffer too small %d bytes, %d bytes too short",
                                   dev_scsi->kernel, sb_len, s - sb_len);
                         return -1;
                 }
@@ -219,7 +219,7 @@ static int scsi_dump_sense(struct udev *udev,
                                 /*
                                  * Possible?
                                  */
-                                log_debug("%s: sense result too" " small %d bytes",
+                                log_info("%s: sense result too" " small %d bytes",
                                           dev_scsi->kernel, s);
                                 return -1;
                         }
@@ -230,25 +230,25 @@ static int scsi_dump_sense(struct udev *udev,
                         asc = sense_buffer[2];
                         ascq = sense_buffer[3];
                 } else {
-                        log_debug("%s: invalid sense code 0x%x",
+                        log_info("%s: invalid sense code 0x%x",
                                   dev_scsi->kernel, code);
                         return -1;
                 }
-                log_debug("%s: sense key 0x%x ASC 0x%x ASCQ 0x%x",
+                log_info("%s: sense key 0x%x ASC 0x%x ASCQ 0x%x",
                           dev_scsi->kernel, sense_key, asc, ascq);
         } else {
                 if (sb_len < 4) {
-                        log_debug("%s: sense buffer too small %d bytes, %d bytes too short",
+                        log_info("%s: sense buffer too small %d bytes, %d bytes too short",
                                   dev_scsi->kernel, sb_len, 4 - sb_len);
                         return -1;
                 }
 
                 if (sense_buffer[0] < 15)
-                        log_debug("%s: old sense key: 0x%x", dev_scsi->kernel, sense_buffer[0] & 0x0f);
+                        log_info("%s: old sense key: 0x%x", dev_scsi->kernel, sense_buffer[0] & 0x0f);
                 else
-                        log_debug("%s: sense = %2x %2x",
+                        log_info("%s: sense = %2x %2x",
                                   dev_scsi->kernel, sense_buffer[0], sense_buffer[2]);
-                log_debug("%s: non-extended sense class %d code 0x%0x",
+                log_info("%s: non-extended sense class %d code 0x%0x",
                           dev_scsi->kernel, sense_class, code);
 
         }
@@ -260,8 +260,8 @@ static int scsi_dump_sense(struct udev *udev,
                 out_buffer[j++] = ' ';
         }
         out_buffer[j] = '\0';
-        log_debug("%s: sense dump:", dev_scsi->kernel);
-        log_debug("%s: %s", dev_scsi->kernel, out_buffer);
+        log_info("%s: sense dump:", dev_scsi->kernel);
+        log_info("%s: %s", dev_scsi->kernel, out_buffer);
 
 #endif
         return -1;
@@ -275,11 +275,11 @@ static int scsi_dump(struct udev *udev,
                 /*
                  * Impossible, should not be called.
                  */
-                log_debug("%s: called with no error", __FUNCTION__);
+                log_info("%s: called with no error", __FUNCTION__);
                 return -1;
         }
 
-        log_debug("%s: sg_io failed status 0x%x 0x%x 0x%x 0x%x",
+        log_info("%s: sg_io failed status 0x%x 0x%x 0x%x 0x%x",
                   dev_scsi->kernel, io->driver_status, io->host_status, io->msg_status, io->status);
         if (io->status == SCSI_CHECK_CONDITION)
                 return scsi_dump_sense(udev, dev_scsi, io->sbp, io->sb_len_wr);
@@ -295,11 +295,11 @@ static int scsi_dump_v4(struct udev *udev,
                 /*
                  * Impossible, should not be called.
                  */
-                log_debug("%s: called with no error", __FUNCTION__);
+                log_info("%s: called with no error", __FUNCTION__);
                 return -1;
         }
 
-        log_debug("%s: sg_io failed status 0x%x 0x%x 0x%x",
+        log_info("%s: sg_io failed status 0x%x 0x%x 0x%x",
                   dev_scsi->kernel, io->driver_status, io->transport_status, io->device_status);
         if (io->device_status == SCSI_CHECK_CONDITION)
                 return scsi_dump_sense(udev, dev_scsi, (unsigned char *)(uintptr_t)io->response,
@@ -323,7 +323,7 @@ static int scsi_inquiry(struct udev *udev,
         int retval;
 
         if (buflen > SCSI_INQ_BUFF_LEN) {
-                log_debug("buflen %d too long", buflen);
+                log_info("buflen %d too long", buflen);
                 return -1;
         }
 
@@ -360,7 +360,7 @@ resend:
                         dev_scsi->use_sg = 3;
                         goto resend;
                 }
-                log_debug_errno(errno, "%s: ioctl failed: %m", dev_scsi->kernel);
+                log_info_errno(errno, "%s: ioctl failed: %m", dev_scsi->kernel);
                 goto error;
         }
 
@@ -395,7 +395,7 @@ resend:
 
 error:
         if (retval < 0)
-                log_debug("%s: Unable to get INQUIRY vpd %d page 0x%x.",
+                log_info("%s: Unable to get INQUIRY vpd %d page 0x%x.",
                           dev_scsi->kernel, evpd, page);
 
         return retval;
@@ -414,11 +414,11 @@ static int do_scsi_page0_inquiry(struct udev *udev,
                 return 1;
 
         if (buffer[1] != 0) {
-                log_debug("%s: page 0 not available.", dev_scsi->kernel);
+                log_info("%s: page 0 not available.", dev_scsi->kernel);
                 return 1;
         }
         if (buffer[3] > len) {
-                log_debug("%s: page 0 buffer too long %d", dev_scsi->kernel, buffer[3]);
+                log_info("%s: page 0 buffer too long %d", dev_scsi->kernel, buffer[3]);
                 return 1;
         }
 
@@ -435,7 +435,7 @@ static int do_scsi_page0_inquiry(struct udev *udev,
                  * invalid.
                  */
                 if (strneq((char *)&buffer[VENDOR_LENGTH], dev_scsi->vendor, VENDOR_LENGTH)) {
-                        log_debug("%s: invalid page0 data", dev_scsi->kernel);
+                        log_info("%s: invalid page0 data", dev_scsi->kernel);
                         return 1;
                 }
         }
@@ -460,7 +460,7 @@ static int prepend_vendor_model(struct udev *udev,
          * above, ind will never be too large.
          */
         if (ind != (VENDOR_LENGTH + MODEL_LENGTH)) {
-                log_debug("%s: expected length %d, got length %d",
+                log_info("%s: expected length %d, got length %d",
                           dev_scsi->kernel, (VENDOR_LENGTH + MODEL_LENGTH), ind);
                 return -1;
         }
@@ -525,7 +525,7 @@ static int check_fill_0x83_id(struct udev *udev,
                 len += VENDOR_LENGTH + MODEL_LENGTH;
 
         if (max_len < len) {
-                log_debug("%s: length %d too short - need %d",
+                log_info("%s: length %d too short - need %d",
                           dev_scsi->kernel, max_len, len);
                 return 1;
         }
@@ -625,7 +625,7 @@ static int do_scsi_page83_inquiry(struct udev *udev,
                 return 1;
 
         if (page_83[1] != PAGE_83) {
-                log_debug("%s: Invalid page 0x83", dev_scsi->kernel);
+                log_info("%s: Invalid page 0x83", dev_scsi->kernel);
                 return 1;
         }
 
@@ -711,7 +711,7 @@ static int do_scsi_page83_prespc3_inquiry(struct udev *udev,
                 return 1;
 
         if (page_83[1] != PAGE_83) {
-                log_debug("%s: Invalid page 0x83", dev_scsi->kernel);
+                log_info("%s: Invalid page 0x83", dev_scsi->kernel);
                 return 1;
         }
         /*
@@ -775,13 +775,13 @@ static int do_scsi_page80_inquiry(struct udev *udev,
                 return retval;
 
         if (buf[1] != PAGE_80) {
-                log_debug("%s: Invalid page 0x80", dev_scsi->kernel);
+                log_info("%s: Invalid page 0x80", dev_scsi->kernel);
                 return 1;
         }
 
         len = 1 + VENDOR_LENGTH + MODEL_LENGTH + buf[3];
         if (max_len < len) {
-                log_debug("%s: length %d too short - need %d",
+                log_info("%s: length %d too short - need %d",
                           dev_scsi->kernel, max_len, len);
                 return 1;
         }
@@ -816,12 +816,12 @@ int scsi_std_inquiry(struct udev *udev,
 
         fd = open(devname, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
         if (fd < 0) {
-                log_debug_errno(errno, "scsi_id: cannot open %s: %m", devname);
+                log_info_errno(errno, "scsi_id: cannot open %s: %m", devname);
                 return 1;
         }
 
         if (fstat(fd, &statbuf) < 0) {
-                log_debug_errno(errno, "scsi_id: cannot stat %s: %m", devname);
+                log_info_errno(errno, "scsi_id: cannot stat %s: %m", devname);
                 err = 2;
                 goto out;
         }
@@ -914,7 +914,7 @@ int scsi_get_serial(struct udev *udev,
                         goto completed;
                 }
         } else if (page_code != 0x00) {
-                log_debug("%s: unsupported page code 0x%d", dev_scsi->kernel, page_code);
+                log_info("%s: unsupported page code 0x%d", dev_scsi->kernel, page_code);
                 retval = 1;
                 goto completed;
         }
diff --git a/src/udev/udev-builtin-blkid.c b/src/udev/udev-builtin-blkid.c
index 6ff244e96..208318c8c 100644
--- a/src/udev/udev-builtin-blkid.c
+++ b/src/udev/udev-builtin-blkid.c
@@ -272,7 +272,7 @@ static int builtin_blkid(struct udev_device *dev, int argc, char *argv[], bool t
 
         fd = open(udev_device_get_devnode(dev), O_RDONLY|O_CLOEXEC);
         if (fd < 0) {
-                err = log_debug_errno(errno, "Failure opening block device %s: %m", udev_device_get_devnode(dev));
+                err = log_info_errno(errno, "Failure opening block device %s: %m", udev_device_get_devnode(dev));
                 goto out;
         }
 
@@ -280,7 +280,7 @@ static int builtin_blkid(struct udev_device *dev, int argc, char *argv[], bool t
         if (err < 0)
                 goto out;
 
-        log_debug("probe %s %sraid offset=%"PRIi64,
+        log_info("probe %s %sraid offset=%"PRIi64,
                   udev_device_get_devnode(dev),
                   noraid ? "no" : "", offset);
 
diff --git a/src/udev/udev-builtin-input_id.c b/src/udev/udev-builtin-input_id.c
index fa830213f..67c09b5ae 100644
--- a/src/udev/udev-builtin-input_id.c
+++ b/src/udev/udev-builtin-input_id.c
@@ -105,7 +105,7 @@ static void get_cap_mask(struct udev_device *dev,
         v = strempty(v);
 
         xsprintf(text, "%s", v);
-        log_debug("%s raw kernel attribute: %s", attr, text);
+        log_info("%s raw kernel attribute: %s", attr, text);
 
         memzero(bitmask, bitmask_size);
         i = 0;
@@ -114,7 +114,7 @@ static void get_cap_mask(struct udev_device *dev,
                 if (i < bitmask_size/sizeof(unsigned long))
                         bitmask[i] = val;
                 else
-                        log_debug("ignoring %s block %lX which is larger than maximum size", attr, val);
+                        log_info("ignoring %s block %lX which is larger than maximum size", attr, val);
                 *word = '\0';
                 ++i;
         }
@@ -122,20 +122,20 @@ static void get_cap_mask(struct udev_device *dev,
         if (i < bitmask_size / sizeof(unsigned long))
                 bitmask[i] = val;
         else
-                log_debug("ignoring %s block %lX which is larger than maximum size", attr, val);
+                log_info("ignoring %s block %lX which is larger than maximum size", attr, val);
 
         if (test) {
                 /* printf pattern with the right unsigned long number of hex chars */
                 xsprintf(text, "  bit %%4u: %%0%zulX\n",
                          2 * sizeof(unsigned long));
-                log_debug("%s decoded bit map:", attr);
+                log_info("%s decoded bit map:", attr);
                 val = bitmask_size / sizeof (unsigned long);
                 /* skip over leading zeros */
                 while (bitmask[val-1] == 0 && val > 0)
                         --val;
                 for (i = 0; i < val; ++i) {
                         DISABLE_WARNING_FORMAT_NONLITERAL;
-                        log_debug(text, i * BITS_PER_LONG, bitmask[i]);
+                        log_info(text, i * BITS_PER_LONG, bitmask[i]);
                         REENABLE_WARNING;
                 }
         }
@@ -266,7 +266,7 @@ static bool test_key(struct udev_device *dev,
 
         /* do we have any KEY_* capability? */
         if (!test_bit(EV_KEY, bitmask_ev)) {
-                log_debug("test_key: no EV_KEY capability");
+                log_info("test_key: no EV_KEY capability");
                 return false;
         }
 
@@ -274,7 +274,7 @@ static bool test_key(struct udev_device *dev,
         found = 0;
         for (i = 0; i < BTN_MISC/BITS_PER_LONG; ++i) {
                 found |= bitmask_key[i];
-                log_debug("test_key: checking bit block %lu for any keys; found=%i", (unsigned long)i*BITS_PER_LONG, found > 0);
+                log_info("test_key: checking bit block %lu for any keys; found=%i", (unsigned long)i*BITS_PER_LONG, found > 0);
         }
         /* If there are no keys in the lower block, check the higher blocks */
         if (!found) {
@@ -282,7 +282,7 @@ static bool test_key(struct udev_device *dev,
                 for (block = 0; block < (sizeof(high_key_blocks) / sizeof(struct range)); ++block) {
                         for (i = high_key_blocks[block].start; i < high_key_blocks[block].end; ++i) {
                                 if (test_bit(i, bitmask_key)) {
-                                        log_debug("test_key: Found key %x in high block", i);
+                                        log_info("test_key: Found key %x in high block", i);
                                         found = 1;
                                         break;
                                 }
diff --git a/src/udev/udev-builtin-keyboard.c b/src/udev/udev-builtin-keyboard.c
index 004428039..c3c089859 100644
--- a/src/udev/udev-builtin-keyboard.c
+++ b/src/udev/udev-builtin-keyboard.c
@@ -63,7 +63,7 @@ static int install_force_release(struct udev_device *dev, const unsigned *releas
         for (i = 0; i < release_count; i++)
                 l = strpcpyf(&s, l, ",%u", release[i]);
 
-        log_debug("keyboard: updating force-release list with '%s'", codes);
+        log_info("keyboard: updating force-release list with '%s'", codes);
         ret = udev_device_set_sysattr_value(atkbd, "force_release", codes);
         if (ret < 0)
                 log_error_errno(ret, "Error writing force-release attribute: %m");
@@ -96,7 +96,7 @@ static void map_keycode(int fd, const char *devnode, int scancode, const char *k
         map.scan = scancode;
         map.key = keycode_num;
 
-        log_debug("keyboard: mapping scan code %d (0x%x) to key code %d (0x%x)",
+        log_info("keyboard: mapping scan code %d (0x%x) to key code %d (0x%x)",
                   map.scan, map.scan, map.key, map.key);
 
         if (ioctl(fd, EVIOCSKEYCODE, &map) < 0)
@@ -145,7 +145,7 @@ static void override_abs(int fd, const char *devnode,
                 return;
         }
 
-        log_debug("keyboard: %x overridden with %"PRIi32"/%"PRIi32"/%"PRIi32"/%"PRIi32"/%"PRIi32" for \"%s\"",
+        log_info("keyboard: %x overridden with %"PRIi32"/%"PRIi32"/%"PRIi32"/%"PRIi32"/%"PRIi32" for \"%s\"",
                   evcode,
                   absinfo.minimum, absinfo.maximum, absinfo.resolution, absinfo.fuzz, absinfo.flat,
                   devnode);
diff --git a/src/udev/udev-builtin-kmod.c b/src/udev/udev-builtin-kmod.c
index 2530fdfd2..36efebc19 100644
--- a/src/udev/udev-builtin-kmod.c
+++ b/src/udev/udev-builtin-kmod.c
@@ -41,7 +41,7 @@ static int load_module(struct udev *udev, const char *alias) {
                 return err;
 
         if (list == NULL)
-                log_debug("No module matches '%s'", alias);
+                log_info("No module matches '%s'", alias);
 
         kmod_list_foreach(l, list) {
                 _cleanup_(kmod_module_unrefp) struct kmod_module *mod = NULL;
@@ -50,11 +50,11 @@ static int load_module(struct udev *udev, const char *alias) {
 
                 err = kmod_module_probe_insert_module(mod, KMOD_PROBE_APPLY_BLACKLIST, NULL, NULL, NULL, NULL);
                 if (err == KMOD_PROBE_APPLY_BLACKLIST)
-                        log_debug("Module '%s' is blacklisted", kmod_module_get_name(mod));
+                        log_info("Module '%s' is blacklisted", kmod_module_get_name(mod));
                 else if (err == 0)
-                        log_debug("Inserted '%s'", kmod_module_get_name(mod));
+                        log_info("Inserted '%s'", kmod_module_get_name(mod));
                 else
-                        log_debug("Failed to insert '%s'", kmod_module_get_name(mod));
+                        log_info("Failed to insert '%s'", kmod_module_get_name(mod));
         }
 
         return err;
@@ -77,7 +77,7 @@ static int builtin_kmod(struct udev_device *dev, int argc, char *argv[], bool te
         }
 
         for (i = 2; argv[i]; i++) {
-                log_debug("Execute '%s' '%s'", argv[1], argv[i]);
+                log_info("Execute '%s' '%s'", argv[1], argv[i]);
                 load_module(udev, argv[i]);
         }
 
@@ -93,7 +93,7 @@ static int builtin_kmod_init(struct udev *udev) {
         if (!ctx)
                 return -ENOMEM;
 
-        log_debug("Load module index");
+        log_info("Load module index");
         kmod_set_log_fn(ctx, udev_kmod_log, udev);
         kmod_load_resources(ctx);
         return 0;
@@ -101,13 +101,13 @@ static int builtin_kmod_init(struct udev *udev) {
 
 /* called on udev shutdown and reload request */
 static void builtin_kmod_exit(struct udev *udev) {
-        log_debug("Unload module index");
+        log_info("Unload module index");
         ctx = kmod_unref(ctx);
 }
 
 /* called every couple of seconds during event activity; 'true' if config has changed */
 static bool builtin_kmod_validate(struct udev *udev) {
-        log_debug("Validate module index");
+        log_info("Validate module index");
         if (!ctx)
                 return false;
         return (kmod_validate_resources(ctx) != KMOD_RESOURCES_OK);
diff --git a/src/udev/udev-builtin-net_setup_link.c b/src/udev/udev-builtin-net_setup_link.c
index 40158e0af..b66e09bfb 100644
--- a/src/udev/udev-builtin-net_setup_link.c
+++ b/src/udev/udev-builtin-net_setup_link.c
@@ -43,7 +43,7 @@ static int builtin_net_setup_link(struct udev_device *dev, int argc, char **argv
         r = link_config_get(ctx, dev, &link);
         if (r < 0) {
                 if (r == -ENOENT) {
-                        log_debug("No matching link configuration found.");
+                        log_info("No matching link configuration found.");
                         return EXIT_SUCCESS;
                 } else {
                         log_error_errno(r, "Could not get link config: %m");
@@ -77,18 +77,18 @@ static int builtin_net_setup_link_init(struct udev *udev) {
         if (r < 0)
                 return r;
 
-        log_debug("Created link configuration context.");
+        log_info("Created link configuration context.");
         return 0;
 }
 
 static void builtin_net_setup_link_exit(struct udev *udev) {
         link_config_ctx_free(ctx);
         ctx = NULL;
-        log_debug("Unloaded link configuration context.");
+        log_info("Unloaded link configuration context.");
 }
 
 static bool builtin_net_setup_link_validate(struct udev *udev) {
-        log_debug("Check if link configuration needs reloading.");
+        log_info("Check if link configuration needs reloading.");
         if (!ctx)
                 return false;
 
diff --git a/src/udev/udev-builtin-usb_id.c b/src/udev/udev-builtin-usb_id.c
index 6d22dfe82..5d40ffc08 100644
--- a/src/udev/udev-builtin-usb_id.c
+++ b/src/udev/udev-builtin-usb_id.c
@@ -173,7 +173,7 @@ static int dev_if_packed_info(struct udev_device *dev, char *ifs_str, size_t len
 
         fd = open(filename, O_RDONLY|O_CLOEXEC);
         if (fd < 0)
-                return log_debug_errno(errno, "Error opening USB device 'descriptors' file: %m");
+                return log_info_errno(errno, "Error opening USB device 'descriptors' file: %m");
 
         size = read(fd, buf, sizeof(buf));
         if (size < 18 || size == sizeof(buf))
@@ -268,7 +268,7 @@ static int builtin_usb_id(struct udev_device *dev, int argc, char *argv[], bool
         /* usb interface directory */
         dev_interface = udev_device_get_parent_with_subsystem_devtype(dev, "usb", "usb_interface");
         if (dev_interface == NULL) {
-                log_debug("unable to access usb_interface device of '%s'",
+                log_info("unable to access usb_interface device of '%s'",
                      udev_device_get_syspath(dev));
                 return EXIT_FAILURE;
         }
@@ -278,7 +278,7 @@ static int builtin_usb_id(struct udev_device *dev, int argc, char *argv[], bool
 
         if_class = udev_device_get_sysattr_value(dev_interface, "bInterfaceClass");
         if (!if_class) {
-                log_debug("%s: cannot get bInterfaceClass attribute",
+                log_info("%s: cannot get bInterfaceClass attribute",
                      udev_device_get_sysname(dev));
                 return EXIT_FAILURE;
         }
@@ -293,13 +293,13 @@ static int builtin_usb_id(struct udev_device *dev, int argc, char *argv[], bool
                 set_usb_iftype(type_str, if_class_num, sizeof(type_str)-1);
         }
 
-        log_debug("%s: if_class %d protocol %d",
+        log_info("%s: if_class %d protocol %d",
              udev_device_get_syspath(dev_interface), if_class_num, protocol);
 
         /* usb device directory */
         dev_usb = udev_device_get_parent_with_subsystem_devtype(dev_interface, "usb", "usb_device");
         if (!dev_usb) {
-                log_debug("unable to find parent 'usb' device of '%s'",
+                log_info("unable to find parent 'usb' device of '%s'",
                      udev_device_get_syspath(dev));
                 return EXIT_FAILURE;
         }
@@ -316,19 +316,19 @@ static int builtin_usb_id(struct udev_device *dev, int argc, char *argv[], bool
                 /* get scsi device */
                 dev_scsi = udev_device_get_parent_with_subsystem_devtype(dev, "scsi", "scsi_device");
                 if (dev_scsi == NULL) {
-                        log_debug("unable to find parent 'scsi' device of '%s'",
+                        log_info("unable to find parent 'scsi' device of '%s'",
                              udev_device_get_syspath(dev));
                         goto fallback;
                 }
                 if (sscanf(udev_device_get_sysname(dev_scsi), "%d:%d:%d:%d", &host, &bus, &target, &lun) != 4) {
-                        log_debug("invalid scsi device '%s'", udev_device_get_sysname(dev_scsi));
+                        log_info("invalid scsi device '%s'", udev_device_get_sysname(dev_scsi));
                         goto fallback;
                 }
 
                 /* Generic SPC-2 device */
                 scsi_vendor = udev_device_get_sysattr_value(dev_scsi, "vendor");
                 if (!scsi_vendor) {
-                        log_debug("%s: cannot get SCSI vendor attribute",
+                        log_info("%s: cannot get SCSI vendor attribute",
                              udev_device_get_sysname(dev_scsi));
                         goto fallback;
                 }
@@ -338,7 +338,7 @@ static int builtin_usb_id(struct udev_device *dev, int argc, char *argv[], bool
 
                 scsi_model = udev_device_get_sysattr_value(dev_scsi, "model");
                 if (!scsi_model) {
-                        log_debug("%s: cannot get SCSI model attribute",
+                        log_info("%s: cannot get SCSI model attribute",
                              udev_device_get_sysname(dev_scsi));
                         goto fallback;
                 }
@@ -348,7 +348,7 @@ static int builtin_usb_id(struct udev_device *dev, int argc, char *argv[], bool
 
                 scsi_type = udev_device_get_sysattr_value(dev_scsi, "type");
                 if (!scsi_type) {
-                        log_debug("%s: cannot get SCSI type attribute",
+                        log_info("%s: cannot get SCSI type attribute",
                              udev_device_get_sysname(dev_scsi));
                         goto fallback;
                 }
@@ -356,7 +356,7 @@ static int builtin_usb_id(struct udev_device *dev, int argc, char *argv[], bool
 
                 scsi_rev = udev_device_get_sysattr_value(dev_scsi, "rev");
                 if (!scsi_rev) {
-                        log_debug("%s: cannot get SCSI revision attribute",
+                        log_info("%s: cannot get SCSI revision attribute",
                              udev_device_get_sysname(dev_scsi));
                         goto fallback;
                 }
@@ -382,7 +382,7 @@ fallback:
                 if (!usb_vendor)
                         usb_vendor = vendor_id;
                 if (!usb_vendor) {
-                        log_debug("No USB vendor information available");
+                        log_info("No USB vendor information available");
                         return EXIT_FAILURE;
                 }
                 udev_util_encode_string(usb_vendor, vendor_str_enc, sizeof(vendor_str_enc));
diff --git a/src/udev/udev-event.c b/src/udev/udev-event.c
index d0befba29..16fa5165a 100644
--- a/src/udev/udev-event.c
+++ b/src/udev/udev-event.c
@@ -218,7 +218,7 @@ static size_t subst_format_var(struct udev_event *event, struct udev_device *dev
                         vbuf[len] = '\0';
                 count = util_replace_chars(vbuf, UDEV_ALLOWED_CHARS_INPUT);
                 if (count > 0)
-                        log_debug("%i character(s) replaced" , count);
+                        log_info("%i character(s) replaced" , count);
                 l = strpcpy(&s, l, vbuf);
                 break;
         }
@@ -580,7 +580,7 @@ static void spawn_read(struct udev_event *event,
                                         pos = buf;
                                         while ((line = strsep(&pos, "\n"))) {
                                                 if (pos != NULL || line[0] != '\0')
-                                                        log_debug("'%s'(%s) '%s'", cmd, *fd == fd_stdout ? "out" : "err" , line);
+                                                        log_info("'%s'(%s) '%s'", cmd, *fd == fd_stdout ? "out" : "err" , line);
                                         }
                                 }
                         } else if (ev[i].events & EPOLLHUP) {
@@ -633,12 +633,12 @@ static int on_spawn_sigchld(sd_event_source *s, const siginfo_t *si, void *userd
         switch (si->si_code) {
         case CLD_EXITED:
                 if (si->si_status == 0) {
-                        log_debug("Process '%s' succeeded.", spawn->cmd);
+                        log_info("Process '%s' succeeded.", spawn->cmd);
                         sd_event_exit(sd_event_source_get_event(s), 0);
 
                         return 1;
                 } else if (spawn->accept_failure)
-                        log_debug("Process '%s' failed with exit code %i.", spawn->cmd, si->si_status);
+                        log_info("Process '%s' failed with exit code %i.", spawn->cmd, si->si_status);
                 else
                         log_warning("Process '%s' failed with exit code %i.", spawn->cmd, si->si_status);
 
@@ -795,7 +795,7 @@ int udev_event_spawn(struct udev_event *event,
                         argv[0] = program;
                 }
 
-                log_debug("starting '%s'", cmd);
+                log_info("starting '%s'", cmd);
 
                 spawn_exec(event, cmd, argv, udev_device_get_properties_envp(event->dev),
                            outpipe[WRITE_END], errpipe[WRITE_END]);
@@ -841,7 +841,7 @@ static int rename_netif(struct udev_event *event) {
         if (r < 0)
                 return log_error_errno(r, "Error changing net interface name '%s' to '%s': %m", oldname, name);
 
-        log_debug("renamed network interface '%s' to '%s'", oldname, name);
+        log_info("renamed network interface '%s' to '%s'", oldname, name);
 
         return 0;
 }
@@ -900,7 +900,7 @@ void udev_event_execute_rules(struct udev_event *event,
                                         log_warning_errno(r, "renamed interface '%d' from '%s' to '%s', but could not update udev_device: %m",
                                                           udev_device_get_ifindex(dev), udev_device_get_sysname(dev), event->name);
                                 else
-                                        log_debug("changed devpath to '%s'", udev_device_get_devpath(dev));
+                                        log_info("changed devpath to '%s'", udev_device_get_devpath(dev));
                         }
                 }
 
@@ -960,7 +960,7 @@ void udev_event_execute_run(struct udev_event *event, usec_t timeout_usec, usec_
                         udev_builtin_run(event->dev, builtin_cmd, command, false);
                 else {
                         if (event->exec_delay > 0) {
-                                log_debug("delay execution of '%s'", command);
+                                log_info("delay execution of '%s'", command);
                                 sleep(event->exec_delay);
                         }
 
diff --git a/src/udev/udev-node.c b/src/udev/udev-node.c
index bb845889c..2c3899478 100644
--- a/src/udev/udev-node.c
+++ b/src/udev/udev-node.c
@@ -78,7 +78,7 @@ static int node_symlink(struct udev_device *dev, const char *node, const char *s
                         if (len > 0 && len < (int)sizeof(buf)) {
                                 buf[len] = '\0';
                                 if (streq(target, buf)) {
-                                        log_debug("preserve already existing symlink '%s' to '%s'", slink, target);
+                                        log_info("preserve already existing symlink '%s' to '%s'", slink, target);
                                         label_fix(slink, true, false);
                                         utimensat(AT_FDCWD, slink, NULL, AT_SYMLINK_NOFOLLOW);
                                         goto exit;
@@ -86,7 +86,7 @@ static int node_symlink(struct udev_device *dev, const char *node, const char *s
                         }
                 }
         } else {
-                log_debug("creating symlink '%s' to '%s'", slink, target);
+                log_info("creating symlink '%s' to '%s'", slink, target);
                 do {
                         err = mkdir_parents_label(slink, 0755);
                         if (!IN_SET(err, 0, -ENOENT))
@@ -101,7 +101,7 @@ static int node_symlink(struct udev_device *dev, const char *node, const char *s
                         goto exit;
         }
 
-        log_debug("atomically replace '%s'", slink);
+        log_info("atomically replace '%s'", slink);
         strscpyl(slink_tmp, sizeof(slink_tmp), slink, ".tmp-", udev_device_get_id_filename(dev), NULL);
         unlink(slink_tmp);
         do {
@@ -152,7 +152,7 @@ static const char *link_find_prioritized(struct udev_device *dev, bool add, cons
                 if (dent->d_name[0] == '.')
                         continue;
 
-                log_debug("found '%s' claiming '%s'", dent->d_name, stackdir);
+                log_info("found '%s' claiming '%s'", dent->d_name, stackdir);
 
                 /* did we find ourself? */
                 if (streq(dent->d_name, udev_device_get_id_filename(dev)))
@@ -165,7 +165,7 @@ static const char *link_find_prioritized(struct udev_device *dev, bool add, cons
                         devnode = udev_device_get_devnode(dev_db);
                         if (devnode != NULL) {
                                 if (target == NULL || udev_device_get_devlink_priority(dev_db) > priority) {
-                                        log_debug("'%s' claims priority %i for '%s'",
+                                        log_info("'%s' claims priority %i for '%s'",
                                                   udev_device_get_syspath(dev_db), udev_device_get_devlink_priority(dev_db), stackdir);
                                         priority = udev_device_get_devlink_priority(dev_db);
                                         strscpy(buf, bufsize, devnode);
@@ -196,11 +196,11 @@ static void link_update(struct udev_device *dev, const char *slink, bool add) {
 
         target = link_find_prioritized(dev, add, dirname, buf, sizeof(buf));
         if (target == NULL) {
-                log_debug("no reference left, remove '%s'", slink);
+                log_info("no reference left, remove '%s'", slink);
                 if (unlink(slink) == 0)
                         rmdir_parents(slink, "/");
         } else {
-                log_debug("creating link '%s' to '%s'", slink, target);
+                log_info("creating link '%s' to '%s'", slink, target);
                 node_symlink(dev, target, slink);
         }
 
@@ -244,7 +244,7 @@ void udev_node_update_old_links(struct udev_device *dev, struct udev_device *dev
                 if (found)
                         continue;
 
-                log_debug("update old name, '%s' no longer belonging to '%s'",
+                log_info("update old name, '%s' no longer belonging to '%s'",
                      name, udev_device_get_devpath(dev));
                 link_update(dev, name, false);
         }
@@ -265,13 +265,13 @@ static int node_permissions_apply(struct udev_device *dev, bool apply,
                 mode |= S_IFCHR;
 
         if (lstat(devnode, &stats) != 0) {
-                err = log_debug_errno(errno, "can not stat() node '%s' (%m)", devnode);
+                err = log_info_errno(errno, "can not stat() node '%s' (%m)", devnode);
                 goto out;
         }
 
         if (((stats.st_mode & S_IFMT) != (mode & S_IFMT)) || (stats.st_rdev != devnum)) {
                 err = -EEXIST;
-                log_debug("found node '%s' with non-matching devnum %s, skip handling",
+                log_info("found node '%s' with non-matching devnum %s, skip handling",
                           udev_device_get_devnode(dev), udev_device_get_id_filename(dev));
                 goto out;
         }
@@ -281,7 +281,7 @@ static int node_permissions_apply(struct udev_device *dev, bool apply,
                 bool smack = false;
 
                 if ((stats.st_mode & 0777) != (mode & 0777) || stats.st_uid != uid || stats.st_gid != gid) {
-                        log_debug("set permissions %s, %#o, uid=%u, gid=%u", devnode, mode, uid, gid);
+                        log_info("set permissions %s, %#o, uid=%u, gid=%u", devnode, mode, uid, gid);
                         err = chmod(devnode, mode);
                         if (err < 0)
                                 log_warning_errno(errno, "setting mode of %s to %#o failed: %m", devnode, mode);
@@ -289,7 +289,7 @@ static int node_permissions_apply(struct udev_device *dev, bool apply,
                         if (err < 0)
                                 log_warning_errno(errno, "setting owner of %s to uid=%u, gid=%u failed: %m", devnode, uid, gid);
                 } else {
-                        log_debug("preserve permissions %s, %#o, uid=%u, gid=%u", devnode, mode, uid, gid);
+                        log_info("preserve permissions %s, %#o, uid=%u, gid=%u", devnode, mode, uid, gid);
                 }
 
                 /* apply SECLABEL{$module}=$label */
@@ -307,7 +307,7 @@ static int node_permissions_apply(struct udev_device *dev, bool apply,
                                 if (r < 0)
                                         log_error_errno(r, "SECLABEL: failed to set SELinux label '%s': %m", label);
                                 else
-                                        log_debug("SECLABEL: set SELinux label '%s'", label);
+                                        log_info("SECLABEL: set SELinux label '%s'", label);
 
                         } else if (streq(name, "smack")) {
                                 smack = true;
@@ -316,7 +316,7 @@ static int node_permissions_apply(struct udev_device *dev, bool apply,
                                 if (r < 0)
                                         log_error_errno(r, "SECLABEL: failed to set SMACK label '%s': %m", label);
                                 else
-                                        log_debug("SECLABEL: set SMACK label '%s'", label);
+                                        log_info("SECLABEL: set SMACK label '%s'", label);
 
                         } else
                                 log_error("SECLABEL: unknown subsystem, ignoring '%s'='%s'", name, label);
@@ -341,7 +341,7 @@ void udev_node_add(struct udev_device *dev, bool apply,
         char filename[DEV_NUM_PATH_MAX];
         struct udev_list_entry *list_entry;
 
-        log_debug("handling device node '%s', devnum=%s, mode=%#o, uid="UID_FMT", gid="GID_FMT,
+        log_info("handling device node '%s', devnum=%s, mode=%#o, uid="UID_FMT", gid="GID_FMT,
                   udev_device_get_devnode(dev), udev_device_get_id_filename(dev), mode, uid, gid);
 
         if (node_permissions_apply(dev, apply, mode, uid, gid, seclabel_list) < 0)
diff --git a/src/udev/udev-rules.c b/src/udev/udev-rules.c
index f4708bb06..597600bd3 100644
--- a/src/udev/udev-rules.c
+++ b/src/udev/udev-rules.c
@@ -341,7 +341,7 @@ static void dump_token(struct udev_rules *rules, struct token *token) {
                         const char *tk_ptr = (char *)token;
                         unsigned int idx = (tk_ptr - tks_ptr) / sizeof(struct token);
 
-                        log_debug("* RULE %s:%u, token: %u, count: %u, label: '%s'",
+                        log_info("* RULE %s:%u, token: %u, count: %u, label: '%s'",
                                   &rules->strbuf->buf[token->rule.filename_off], token->rule.filename_line,
                                   idx, token->rule.token_count,
                                   &rules->strbuf->buf[token->rule.label_off]);
@@ -373,11 +373,11 @@ static void dump_token(struct udev_rules *rules, struct token *token) {
         case TK_A_MODE:
         case TK_A_RUN_BUILTIN:
         case TK_A_RUN_PROGRAM:
-                log_debug("%s %s '%s'(%s)",
+                log_info("%s %s '%s'(%s)",
                           token_str(type), operation_str(op), value, string_glob_str(glob));
                 break;
         case TK_M_IMPORT_BUILTIN:
-                log_debug("%s %i '%s'", token_str(type), token->key.builtin_cmd, value);
+                log_info("%s %i '%s'", token_str(type), token->key.builtin_cmd, value);
                 break;
         case TK_M_ATTR:
         case TK_M_SYSCTL:
@@ -386,54 +386,54 @@ static void dump_token(struct udev_rules *rules, struct token *token) {
         case TK_A_ATTR:
         case TK_A_SYSCTL:
         case TK_A_ENV:
-                log_debug("%s %s '%s' '%s'(%s)",
+                log_info("%s %s '%s' '%s'(%s)",
                           token_str(type), operation_str(op), attr, value, string_glob_str(glob));
                 break;
         case TK_M_TAG:
         case TK_A_TAG:
-                log_debug("%s %s '%s'", token_str(type), operation_str(op), value);
+                log_info("%s %s '%s'", token_str(type), operation_str(op), value);
                 break;
         case TK_A_STRING_ESCAPE_NONE:
         case TK_A_STRING_ESCAPE_REPLACE:
         case TK_A_DB_PERSIST:
-                log_debug("%s", token_str(type));
+                log_info("%s", token_str(type));
                 break;
         case TK_M_TEST:
-                log_debug("%s %s '%s'(%s) %#o",
+                log_info("%s %s '%s'(%s) %#o",
                           token_str(type), operation_str(op), value, string_glob_str(glob), token->key.mode);
                 break;
         case TK_A_INOTIFY_WATCH:
-                log_debug("%s %u", token_str(type), token->key.watch);
+                log_info("%s %u", token_str(type), token->key.watch);
                 break;
         case TK_A_DEVLINK_PRIO:
-                log_debug("%s %u", token_str(type), token->key.devlink_prio);
+                log_info("%s %u", token_str(type), token->key.devlink_prio);
                 break;
         case TK_A_OWNER_ID:
-                log_debug("%s %s %u", token_str(type), operation_str(op), token->key.uid);
+                log_info("%s %s %u", token_str(type), operation_str(op), token->key.uid);
                 break;
         case TK_A_GROUP_ID:
-                log_debug("%s %s %u", token_str(type), operation_str(op), token->key.gid);
+                log_info("%s %s %u", token_str(type), operation_str(op), token->key.gid);
                 break;
         case TK_A_MODE_ID:
-                log_debug("%s %s %#o", token_str(type), operation_str(op), token->key.mode);
+                log_info("%s %s %#o", token_str(type), operation_str(op), token->key.mode);
                 break;
         case TK_A_STATIC_NODE:
-                log_debug("%s '%s'", token_str(type), value);
+                log_info("%s '%s'", token_str(type), value);
                 break;
         case TK_A_SECLABEL:
-                log_debug("%s %s '%s' '%s'", token_str(type), operation_str(op), attr, value);
+                log_info("%s %s '%s' '%s'", token_str(type), operation_str(op), attr, value);
                 break;
         case TK_A_GOTO:
-                log_debug("%s '%s' %u", token_str(type), value, token->key.rule_goto);
+                log_info("%s '%s' %u", token_str(type), value, token->key.rule_goto);
                 break;
         case TK_END:
-                log_debug("* %s", token_str(type));
+                log_info("* %s", token_str(type));
                 break;
         case TK_M_PARENTS_MIN:
         case TK_M_PARENTS_MAX:
         case TK_M_MAX:
         case TK_UNSET:
-                log_debug("unknown type %u", type);
+                log_info("unknown type %u", type);
                 break;
         }
 }
@@ -441,7 +441,7 @@ static void dump_token(struct udev_rules *rules, struct token *token) {
 static void dump_rules(struct udev_rules *rules) {
         unsigned int i;
 
-        log_debug("dumping %u (%zu bytes) tokens, %zu (%zu bytes) strings",
+        log_info("dumping %u (%zu bytes) tokens, %zu (%zu bytes) strings",
                   rules->token_cur,
                   rules->token_cur * sizeof(struct token),
                   rules->strbuf->nodes_count,
@@ -616,7 +616,7 @@ static int import_property_from_string(struct udev_device *dev, char *line) {
         /* unquote */
         if (IN_SET(val[0], '"', '\'')) {
                 if (len == 1 || val[len-1] != val[0]) {
-                        log_debug("inconsistent quoting: '%s', skip", line);
+                        log_info("inconsistent quoting: '%s', skip", line);
                         return -1;
                 }
                 val[len-1] = '\0';
@@ -1012,7 +1012,7 @@ static int sort_token(struct udev_rules *rules, struct rule_tmp *rule_tmp) {
 
 #define LOG_RULE_ERROR(fmt, ...) log_error("Invalid rule %s:%u: " fmt, filename, lineno, ##__VA_ARGS__)
 #define LOG_RULE_WARNING(fmt, ...) log_warning("%s:%u: " fmt, filename, lineno, ##__VA_ARGS__)
-#define LOG_RULE_DEBUG(fmt, ...) log_debug("%s:%u: " fmt, filename, lineno, ##__VA_ARGS__)
+#define LOG_RULE_DEBUG(fmt, ...) log_info("%s:%u: " fmt, filename, lineno, ##__VA_ARGS__)
 #define LOG_AND_RETURN(fmt, ...) { LOG_RULE_ERROR(fmt, __VA_ARGS__); return; }
 
 static void add_rule(struct udev_rules *rules, char *line,
@@ -1463,10 +1463,10 @@ static int parse_file(struct udev_rules *rules, const char *filename) {
         }
 
         if (null_or_empty_fd(fileno(f))) {
-                log_debug("Skipping empty file: %s", filename);
+                log_info("Skipping empty file: %s", filename);
                 return 0;
         } else
-                log_debug("Reading rules file: %s", filename);
+                log_info("Reading rules file: %s", filename);
 
         first_token = rules->token_cur;
         filename_off = rules_add_string(rules, filename);
@@ -1576,11 +1576,11 @@ struct udev_rules *udev_rules_new(struct udev *udev, int resolve_names) {
         memzero(&end_token, sizeof(struct token));
         end_token.type = TK_END;
         add_token(rules, &end_token);
-        log_debug("rules contain %zu bytes tokens (%u * %zu bytes), %zu bytes strings",
+        log_info("rules contain %zu bytes tokens (%u * %zu bytes), %zu bytes strings",
                   rules->token_max * sizeof(struct token), rules->token_max, sizeof(struct token), rules->strbuf->len);
 
         /* cleanup temporary strbuf data */
-        log_debug("%zu strings (%zu bytes), %zu de-duplicated (%zu bytes), %zu trie nodes used",
+        log_info("%zu strings (%zu bytes), %zu de-duplicated (%zu bytes), %zu trie nodes used",
                   rules->strbuf->in_count, rules->strbuf->in_len,
                   rules->strbuf->dedup_count, rules->strbuf->dedup_len, rules->strbuf->nodes_count);
         strbuf_complete(rules->strbuf);
@@ -1965,7 +1965,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
 
                         event->program_result = mfree(event->program_result);
                         udev_event_apply_format(event, rules_str(rules, cur->key.value_off), program, sizeof(program), false);
-                        log_debug("PROGRAM '%s' %s:%u",
+                        log_info("PROGRAM '%s' %s:%u",
                                   program,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -1980,7 +1980,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                                 if (IN_SET(esc, ESCAPE_UNSET, ESCAPE_REPLACE)) {
                                         count = util_replace_chars(result, UDEV_ALLOWED_CHARS_INPUT);
                                         if (count > 0)
-                                                log_debug("%i character(s) replaced" , count);
+                                                log_info("%i character(s) replaced" , count);
                                 }
                                 event->program_result = strdup(result);
                                 if (cur->key.op == OP_NOMATCH)
@@ -2001,7 +2001,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                         char import[UTIL_PATH_SIZE];
 
                         udev_event_apply_format(event, rules_str(rules, cur->key.value_off), import, sizeof(import), false);
-                        log_debug("IMPORT '%s' %s:%u",
+                        log_info("IMPORT '%s' %s:%u",
                                   import,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2017,7 +2017,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                         if (udev_builtin_run_once(cur->key.builtin_cmd)) {
                                 /* check if we ran already */
                                 if (event->builtin_run & (1 << cur->key.builtin_cmd)) {
-                                        log_debug("IMPORT builtin skip '%s' %s:%u",
+                                        log_info("IMPORT builtin skip '%s' %s:%u",
                                                   udev_builtin_name(cur->key.builtin_cmd),
                                                   rules_str(rules, rule->rule.filename_off),
                                                   rule->rule.filename_line);
@@ -2032,14 +2032,14 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                         }
 
                         udev_event_apply_format(event, rules_str(rules, cur->key.value_off), command, sizeof(command), false);
-                        log_debug("IMPORT builtin '%s' %s:%u",
+                        log_info("IMPORT builtin '%s' %s:%u",
                                   udev_builtin_name(cur->key.builtin_cmd),
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
 
                         if (udev_builtin_run(event->dev, cur->key.builtin_cmd, command, false) != 0) {
                                 /* remember failure */
-                                log_debug("IMPORT builtin '%s' returned non-zero",
+                                log_info("IMPORT builtin '%s' returned non-zero",
                                           udev_builtin_name(cur->key.builtin_cmd));
                                 event->builtin_ret |= (1 << cur->key.builtin_cmd);
                                 if (cur->key.op != OP_NOMATCH)
@@ -2069,7 +2069,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
 
                         r = proc_cmdline_get_key(key, PROC_CMDLINE_VALUE_OPTIONAL, &value);
                         if (r < 0)
-                                log_debug_errno(r, "Failed to read %s from /proc/cmdline, ignoring: %m", key);
+                                log_info_errno(r, "Failed to read %s from /proc/cmdline, ignoring: %m", key);
                         else if (r > 0) {
                                 imported = true;
 
@@ -2131,7 +2131,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                                 log_unknown_owner(r, "user", owner);
                                 event->uid = 0;
                         }
-                        log_debug("OWNER %u %s:%u",
+                        log_info("OWNER %u %s:%u",
                                   event->uid,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2152,7 +2152,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                                 log_unknown_owner(r, "group", group);
                                 event->gid = 0;
                         }
-                        log_debug("GROUP %u %s:%u",
+                        log_info("GROUP %u %s:%u",
                                   event->gid,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2175,7 +2175,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                                 event->mode_final = true;
                         event->mode_set = true;
                         event->mode = mode;
-                        log_debug("MODE %#o %s:%u",
+                        log_info("MODE %#o %s:%u",
                                   event->mode,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2188,7 +2188,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                                 event->owner_final = true;
                         event->owner_set = true;
                         event->uid = cur->key.uid;
-                        log_debug("OWNER %u %s:%u",
+                        log_info("OWNER %u %s:%u",
                                   event->uid,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2200,7 +2200,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                                 event->group_final = true;
                         event->group_set = true;
                         event->gid = cur->key.gid;
-                        log_debug("GROUP %u %s:%u",
+                        log_info("GROUP %u %s:%u",
                                   event->gid,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2212,7 +2212,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                                 event->mode_final = true;
                         event->mode_set = true;
                         event->mode = cur->key.mode;
-                        log_debug("MODE %#o %s:%u",
+                        log_info("MODE %#o %s:%u",
                                   event->mode,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2231,7 +2231,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                         if (IN_SET(cur->key.op, OP_ASSIGN, OP_ASSIGN_FINAL))
                                 udev_list_cleanup(&event->seclabel_list);
                         udev_list_entry_add(&event->seclabel_list, name, label);
-                        log_debug("SECLABEL{%s}='%s' %s:%u",
+                        log_info("SECLABEL{%s}='%s' %s:%u",
                                   name, label,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2300,7 +2300,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                         if (IN_SET(esc, ESCAPE_UNSET, ESCAPE_REPLACE)) {
                                 count = util_replace_chars(name_str, "/");
                                 if (count > 0)
-                                        log_debug("%i character(s) replaced", count);
+                                        log_info("%i character(s) replaced", count);
                         }
                         if (major(udev_device_get_devnum(event->dev)) &&
                             !streq(name_str, udev_device_get_devnode(event->dev) + STRLEN("/dev/"))) {
@@ -2314,7 +2314,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                                 log_oom();
                                 return;
                         }
-                        log_debug("NAME '%s' %s:%u",
+                        log_info("NAME '%s' %s:%u",
                                   event->name,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2342,14 +2342,14 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                         else if (esc == ESCAPE_REPLACE)
                                 count = util_replace_chars(temp, "/");
                         if (count > 0)
-                                log_debug("%i character(s) replaced" , count);
+                                log_info("%i character(s) replaced" , count);
                         pos = temp;
                         while (isspace(pos[0]))
                                 pos++;
                         next = strchr(pos, ' ');
                         while (next != NULL) {
                                 next[0] = '\0';
-                                log_debug("LINK '%s' %s:%u", pos,
+                                log_info("LINK '%s' %s:%u", pos,
                                           rules_str(rules, rule->rule.filename_off), rule->rule.filename_line);
                                 strscpyl(filename, sizeof(filename), "/dev/", pos, NULL);
                                 udev_device_add_devlink(event->dev, filename);
@@ -2359,7 +2359,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                                 next = strchr(pos, ' ');
                         }
                         if (pos[0] != '\0') {
-                                log_debug("LINK '%s' %s:%u", pos,
+                                log_info("LINK '%s' %s:%u", pos,
                                           rules_str(rules, rule->rule.filename_off), rule->rule.filename_line);
                                 strscpyl(filename, sizeof(filename), "/dev/", pos, NULL);
                                 udev_device_add_devlink(event->dev, filename);
@@ -2377,7 +2377,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                         attr_subst_subdir(attr, sizeof(attr));
 
                         udev_event_apply_format(event, rules_str(rules, cur->key.value_off), value, sizeof(value), false);
-                        log_debug("ATTR '%s' writing '%s' %s:%u", attr, value,
+                        log_info("ATTR '%s' writing '%s' %s:%u", attr, value,
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
                         f = fopen(attr, "we");
@@ -2394,7 +2394,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
                         udev_event_apply_format(event, rules_str(rules, cur->key.attr_off), filename, sizeof(filename), false);
                         sysctl_normalize(filename);
                         udev_event_apply_format(event, rules_str(rules, cur->key.value_off), value, sizeof(value), false);
-                        log_debug("SYSCTL '%s' writing '%s' %s:%u", filename, value,
+                        log_info("SYSCTL '%s' writing '%s' %s:%u", filename, value,
                                   rules_str(rules, rule->rule.filename_off), rule->rule.filename_line);
                         r = sysctl_write(filename, value);
                         if (r < 0)
@@ -2407,7 +2407,7 @@ void udev_rules_apply_to_event(struct udev_rules *rules,
 
                         if (IN_SET(cur->key.op, OP_ASSIGN, OP_ASSIGN_FINAL))
                                 udev_list_cleanup(&event->run_list);
-                        log_debug("RUN '%s' %s:%u",
+                        log_info("RUN '%s' %s:%u",
                                   rules_str(rules, cur->key.value_off),
                                   rules_str(rules, rule->rule.filename_off),
                                   rule->rule.filename_line);
@@ -2539,7 +2539,7 @@ int udev_rules_apply_static_dev_perms(struct udev_rules *rules) {
                                         return log_error_errno(errno, "Failed to chmod '%s' %#o: %m",
                                                                device_node, mode);
                                 else
-                                        log_debug("chmod '%s' %#o", device_node, mode);
+                                        log_info("chmod '%s' %#o", device_node, mode);
                         }
 
                         if ((uid != 0 && uid != stats.st_uid) || (gid != 0 && gid != stats.st_gid)) {
@@ -2548,7 +2548,7 @@ int udev_rules_apply_static_dev_perms(struct udev_rules *rules) {
                                         return log_error_errno(errno, "Failed to chown '%s' %u %u: %m",
                                                                device_node, uid, gid);
                                 else
-                                        log_debug("chown '%s' %u %u", device_node, uid, gid);
+                                        log_info("chown '%s' %u %u", device_node, uid, gid);
                         }
 
                         utimensat(AT_FDCWD, device_node, NULL, 0);
diff --git a/src/udev/udev-watch.c b/src/udev/udev-watch.c
index 351cb6345..3150a6635 100644
--- a/src/udev/udev-watch.c
+++ b/src/udev/udev-watch.c
@@ -75,7 +75,7 @@ void udev_watch_restore(struct udev *udev) {
                         if (dev == NULL)
                                 goto unlink;
 
-                        log_debug("restoring old watch on '%s'", udev_device_get_devnode(dev));
+                        log_info("restoring old watch on '%s'", udev_device_get_devnode(dev));
                         udev_watch_begin(udev, dev);
                         udev_device_unref(dev);
 unlink:
@@ -97,7 +97,7 @@ void udev_watch_begin(struct udev *udev, struct udev_device *dev) {
         if (inotify_fd < 0)
                 return;
 
-        log_debug("adding watch on '%s'", udev_device_get_devnode(dev));
+        log_info("adding watch on '%s'", udev_device_get_devnode(dev));
         wd = inotify_add_watch(inotify_fd, udev_device_get_devnode(dev), IN_CLOSE_WRITE);
         if (wd < 0) {
                 log_error_errno(errno, "inotify_add_watch(%d, %s, %o) failed: %m",
@@ -126,7 +126,7 @@ void udev_watch_end(struct udev *udev, struct udev_device *dev) {
         if (wd < 0)
                 return;
 
-        log_debug("removing watch on '%s'", udev_device_get_devnode(dev));
+        log_info("removing watch on '%s'", udev_device_get_devnode(dev));
         inotify_rm_watch(inotify_fd, wd);
 
         xsprintf(filename, "/run/udev/watch/%d", wd);
diff --git a/src/udev/udevadm-hwdb.c b/src/udev/udevadm-hwdb.c
index ab5dc7ab6..14436da58 100644
--- a/src/udev/udevadm-hwdb.c
+++ b/src/udev/udevadm-hwdb.c
@@ -402,17 +402,17 @@ static int trie_store(struct trie *trie, const char *filename) {
         /* write succeeded */
         fclose(t.f);
 
-        log_debug("=== trie on-disk ===");
-        log_debug("size:             %8"PRIi64" bytes", size);
-        log_debug("header:           %8zu bytes", sizeof(struct trie_header_f));
-        log_debug("nodes:            %8"PRIu64" bytes (%8"PRIu64")",
+        log_info("=== trie on-disk ===");
+        log_info("size:             %8"PRIi64" bytes", size);
+        log_info("header:           %8zu bytes", sizeof(struct trie_header_f));
+        log_info("nodes:            %8"PRIu64" bytes (%8"PRIu64")",
                   t.nodes_count * sizeof(struct trie_node_f), t.nodes_count);
-        log_debug("child pointers:   %8"PRIu64" bytes (%8"PRIu64")",
+        log_info("child pointers:   %8"PRIu64" bytes (%8"PRIu64")",
                   t.children_count * sizeof(struct trie_child_entry_f), t.children_count);
-        log_debug("value pointers:   %8"PRIu64" bytes (%8"PRIu64")",
+        log_info("value pointers:   %8"PRIu64" bytes (%8"PRIu64")",
                   t.values_count * sizeof(struct trie_value_entry_f), t.values_count);
-        log_debug("string store:     %8zu bytes", trie->strings->len);
-        log_debug("strings start:    %8"PRIu64, t.strings_off);
+        log_info("string store:     %8zu bytes", trie->strings->len);
+        log_info("strings start:    %8"PRIu64, t.strings_off);
 
         return 0;
 
@@ -645,25 +645,25 @@ static int adm_hwdb(struct udev *udev, int argc, char *argv[]) {
                         goto out;
                 }
                 STRV_FOREACH(f, files) {
-                        log_debug("reading file '%s'", *f);
+                        log_info("reading file '%s'", *f);
                         import_file(udev, trie, *f);
                 }
                 strv_free(files);
 
                 strbuf_complete(trie->strings);
 
-                log_debug("=== trie in-memory ===");
-                log_debug("nodes:            %8zu bytes (%8zu)",
+                log_info("=== trie in-memory ===");
+                log_info("nodes:            %8zu bytes (%8zu)",
                           trie->nodes_count * sizeof(struct trie_node), trie->nodes_count);
-                log_debug("children arrays:  %8zu bytes (%8zu)",
+                log_info("children arrays:  %8zu bytes (%8zu)",
                           trie->children_count * sizeof(struct trie_child_entry), trie->children_count);
-                log_debug("values arrays:    %8zu bytes (%8zu)",
+                log_info("values arrays:    %8zu bytes (%8zu)",
                           trie->values_count * sizeof(struct trie_value_entry), trie->values_count);
-                log_debug("strings:          %8zu bytes",
+                log_info("strings:          %8zu bytes",
                           trie->strings->len);
-                log_debug("strings incoming: %8zu bytes (%8zu)",
+                log_info("strings incoming: %8zu bytes (%8zu)",
                           trie->strings->in_len, trie->strings->in_count);
-                log_debug("strings dedup'ed: %8zu bytes (%8zu)",
+                log_info("strings dedup'ed: %8zu bytes (%8zu)",
                           trie->strings->dedup_len, trie->strings->dedup_count);
 
                 hwdb_bin = strjoin(root, "/", hwdb_bin_dir, "/hwdb.bin");
diff --git a/src/udev/udevadm-settle.c b/src/udev/udevadm-settle.c
index 0af3e6412..a32ea0efe 100644
--- a/src/udev/udevadm-settle.c
+++ b/src/udev/udevadm-settle.c
@@ -115,7 +115,7 @@ static int adm_settle(struct udev *udev, int argc, char *argv[]) {
                 uctrl = udev_ctrl_new(udev);
                 if (uctrl != NULL) {
                         if (udev_ctrl_send_ping(uctrl, MAX(5U, timeout)) < 0) {
-                                log_debug("no connection to daemon");
+                                log_info("no connection to daemon");
                                 udev_ctrl_unref(uctrl);
                                 return EXIT_SUCCESS;
                         }
@@ -132,7 +132,7 @@ static int adm_settle(struct udev *udev, int argc, char *argv[]) {
         pfd[0].events = POLLIN;
         pfd[0].fd = udev_queue_get_fd(queue);
         if (pfd[0].fd < 0) {
-                log_debug("queue is empty, nothing to watch");
+                log_info("queue is empty, nothing to watch");
                 rc = EXIT_SUCCESS;
                 goto out;
         }
diff --git a/src/udev/udevadm-test.c b/src/udev/udevadm-test.c
index ef1f2f026..a784515ff 100644
--- a/src/udev/udevadm-test.c
+++ b/src/udev/udevadm-test.c
@@ -62,7 +62,7 @@ static int adm_test(struct udev *udev, int argc, char *argv[]) {
                 {}
         };
 
-        log_debug("version %s", PACKAGE_VERSION);
+        log_info("version %s", PACKAGE_VERSION);
 
         while ((c = getopt_long(argc, argv, "a:N:Vh", options, NULL)) >= 0)
                 switch (c) {
diff --git a/src/udev/udevadm-trigger.c b/src/udev/udevadm-trigger.c
index f78a2ba43..591fe7b34 100644
--- a/src/udev/udevadm-trigger.c
+++ b/src/udev/udevadm-trigger.c
@@ -49,7 +49,7 @@ static void exec_list(struct udev_enumerate *udev_enumerate, const char *action)
                 if (fd < 0)
                         continue;
                 if (write(fd, action, strlen(action)) < 0)
-                        log_debug_errno(errno, "error writing '%s' to '%s': %m", action, filename);
+                        log_info_errno(errno, "error writing '%s' to '%s': %m", action, filename);
                 close(fd);
         }
 }
diff --git a/src/udev/udevadm.c b/src/udev/udevadm.c
index 06be1e8af..391e6682c 100644
--- a/src/udev/udevadm.c
+++ b/src/udev/udevadm.c
@@ -73,7 +73,7 @@ static int adm_help(struct udev *udev, int argc, char *argv[]) {
 static int run_command(struct udev *udev, const struct udevadm_cmd *cmd, int argc, char *argv[]) {
         if (cmd->debug)
                 log_set_max_level(LOG_DEBUG);
-        log_debug("calling: %s", cmd->name);
+        log_info("calling: %s", cmd->name);
         return cmd->cmd(udev, argc, argv);
 }
 
diff --git a/src/udev/udevd.c b/src/udev/udevd.c
index 5c757d513..35f702cec 100644
--- a/src/udev/udevd.c
+++ b/src/udev/udevd.c
@@ -408,7 +408,7 @@ static void worker_spawn(Manager *manager, struct event *event) {
 
                         assert(dev);
 
-                        log_debug("seq %llu running", udev_device_get_seqnum(dev));
+                        log_info("seq %llu running", udev_device_get_seqnum(dev));
                         udev_event = udev_event_new(dev);
                         if (udev_event == NULL) {
                                 r = -ENOMEM;
@@ -438,7 +438,7 @@ static void worker_spawn(Manager *manager, struct event *event) {
                                 if (d) {
                                         fd_lock = open(udev_device_get_devnode(d), O_RDONLY|O_CLOEXEC|O_NOFOLLOW|O_NONBLOCK);
                                         if (fd_lock >= 0 && flock(fd_lock, LOCK_SH|LOCK_NB) < 0) {
-                                                log_debug_errno(errno, "Unable to flock(%s), skipping event handling: %m", udev_device_get_devnode(d));
+                                                log_info_errno(errno, "Unable to flock(%s), skipping event handling: %m", udev_device_get_devnode(d));
                                                 fd_lock = safe_close(fd_lock);
                                                 goto skip;
                                         }
@@ -473,7 +473,7 @@ static void worker_spawn(Manager *manager, struct event *event) {
                         udev_monitor_send_device(worker_monitor, NULL, dev);
 
 skip:
-                        log_debug("seq %llu processed", udev_device_get_seqnum(dev));
+                        log_info("seq %llu processed", udev_device_get_seqnum(dev));
 
                         /* send udevd the result of the event execution */
                         r = worker_send_message(manager->worker_watch[WRITE_END]);
@@ -539,7 +539,7 @@ out:
 
                 worker_attach_event(worker, event);
 
-                log_debug("seq %llu forked new worker ["PID_FMT"]", udev_device_get_seqnum(event->dev), pid);
+                log_info("seq %llu forked new worker ["PID_FMT"]", udev_device_get_seqnum(event->dev), pid);
                 break;
         }
         }
@@ -572,7 +572,7 @@ static void event_run(Manager *manager, struct event *event) {
 
         if (hashmap_size(manager->workers) >= arg_children_max) {
                 if (arg_children_max > 1)
-                        log_debug("maximum number (%i) of children reached", hashmap_size(manager->workers));
+                        log_info("maximum number (%i) of children reached", hashmap_size(manager->workers));
                 return;
         }
 
@@ -610,7 +610,7 @@ static int event_queue_insert(Manager *manager, struct udev_device *dev) {
         event->is_block = streq("block", udev_device_get_subsystem(dev));
         event->ifindex = udev_device_get_ifindex(dev);
 
-        log_debug("seq %llu queued, '%s' '%s'", udev_device_get_seqnum(dev),
+        log_info("seq %llu queued, '%s' '%s'", udev_device_get_seqnum(dev),
              udev_device_get_action(dev), udev_device_get_subsystem(dev));
 
         event->state = EVENT_QUEUED;
@@ -882,7 +882,7 @@ static int on_worker(sd_event_source *s, int fd, uint32_t revents, void *userdat
                 /* lookup worker who sent the signal */
                 worker = hashmap_get(manager->workers, PID_TO_PTR(ucred->pid));
                 if (!worker) {
-                        log_debug("worker ["PID_FMT"] returned, but is no longer tracked", ucred->pid);
+                        log_info("worker ["PID_FMT"] returned, but is no longer tracked", ucred->pid);
                         continue;
                 }
 
@@ -940,24 +940,24 @@ static int on_ctrl_msg(sd_event_source *s, int fd, uint32_t revents, void *userd
 
         i = udev_ctrl_get_set_log_level(ctrl_msg);
         if (i >= 0) {
-                log_debug("udevd message (SET_LOG_LEVEL) received, log_priority=%i", i);
+                log_info("udevd message (SET_LOG_LEVEL) received, log_priority=%i", i);
                 log_set_max_level(i);
                 manager_kill_workers(manager);
         }
 
         if (udev_ctrl_get_stop_exec_queue(ctrl_msg) > 0) {
-                log_debug("udevd message (STOP_EXEC_QUEUE) received");
+                log_info("udevd message (STOP_EXEC_QUEUE) received");
                 manager->stop_exec_queue = true;
         }
 
         if (udev_ctrl_get_start_exec_queue(ctrl_msg) > 0) {
-                log_debug("udevd message (START_EXEC_QUEUE) received");
+                log_info("udevd message (START_EXEC_QUEUE) received");
                 manager->stop_exec_queue = false;
                 event_queue_start(manager);
         }
 
         if (udev_ctrl_get_reload(ctrl_msg) > 0) {
-                log_debug("udevd message (RELOAD) received");
+                log_info("udevd message (RELOAD) received");
                 manager_reload(manager);
         }
 
@@ -974,10 +974,10 @@ static int on_ctrl_msg(sd_event_source *s, int fd, uint32_t revents, void *userd
                                 val[0] = '\0';
                                 val = &val[1];
                                 if (val[0] == '\0') {
-                                        log_debug("udevd message (ENV) received, unset '%s'", key);
+                                        log_info("udevd message (ENV) received, unset '%s'", key);
                                         udev_list_entry_add(&manager->properties, key, NULL);
                                 } else {
-                                        log_debug("udevd message (ENV) received, set '%s=%s'", key, val);
+                                        log_info("udevd message (ENV) received, set '%s=%s'", key, val);
                                         udev_list_entry_add(&manager->properties, key, val);
                                 }
                         } else
@@ -988,7 +988,7 @@ static int on_ctrl_msg(sd_event_source *s, int fd, uint32_t revents, void *userd
 
         i = udev_ctrl_get_set_children_max(ctrl_msg);
         if (i >= 0) {
-                log_debug("udevd message (SET_MAX_CHILDREN) received, children_max=%i", i);
+                log_info("udevd message (SET_MAX_CHILDREN) received, children_max=%i", i);
                 arg_children_max = i;
 
                 (void) sd_notifyf(false,
@@ -997,10 +997,10 @@ static int on_ctrl_msg(sd_event_source *s, int fd, uint32_t revents, void *userd
         }
 
         if (udev_ctrl_get_ping(ctrl_msg) > 0)
-                log_debug("udevd message (SYNC) received");
+                log_info("udevd message (SYNC) received");
 
         if (udev_ctrl_get_exit(ctrl_msg) > 0) {
-                log_debug("udevd message (EXIT) received");
+                log_info("udevd message (EXIT) received");
                 manager_exit(manager);
                 /* keep reference to block the client until we exit
                    TODO: deal with several blocking exit requests */
@@ -1084,7 +1084,7 @@ static int synthesize_change(struct udev_device *dev) {
                  * We have partitions but re-reading the partition table did not
                  * work, synthesize "change" for the disk and all partitions.
                  */
-                log_debug("device %s closed, synthesising 'change'", udev_device_get_devnode(dev));
+                log_info("device %s closed, synthesising 'change'", udev_device_get_devnode(dev));
                 strscpyl(filename, sizeof(filename), udev_device_get_syspath(dev), "/uevent", NULL);
                 write_string_file(filename, "change", WRITE_STRING_FILE_CREATE);
 
@@ -1098,7 +1098,7 @@ static int synthesize_change(struct udev_device *dev) {
                         if (!streq_ptr("partition", udev_device_get_devtype(d)))
                                 continue;
 
-                        log_debug("device %s closed, synthesising partition '%s' 'change'",
+                        log_info("device %s closed, synthesising partition '%s' 'change'",
                                   udev_device_get_devnode(dev), udev_device_get_devnode(d));
                         strscpyl(filename, sizeof(filename), udev_device_get_syspath(d), "/uevent", NULL);
                         write_string_file(filename, "change", WRITE_STRING_FILE_CREATE);
@@ -1107,7 +1107,7 @@ static int synthesize_change(struct udev_device *dev) {
                 return 0;
         }
 
-        log_debug("device %s closed, synthesising 'change'", udev_device_get_devnode(dev));
+        log_info("device %s closed, synthesising 'change'", udev_device_get_devnode(dev));
         strscpyl(filename, sizeof(filename), udev_device_get_syspath(dev), "/uevent", NULL);
         write_string_file(filename, "change", WRITE_STRING_FILE_CREATE);
 
@@ -1137,7 +1137,7 @@ static int on_inotify(sd_event_source *s, int fd, uint32_t revents, void *userda
                 if (!dev)
                         continue;
 
-                log_debug("inotify event: %x for %s", e->mask, udev_device_get_devnode(dev));
+                log_info("inotify event: %x for %s", e->mask, udev_device_get_devnode(dev));
                 if (e->mask & IN_CLOSE_WRITE) {
                         synthesize_change(dev);
 
@@ -1196,7 +1196,7 @@ static int on_sigchld(sd_event_source *s, const struct signalfd_siginfo *si, voi
 
                 if (WIFEXITED(status)) {
                         if (WEXITSTATUS(status) == 0)
-                                log_debug("worker ["PID_FMT"] exited", pid);
+                                log_info("worker ["PID_FMT"] exited", pid);
                         else
                                 log_warning("worker ["PID_FMT"] exited with return code %i", pid, WEXITSTATUS(status));
                 } else if (WIFSIGNALED(status)) {
@@ -1240,7 +1240,7 @@ static int on_post(sd_event_source *s, void *userdata) {
                 /* no pending events */
                 if (!hashmap_isempty(manager->workers)) {
                         /* there are idle workers */
-                        log_debug("cleanup idle workers");
+                        log_info("cleanup idle workers");
                         manager_kill_workers(manager);
                 } else {
                         /* we are idle */
@@ -1682,7 +1682,7 @@ int main(int argc, char *argv[]) {
                 if (sched_getaffinity(0, sizeof(cpu_set), &cpu_set) == 0)
                         arg_children_max += CPU_COUNT(&cpu_set) * 2;
 
-                log_debug("set children_max to %u", arg_children_max);
+                log_info("set children_max to %u", arg_children_max);
         }
 
         /* set umask before creating any file/directory */
@@ -1715,7 +1715,7 @@ int main(int argc, char *argv[]) {
                 r = cg_pid_get_path(SYSTEMD_CGROUP_CONTROLLER, 0, &cgroup);
                 if (r < 0) {
                         if (IN_SET(r, -ENOENT, -ENOMEDIUM))
-                                log_debug_errno(r, "did not find dedicated cgroup: %m");
+                                log_info_errno(r, "did not find dedicated cgroup: %m");
                         else
                                 log_warning_errno(r, "failed to get cgroup: %m");
                 }
diff --git a/src/update-done/update-done.c b/src/update-done/update-done.c
index ccf2d4719..7bd1ecb2e 100644
--- a/src/update-done/update-done.c
+++ b/src/update-done/update-done.c
@@ -45,7 +45,7 @@ static int apply_timestamp(const char *path, struct timespec *ts) {
 
         r = write_string_file_atomic_label_ts(path, message, ts);
         if (r == -EROFS)
-                return log_debug("Cannot create \"%s\", file system is read-only.", path);
+                return log_info("Cannot create \"%s\", file system is read-only.", path);
         if (r < 0)
                 return log_error_errno(r, "Failed to write \"%s\": %m", path);
         return 0;
diff --git a/src/update-utmp/update-utmp.c b/src/update-utmp/update-utmp.c
index e16f67be2..16b6abf69 100644
--- a/src/update-utmp/update-utmp.c
+++ b/src/update-utmp/update-utmp.c
@@ -260,7 +260,7 @@ int main(int argc, char *argv[]) {
                 goto finish;
         }
 
-        log_debug("systemd-update-utmp running as pid "PID_FMT, getpid_cached());
+        log_info("systemd-update-utmp running as pid "PID_FMT, getpid_cached());
 
         if (streq(argv[1], "reboot"))
                 r = on_reboot(&c);
@@ -273,7 +273,7 @@ int main(int argc, char *argv[]) {
                 r = -EINVAL;
         }
 
-        log_debug("systemd-update-utmp stopped as pid "PID_FMT, getpid_cached());
+        log_info("systemd-update-utmp stopped as pid "PID_FMT, getpid_cached());
 
 finish:
 #if HAVE_AUDIT
diff --git a/src/vconsole/vconsole-setup.c b/src/vconsole/vconsole-setup.c
index 2e0e09d84..163bfd508 100644
--- a/src/vconsole/vconsole-setup.c
+++ b/src/vconsole/vconsole-setup.c
@@ -113,7 +113,7 @@ static int toggle_utf8(const char *name, int fd, bool utf8) {
         if (r < 0)
                 return log_warning_errno(errno, "Failed to %s iutf8 flag on %s: %m", enable_disable(utf8), name);
 
-        log_debug("UTF-8 kbdmode %sd on %s", enable_disable(utf8), name);
+        log_info("UTF-8 kbdmode %sd on %s", enable_disable(utf8), name);
         return 0;
 }
 
@@ -124,7 +124,7 @@ static int toggle_utf8_sysfs(bool utf8) {
         if (r < 0)
                 return log_warning_errno(r, "Failed to %s sysfs UTF-8 flag: %m", enable_disable(utf8));
 
-        log_debug("Sysfs UTF-8 flag %sd", enable_disable(utf8));
+        log_info("Sysfs UTF-8 flag %sd", enable_disable(utf8));
         return 0;
 }
 
@@ -150,7 +150,7 @@ static int keyboard_load_and_wait(const char *vc, const char *map, const char *m
                 args[i++] = map_toggle;
         args[i++] = NULL;
 
-        log_debug("Executing \"%s\"...",
+        log_info("Executing \"%s\"...",
                   strnull((cmd = strv_join((char**) args, " "))));
 
         r = safe_fork("(loadkeys)", FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_LOG, &pid);
@@ -190,7 +190,7 @@ static int font_load_and_wait(const char *vc, const char *font, const char *map,
                 args[i++] = font;
         args[i++] = NULL;
 
-        log_debug("Executing \"%s\"...",
+        log_info("Executing \"%s\"...",
                   strnull((cmd = strv_join((char**) args, " "))));
 
         r = safe_fork("(setfont)", FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_LOG, &pid);
@@ -319,7 +319,7 @@ static void setup_remaining_vcs(int src_fd, unsigned src_idx, bool utf8) {
                         continue;
                 }
 
-                log_debug("Font and unimap successfully copied to %s", ttyname);
+                log_info("Font and unimap successfully copied to %s", ttyname);
         }
 }
 
diff --git a/src/veritysetup/veritysetup-generator.c b/src/veritysetup/veritysetup-generator.c
index d09f29539..5576887c9 100644
--- a/src/veritysetup/veritysetup-generator.c
+++ b/src/veritysetup/veritysetup-generator.c
@@ -67,7 +67,7 @@ static int create_device(void) {
         if (!arg_root_hash || !arg_data_what || !arg_hash_what)
                 return -EINVAL;
 
-        log_debug("Using root verity data device %s,\n"
+        log_info("Using root verity data device %s,\n"
                   "                  hash device %s,\n"
                   "                and root hash %s.", arg_data_what, arg_hash_what, arg_root_hash);
 
@@ -194,7 +194,7 @@ static int determine_devices(void) {
         if (r < 0)
                 return log_error_errno(r, "Failed to parse root hash: %s", arg_root_hash);
         if (l < sizeof(sd_id128_t)) {
-                log_debug("Root hash is shorter than 128 bits (32 characters), ignoring for discovering verity partition.");
+                log_info("Root hash is shorter than 128 bits (32 characters), ignoring for discovering verity partition.");
                 return 0;
         }
 
-- 
2.17.1

